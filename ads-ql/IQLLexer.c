/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : IQL.g
 *     -                            On : 2022-01-03 14:45:32
 *     -                 for the lexer : IQLLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "IQLLexer.h"
/* ----------------------------------------- */


/** String literals used by IQLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2D, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3C, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x41, 0x44, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x41, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x41, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x41, 0x4E, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x41, 0x52, 0x52, 0x41, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x41, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x41, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x41, 0x56, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x42, 0x49, 0x47, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x42, 0x4F, 0x4F, 0x4C, 0x45, 0x41, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x42, 0x52, 0x45, 0x41, 0x4B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x42, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x43, 0x41, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x43, 0x41, 0x53, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x43, 0x49, 0x44, 0x52, 0x56, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x43, 0x49, 0x44, 0x52, 0x56, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x43, 0x4F, 0x41, 0x4C, 0x45, 0x53, 0x43, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x43, 0x4F, 0x4E, 0x54, 0x49, 0x4E, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x43, 0x4F, 0x55, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x43, 0x52, 0x4F, 0x53, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x44, 0x41, 0x54, 0x45, 0x54, 0x49, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x44, 0x45, 0x43, 0x49, 0x4D, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x44, 0x45, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x44, 0x4F, 0x55, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x45, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x45, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x46, 0x52, 0x4F, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x46, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x46, 0x55, 0x4E, 0x43, 0x54, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x49, 0x46,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x49, 0x4E, 0x4E, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x49, 0x4E, 0x54, 0x4F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x49, 0x4E, 0x54, 0x45, 0x47, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x56, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x49, 0x50, 0x56, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x49, 0x50, 0x56, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x49, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x4A, 0x4F, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x4B, 0x45, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x4C, 0x45, 0x46, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x4D, 0x41, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x4D, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x4E, 0x4F, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x4E, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x4E, 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x4F, 0x55, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x4F, 0x55, 0x54, 0x50, 0x55, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x50, 0x52, 0x45, 0x43, 0x49, 0x53, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x50, 0x52, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_74[]  = { 0x52, 0x41, 0x49, 0x53, 0x45, 0x52, 0x52, 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_75[]  = { 0x52, 0x45, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_76[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_77[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_78[]  = { 0x52, 0x49, 0x47, 0x48, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_79[]  = { 0x52, 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_80[]  = { 0x52, 0x4F, 0x57,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_81[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_82[]  = { 0x53, 0x45, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_83[]  = { 0x53, 0x4D, 0x41, 0x4C, 0x4C, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_84[]  = { 0x53, 0x4F, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_85[]  = { 0x53, 0x55, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_86[]  = { 0x53, 0x57, 0x49, 0x54, 0x43, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_87[]  = { 0x54, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_88[]  = { 0x54, 0x49, 0x4E, 0x59, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_89[]  = { 0x54, 0x52, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_90[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_91[]  = { 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_92[]  = { 0x57, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_93[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_94[]  = { 0x57, 0x48, 0x49, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_95[]  = { 0x57, 0x49, 0x54, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_96[]  = { 0x4E, 0x27,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_97[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_98[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_99[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pIQLLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pIQLLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pIQLLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pIQLLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mT__120    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__121    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__122    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__123    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__124    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__125    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__126    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__127    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__128    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__129    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__130    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__131    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__132    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__133    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__134    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__135    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__136    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__137    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__138    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__139    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__140    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__141    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__142    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__143    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__144    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__145    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__146    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__147    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__148    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ADD    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AND    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ANY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ARRAY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ASC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AVG    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BEGIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BETWEEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BIGINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BOOLEAN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BREAK    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CASE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CAST    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CIDRV4    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CIDRV6    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COALESCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CONTINUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COUNT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CREATE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CROSS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DATETIME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECLARE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECIMAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DESC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DISTINCT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DOUBLE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ELSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_END    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_EXISTS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FALSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FROM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FUNCTION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_GROUP    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_HAVING    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IF    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INDEX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INNER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTO    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTEGER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTERVAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IPV4    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IPV6    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_JOIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_KEY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LEFT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MAX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NOT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NVARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ON    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ORDER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTPUT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRECISION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PROCEDURE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RAISERROR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_REAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURNS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RIGHT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RLIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ROW    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SELECT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SET    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SMALLINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SOME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SUM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SWITCH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_THEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_TINYINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_TRUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_UNION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_VARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHERE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHILE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WITH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDOUBLE_QUOTED_STRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mESCAPE_SEQUENCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mOCTAL_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_DIGIT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mUNICODE_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mML_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSL_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mQUOTED_ID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mBIGINT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTHREE_DIGIT_NUMBER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFOUR_DIGIT_HEX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_BIGINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOATING_POINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mIPV4_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mIPV6_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mEXPONENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOAT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pIQLLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred1_IQL    (pIQLLexer ctx);
static void	IQLLexerFree(pIQLLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
IQLLexerFree  (pIQLLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "IQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return IQLLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pIQLLexer ctx; // Context structure we will build and return

    ctx = (pIQLLexer) ANTLR3_CALLOC(1, sizeof(IQLLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in IQLLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our IQLLexer interface
     */
    ctx->mT__120	= mT__120;
    ctx->mT__121	= mT__121;
    ctx->mT__122	= mT__122;
    ctx->mT__123	= mT__123;
    ctx->mT__124	= mT__124;
    ctx->mT__125	= mT__125;
    ctx->mT__126	= mT__126;
    ctx->mT__127	= mT__127;
    ctx->mT__128	= mT__128;
    ctx->mT__129	= mT__129;
    ctx->mT__130	= mT__130;
    ctx->mT__131	= mT__131;
    ctx->mT__132	= mT__132;
    ctx->mT__133	= mT__133;
    ctx->mT__134	= mT__134;
    ctx->mT__135	= mT__135;
    ctx->mT__136	= mT__136;
    ctx->mT__137	= mT__137;
    ctx->mT__138	= mT__138;
    ctx->mT__139	= mT__139;
    ctx->mT__140	= mT__140;
    ctx->mT__141	= mT__141;
    ctx->mT__142	= mT__142;
    ctx->mT__143	= mT__143;
    ctx->mT__144	= mT__144;
    ctx->mT__145	= mT__145;
    ctx->mT__146	= mT__146;
    ctx->mT__147	= mT__147;
    ctx->mT__148	= mT__148;
    ctx->mTK_ADD	= mTK_ADD;
    ctx->mTK_ALL	= mTK_ALL;
    ctx->mTK_ALTER	= mTK_ALTER;
    ctx->mTK_AND	= mTK_AND;
    ctx->mTK_ANY	= mTK_ANY;
    ctx->mTK_ARRAY	= mTK_ARRAY;
    ctx->mTK_AS	= mTK_AS;
    ctx->mTK_ASC	= mTK_ASC;
    ctx->mTK_AVG	= mTK_AVG;
    ctx->mTK_BEGIN	= mTK_BEGIN;
    ctx->mTK_BETWEEN	= mTK_BETWEEN;
    ctx->mTK_BIGINT	= mTK_BIGINT;
    ctx->mTK_BOOLEAN	= mTK_BOOLEAN;
    ctx->mTK_BREAK	= mTK_BREAK;
    ctx->mTK_BY	= mTK_BY;
    ctx->mTK_CASE	= mTK_CASE;
    ctx->mTK_CAST	= mTK_CAST;
    ctx->mTK_CHAR	= mTK_CHAR;
    ctx->mTK_CIDRV4	= mTK_CIDRV4;
    ctx->mTK_CIDRV6	= mTK_CIDRV6;
    ctx->mTK_COALESCE	= mTK_COALESCE;
    ctx->mTK_CONTINUE	= mTK_CONTINUE;
    ctx->mTK_COUNT	= mTK_COUNT;
    ctx->mTK_CREATE	= mTK_CREATE;
    ctx->mTK_CROSS	= mTK_CROSS;
    ctx->mTK_DATETIME	= mTK_DATETIME;
    ctx->mTK_DECLARE	= mTK_DECLARE;
    ctx->mTK_DECIMAL	= mTK_DECIMAL;
    ctx->mTK_DESC	= mTK_DESC;
    ctx->mTK_DISTINCT	= mTK_DISTINCT;
    ctx->mTK_DOUBLE	= mTK_DOUBLE;
    ctx->mTK_ELSE	= mTK_ELSE;
    ctx->mTK_END	= mTK_END;
    ctx->mTK_EXISTS	= mTK_EXISTS;
    ctx->mTK_FALSE	= mTK_FALSE;
    ctx->mTK_FROM	= mTK_FROM;
    ctx->mTK_FULL	= mTK_FULL;
    ctx->mTK_FUNCTION	= mTK_FUNCTION;
    ctx->mTK_GROUP	= mTK_GROUP;
    ctx->mTK_HAVING	= mTK_HAVING;
    ctx->mTK_IF	= mTK_IF;
    ctx->mTK_IN	= mTK_IN;
    ctx->mTK_INDEX	= mTK_INDEX;
    ctx->mTK_INNER	= mTK_INNER;
    ctx->mTK_INTO	= mTK_INTO;
    ctx->mTK_INTEGER	= mTK_INTEGER;
    ctx->mTK_INTERVAL	= mTK_INTERVAL;
    ctx->mTK_IPV4	= mTK_IPV4;
    ctx->mTK_IPV6	= mTK_IPV6;
    ctx->mTK_IS	= mTK_IS;
    ctx->mTK_JOIN	= mTK_JOIN;
    ctx->mTK_KEY	= mTK_KEY;
    ctx->mTK_LEFT	= mTK_LEFT;
    ctx->mTK_LIKE	= mTK_LIKE;
    ctx->mTK_MAX	= mTK_MAX;
    ctx->mTK_MIN	= mTK_MIN;
    ctx->mTK_NOT	= mTK_NOT;
    ctx->mTK_NULL	= mTK_NULL;
    ctx->mTK_NVARCHAR	= mTK_NVARCHAR;
    ctx->mTK_ON	= mTK_ON;
    ctx->mTK_OR	= mTK_OR;
    ctx->mTK_ORDER	= mTK_ORDER;
    ctx->mTK_OUTER	= mTK_OUTER;
    ctx->mTK_OUTPUT	= mTK_OUTPUT;
    ctx->mTK_PRECISION	= mTK_PRECISION;
    ctx->mTK_PRINT	= mTK_PRINT;
    ctx->mTK_PROCEDURE	= mTK_PROCEDURE;
    ctx->mTK_RAISERROR	= mTK_RAISERROR;
    ctx->mTK_REAL	= mTK_REAL;
    ctx->mTK_RETURN	= mTK_RETURN;
    ctx->mTK_RETURNS	= mTK_RETURNS;
    ctx->mTK_RIGHT	= mTK_RIGHT;
    ctx->mTK_RLIKE	= mTK_RLIKE;
    ctx->mTK_ROW	= mTK_ROW;
    ctx->mTK_SELECT	= mTK_SELECT;
    ctx->mTK_SET	= mTK_SET;
    ctx->mTK_SMALLINT	= mTK_SMALLINT;
    ctx->mTK_SOME	= mTK_SOME;
    ctx->mTK_SUM	= mTK_SUM;
    ctx->mTK_SWITCH	= mTK_SWITCH;
    ctx->mTK_THEN	= mTK_THEN;
    ctx->mTK_TINYINT	= mTK_TINYINT;
    ctx->mTK_TRUE	= mTK_TRUE;
    ctx->mTK_UNION	= mTK_UNION;
    ctx->mTK_VARCHAR	= mTK_VARCHAR;
    ctx->mTK_WHEN	= mTK_WHEN;
    ctx->mTK_WHERE	= mTK_WHERE;
    ctx->mTK_WHILE	= mTK_WHILE;
    ctx->mTK_WITH	= mTK_WITH;
    ctx->mSTRING_LITERAL	= mSTRING_LITERAL;
    ctx->mWSTRING_LITERAL	= mWSTRING_LITERAL;
    ctx->mDOUBLE_QUOTED_STRING_LITERAL	= mDOUBLE_QUOTED_STRING_LITERAL;
    ctx->mESCAPE_SEQUENCE	= mESCAPE_SEQUENCE;
    ctx->mOCTAL_ESCAPE	= mOCTAL_ESCAPE;
    ctx->mHEX_DIGIT	= mHEX_DIGIT;
    ctx->mUNICODE_ESCAPE	= mUNICODE_ESCAPE;
    ctx->mWS	= mWS;
    ctx->mML_COMMENT	= mML_COMMENT;
    ctx->mSL_COMMENT	= mSL_COMMENT;
    ctx->mID	= mID;
    ctx->mQUOTED_ID	= mQUOTED_ID;
    ctx->mBIGINT_SUFFIX	= mBIGINT_SUFFIX;
    ctx->mTHREE_DIGIT_NUMBER	= mTHREE_DIGIT_NUMBER;
    ctx->mFOUR_DIGIT_HEX	= mFOUR_DIGIT_HEX;
    ctx->mHEX_INTEGER_LITERAL	= mHEX_INTEGER_LITERAL;
    ctx->mDECIMAL_INTEGER_LITERAL	= mDECIMAL_INTEGER_LITERAL;
    ctx->mDECIMAL_BIGINT_LITERAL	= mDECIMAL_BIGINT_LITERAL;
    ctx->mFLOATING_POINT_LITERAL	= mFLOATING_POINT_LITERAL;
    ctx->mIPV4_LITERAL	= mIPV4_LITERAL;
    ctx->mIPV6_LITERAL	= mIPV6_LITERAL;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mFLOAT_SUFFIX	= mFLOAT_SUFFIX;
    ctx->mDECIMAL_LITERAL	= mDECIMAL_LITERAL;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= IQLLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    706:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );
 */
static const ANTLR3_INT32 dfa30_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_max[5] =
    {
	57, 102, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa30_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa30_T_empty	    NULL

static const ANTLR3_INT32 dfa30_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4
    };static const ANTLR3_INT32 dfa30_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa30_transitions[] =
{
    dfa30_T1, dfa30_T0, dfa30_T_empty, dfa30_T_empty, dfa30_T_empty	
};


/* Declare tracking structure for Cyclic DFA 30
 */
static
ANTLR3_CYCLIC_DFA cdfa30
    =	{
	    30,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"706:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa30_eot,	    /* EOT table			    */
	    dfa30_eof,	    /* EOF table			    */
	    dfa30_min,	    /* Minimum tokens for each state    */
	    dfa30_max,	    /* Maximum tokens for each state    */
	    dfa30_accept,	/* Accept table			    */
	    dfa30_special,	/* Special transition states	    */
	    dfa30_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 30
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    719:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );
 */
static const ANTLR3_INT32 dfa37_eot[13] =
    {
	-1, -1, -1, -1, -1, -1, 9, -1, -1, -1, 9, 9, 9
    };
static const ANTLR3_INT32 dfa37_eof[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa37_min[13] =
    {
	48, -1, 48, 48, 48, 48, 48, -1, 58, -1, 48, 48, 58
    };
static const ANTLR3_INT32 dfa37_max[13] =
    {
	102, -1, 102, 102, 102, 102, 102, -1, 58, -1, 102, 102, 58
    };
static const ANTLR3_INT32 dfa37_accept[13] =
    {
	-1, 1, -1, -1, -1, -1, -1, 3, -1, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa37_special[13] =
    {	
	-1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa37_T_empty	    NULL

static const ANTLR3_INT32 dfa37_T0[] =
    {
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa37_T1[] =
    {
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, -1, -1, -1, -1, -1, -1, 6, 6, 6, 6, 6, 
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 6, 6, 6, 6, 6
    };static const ANTLR3_INT32 dfa37_T2[] =
    {
	10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 4, -1, -1, -1, -1, -1, -1, 10, 
	10, 10, 10, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa37_T3[] =
    {
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa37_T4[] =
    {
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, -1, -1, -1, -1, -1, -1, 12, 
	12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, 12, 12, 12, 
	12
    };static const ANTLR3_INT32 dfa37_T5[] =
    {
	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, -1, -1, -1, -1, -1, -1, 11, 
	11, 11, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, 11, 11, 11, 
	11
    };static const ANTLR3_INT32 dfa37_T6[] =
    {
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8
    };static const ANTLR3_INT32 dfa37_T7[] =
    {
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa37_T8[] =
    {
	4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa37_transitions[] =
{
    dfa37_T0, dfa37_T_empty, dfa37_T3, dfa37_T7, dfa37_T1, dfa37_T6, dfa37_T2, 
    dfa37_T_empty, dfa37_T8, dfa37_T_empty, dfa37_T5, dfa37_T4, dfa37_T8	
};

static ANTLR3_INT32 dfa37_sst(pIQLLexer ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA37_4;

    	    ANTLR3_MARKER index37_4;


    		LA37_4 = LA(1);

    	 
    	    index37_4 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (((LA37_4 >= '0') && (LA37_4 <= '9')) || ((LA37_4 >= 'A') && (LA37_4 <= 'F')) || ((LA37_4 >= 'a') && (LA37_4 <= 'f'))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA37_4 == ':') && (synpred1_IQL(ctx)))
    	    {
    	        s = 7;
    	    }

    	 
    		SEEK(index37_4);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"719:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );";
    EXCEPTION->decisionNum  = 37;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 37
 */
static
ANTLR3_CYCLIC_DFA cdfa37
    =	{
	    37,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"719:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );",	
	    (CDFA_SPECIAL_FUNC) dfa37_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa37_eot,	    /* EOT table			    */
	    dfa37_eof,	    /* EOF table			    */
	    dfa37_min,	    /* Minimum tokens for each state    */
	    dfa37_max,	    /* Maximum tokens for each state    */
	    dfa37_accept,	/* Accept table			    */
	    dfa37_special,	/* Special transition states	    */
	    dfa37_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 37
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL );
 */
static const ANTLR3_INT32 dfa44_eot[501] =
    {
	-1, -1, -1, -1, -1, -1, 56, 58, -1, -1, -1, -1, 60, -1, 62, -1, 64, 67, 
	-1, -1, 70, -1, -1, -1, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, 54, -1, 138, 138, 
	-1, -1, -1, 143, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 153, 54, 54, 54, 54, 54, 54, 160, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 183, 187, 54, 189, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, -1, 199, 201, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, 143, -1, -1, -1, 144, -1, 138, 
	-1, -1, 232, 54, 234, 54, 236, 237, 54, 239, -1, 240, 54, 54, 54, 54, 54, 
	-1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 262, 54, 54, 
	54, 54, 54, 54, 54, -1, 54, 54, 54, -1, 54, -1, 54, 277, 54, 54, 280, 281, 
	282, 54, 54, -1, 54, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 296, 54, 298, 
	54, 54, 301, 54, 54, 54, 54, 54, 54, 54, 54, 54, 143, -1, -1, 144, 144, 
	138, -1, 54, -1, 54, -1, -1, 54, -1, -1, 54, 54, 54, 54, 54, 327, 328, 
	329, 54, 54, 54, 54, 54, 54, 54, 54, 54, 339, 54, 54, 342, -1, 54, 54, 
	345, 346, 54, 54, 54, 54, 54, 352, 54, 355, 356, 357, -1, 358, 359, -1, 
	-1, -1, 360, 54, 54, 54, 54, 54, 54, 54, 54, 369, 54, 54, 54, -1, 54, -1, 
	54, 375, -1, 54, 377, 54, 379, 54, 54, 382, 54, 54, 385, 143, -1, -1, -1, 
	144, 144, 144, 138, 390, 391, 392, 54, 54, 54, 396, -1, -1, -1, 54, 54, 
	54, 401, 54, 403, 54, 54, 54, -1, 54, 54, -1, 54, 410, -1, -1, 54, 412, 
	54, 414, 415, -1, 54, 54, -1, -1, -1, -1, -1, -1, 54, 419, 420, 54, 54, 
	423, 54, 54, -1, 54, 427, 428, 54, 54, -1, 54, -1, 54, -1, 433, 54, -1, 
	435, 436, -1, 143, 143, -1, 138, -1, -1, -1, 54, 439, 54, -1, 441, 442, 
	54, 54, -1, 445, -1, 54, 54, 54, 54, 450, 451, -1, 54, -1, 453, -1, -1, 
	54, 54, 54, -1, -1, 457, 54, -1, 54, 54, 462, -1, -1, 463, 54, 465, 54, 
	-1, 54, -1, -1, 143, 468, -1, 469, -1, -1, 54, 54, -1, 54, 473, 474, 54, 
	-1, -1, 54, -1, 477, 54, 54, -1, 54, 54, 54, 483, -1, -1, 54, -1, 485, 
	486, -1, -1, 487, 488, 489, -1, -1, 490, 491, -1, 492, 493, 54, 54, 54, 
	-1, 497, -1, -1, -1, -1, -1, -1, -1, -1, -1, 498, 499, 500, -1, -1, -1, 
	-1
    };
static const ANTLR3_INT32 dfa44_eof[501] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_min[501] =
    {
	9, -1, -1, -1, -1, -1, 62, 48, -1, -1, -1, -1, 58, -1, 124, -1, 61, 61, 
	-1, -1, 42, -1, -1, -1, -1, 48, 48, 48, 48, 48, 48, 82, 65, 70, 79, 69, 
	69, 65, 39, 78, 82, 65, 69, 72, 78, 65, 72, -1, -1, -1, 48, -1, 46, 46, 
	-1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 
	76, 68, 82, 48, 71, 48, 48, 71, 79, 69, 48, 48, 65, 68, 65, 69, 48, 48, 
	83, 85, 83, 68, 73, 48, 79, 76, 79, 86, 48, 48, 86, 48, 73, 89, 70, 75, 
	88, 78, 84, 76, 65, -1, 48, 48, 84, 69, 73, 65, 71, 73, 87, 76, 65, 77, 
	77, 73, 69, 78, 85, 73, 82, 69, 84, -1, 48, 46, -1, 43, 48, -1, 46, -1, 
	-1, 48, 48, 48, 69, 48, 48, 65, 48, -1, 48, 73, 87, 73, 76, 65, -1, 69, 
	82, 82, 76, 84, 78, 65, 83, 69, 48, 67, 84, 66, 69, 48, 83, 83, 77, 76, 
	67, 85, 73, -1, 69, 69, 69, -1, 52, -1, 78, 48, 84, 69, 48, 48, 48, 76, 
	82, -1, 69, -1, 69, 67, 78, 67, 83, 76, 85, 72, 75, 48, 69, 48, 76, 69, 
	48, 84, 78, 89, 69, 79, 67, 78, 76, 72, 46, 46, 43, 48, 48, 46, -1, 58, 
	-1, 82, -1, -1, 89, -1, -1, 78, 69, 78, 69, 75, 48, 48, 48, 86, 69, 73, 
	84, 84, 83, 84, 65, 77, 48, 73, 76, 48, -1, 84, 69, 48, 48, 84, 80, 78, 
	88, 82, 48, 71, 48, 48, 48, -1, 48, 48, -1, -1, -1, 48, 67, 82, 82, 85, 
	73, 84, 69, 69, 48, 82, 84, 69, -1, 67, -1, 76, 48, -1, 67, 48, 73, 48, 
	78, 72, 48, 69, 69, 48, 46, -1, 46, 43, 58, 58, 58, 46, 48, 48, 48, 69, 
	84, 65, 48, -1, -1, -1, 52, 83, 78, 48, 69, 48, 73, 82, 65, -1, 78, 69, 
	-1, 83, 48, -1, -1, 73, 48, 71, 48, 48, -1, 69, 86, -1, -1, -1, -1, -1, 
	-1, 72, 48, 48, 84, 83, 48, 68, 82, -1, 78, 48, 48, 84, 73, -1, 72, -1, 
	78, -1, 48, 65, -1, 48, 48, -1, 46, 48, 46, 46, -1, -1, -1, 78, 48, 78, 
	-1, 48, 48, 67, 85, -1, 48, -1, 77, 69, 76, 67, 48, 48, -1, 79, -1, 48, 
	-1, -1, 82, 65, 65, -1, -1, 48, 73, -1, 85, 82, 48, -1, -1, 48, 78, 48, 
	84, -1, 82, -1, -1, 48, 48, -1, 48, -1, -1, 69, 69, -1, 69, 48, 48, 84, 
	-1, -1, 78, -1, 48, 76, 82, -1, 79, 82, 79, 48, -1, -1, 84, -1, 48, 48, 
	-1, -1, 48, 48, 48, -1, -1, 48, 48, -1, 48, 48, 78, 69, 82, -1, 48, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 48, 48, 48, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_max[501] =
    {
	126, -1, -1, -1, -1, -1, 62, 57, -1, -1, -1, -1, 58, -1, 124, -1, 61, 62, 
	-1, -1, 47, -1, -1, -1, -1, 102, 102, 102, 102, 102, 102, 82, 65, 83, 79, 
	69, 73, 73, 86, 85, 82, 79, 87, 82, 78, 65, 73, -1, -1, -1, 102, -1, 120, 
	102, -1, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	102, 84, 89, 82, 122, 71, 102, 102, 71, 79, 69, 122, 102, 65, 68, 85, 79, 
	102, 102, 83, 85, 83, 68, 73, 102, 79, 78, 79, 86, 122, 122, 86, 122, 73, 
	89, 70, 75, 88, 78, 84, 76, 65, -1, 122, 122, 84, 79, 73, 84, 71, 73, 87, 
	84, 65, 77, 77, 73, 69, 78, 85, 73, 82, 73, 84, -1, 101, 102, -1, 102, 
	102, -1, 102, -1, -1, 122, 102, 122, 69, 122, 122, 65, 122, -1, 122, 73, 
	87, 73, 76, 65, -1, 84, 82, 82, 76, 84, 78, 65, 83, 69, 102, 67, 84, 66, 
	69, 122, 83, 83, 77, 76, 67, 85, 73, -1, 69, 69, 79, -1, 54, -1, 78, 122, 
	84, 69, 122, 122, 122, 76, 82, -1, 69, -1, 80, 67, 78, 67, 83, 76, 85, 
	72, 75, 122, 69, 122, 76, 69, 122, 84, 78, 89, 69, 79, 67, 82, 76, 72, 
	101, 102, 102, 102, 102, 102, -1, 58, -1, 82, -1, -1, 89, -1, -1, 78, 69, 
	78, 69, 75, 122, 122, 122, 86, 69, 73, 84, 84, 83, 84, 65, 77, 122, 73, 
	76, 122, -1, 84, 69, 122, 122, 84, 80, 78, 88, 82, 122, 82, 122, 122, 122, 
	-1, 122, 122, -1, -1, -1, 122, 67, 82, 82, 85, 73, 84, 69, 69, 122, 82, 
	84, 69, -1, 67, -1, 76, 122, -1, 67, 122, 73, 122, 78, 72, 122, 69, 69, 
	122, 101, -1, 102, 58, 58, 58, 58, 102, 122, 122, 122, 69, 84, 65, 122, 
	-1, -1, -1, 54, 83, 78, 122, 69, 122, 73, 82, 65, -1, 78, 69, -1, 83, 122, 
	-1, -1, 73, 122, 71, 122, 122, -1, 69, 86, -1, -1, -1, -1, -1, -1, 72, 
	122, 122, 84, 83, 122, 68, 82, -1, 78, 122, 122, 84, 73, -1, 72, -1, 78, 
	-1, 122, 65, -1, 122, 122, -1, 101, 101, 102, 102, -1, -1, -1, 78, 122, 
	78, -1, 122, 122, 67, 85, -1, 122, -1, 77, 69, 76, 67, 122, 122, -1, 79, 
	-1, 122, -1, -1, 82, 65, 65, -1, -1, 122, 73, -1, 85, 82, 122, -1, -1, 
	122, 78, 122, 84, -1, 82, -1, -1, 101, 122, -1, 122, -1, -1, 69, 69, -1, 
	69, 122, 122, 84, -1, -1, 78, -1, 122, 76, 82, -1, 79, 82, 79, 122, -1, 
	-1, 84, -1, 122, 122, -1, -1, 122, 122, 122, -1, -1, 122, 122, -1, 122, 
	122, 78, 69, 82, -1, 122, -1, -1, -1, -1, -1, -1, -1, -1, -1, 122, 122, 
	122, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_accept[501] =
    {
	-1, 1, 2, 3, 4, 5, -1, -1, 8, 9, 10, 11, -1, 13, -1, 15, -1, -1, 21, 22, 
	-1, 26, 27, 28, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 119, 121, 122, -1, 126, -1, -1, 125, 
	6, 23, -1, 7, 132, 12, 24, 14, 18, 16, 19, 20, 17, 123, 124, 25, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 120, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 127, -1, -1, 128, -1, -1, 129, -1, 133, 
	130, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, 44, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 70, -1, -1, -1, 71, -1, 79, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 89, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, 
	31, -1, 33, 34, -1, 37, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 84, 85, 86, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 103, -1, 105, -1, -1, 108, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 131, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 45, 46, 47, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, 
	-1, 61, -1, -1, 65, 66, -1, -1, -1, -1, -1, 74, -1, -1, 77, 78, 80, 82, 
	83, 87, -1, -1, -1, -1, -1, -1, -1, -1, 98, -1, -1, -1, -1, -1, 107, -1, 
	110, -1, 112, -1, -1, 115, -1, -1, 118, -1, -1, -1, -1, 32, 35, 39, -1, 
	-1, -1, 43, -1, -1, -1, -1, 52, -1, 54, -1, -1, -1, -1, -1, -1, 64, -1, 
	68, -1, 72, 73, -1, -1, -1, 91, 92, -1, -1, 95, -1, -1, -1, 101, 102, -1, 
	-1, -1, -1, 113, -1, 116, 117, -1, -1, 41, -1, 48, 49, -1, -1, 53, -1, 
	-1, -1, -1, 60, 63, -1, 69, -1, -1, -1, 93, -1, -1, -1, -1, 99, 104, -1, 
	109, -1, -1, 40, 42, -1, -1, -1, 56, 57, -1, -1, 75, -1, -1, -1, -1, -1, 
	100, -1, 111, 114, 50, 51, 55, 59, 67, 76, 88, -1, -1, -1, 106, 94, 96, 
	97
    };
static const ANTLR3_INT32 dfa44_special[501] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa44_T_empty	    NULL

static const ANTLR3_INT32 dfa44_T0[] =
    {
	271
    };static const ANTLR3_INT32 dfa44_T1[] =
    {
	351
    };static const ANTLR3_INT32 dfa44_T2[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T3[] =
    {
	202
    };static const ANTLR3_INT32 dfa44_T4[] =
    {
	136, -1, 231, 231, 231, 231, 231, 231, 231, 231, 231, 231, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 229, 228, 229, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 229, 228, 229
    };static const ANTLR3_INT32 dfa44_T5[] =
    {
	286, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 287
    };static const ANTLR3_INT32 dfa44_T6[] =
    {
	416
    };static const ANTLR3_INT32 dfa44_T7[] =
    {
	454
    };static const ANTLR3_INT32 dfa44_T8[] =
    {
	417
    };static const ANTLR3_INT32 dfa44_T9[] =
    {
	455
    };static const ANTLR3_INT32 dfa44_T10[] =
    {
	478
    };static const ANTLR3_INT32 dfa44_T11[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 146, 146, 146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 146, 
	146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T12[] =
    {
	133, 134
    };static const ANTLR3_INT32 dfa44_T13[] =
    {
	190
    };static const ANTLR3_INT32 dfa44_T14[] =
    {
	276
    };static const ANTLR3_INT32 dfa44_T15[] =
    {
	191
    };static const ANTLR3_INT32 dfa44_T16[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 146, 146, 146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 146, 
	146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T17[] =
    {
	192
    };static const ANTLR3_INT32 dfa44_T18[] =
    {
	114, -1, -1, -1, 115, -1, -1, 116
    };static const ANTLR3_INT32 dfa44_T19[] =
    {
	278
    };static const ANTLR3_INT32 dfa44_T20[] =
    {
	207, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 208
    };static const ANTLR3_INT32 dfa44_T21[] =
    {
	193
    };static const ANTLR3_INT32 dfa44_T22[] =
    {
	279
    };static const ANTLR3_INT32 dfa44_T23[] =
    {
	194
    };static const ANTLR3_INT32 dfa44_T24[] =
    {
	195
    };static const ANTLR3_INT32 dfa44_T25[] =
    {
	147, -1, -1, -1, -1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa44_T26[] =
    {
	196
    };static const ANTLR3_INT32 dfa44_T27[] =
    {
	197
    };static const ANTLR3_INT32 dfa44_T28[] =
    {
	283
    };static const ANTLR3_INT32 dfa44_T29[] =
    {
	144, -1, 144, -1, -1, 230, 230, 230, 230, 230, 230, 230, 230, 230, 230, 
	59, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 59, 59, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa44_T30[] =
    {
	198
    };static const ANTLR3_INT32 dfa44_T31[] =
    {
	284
    };static const ANTLR3_INT32 dfa44_T32[] =
    {
	361
    };static const ANTLR3_INT32 dfa44_T33[] =
    {
	418
    };static const ANTLR3_INT32 dfa44_T34[] =
    {
	456
    };static const ANTLR3_INT32 dfa44_T35[] =
    {
	479
    };static const ANTLR3_INT32 dfa44_T36[] =
    {
	63
    };static const ANTLR3_INT32 dfa44_T37[] =
    {
	149, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 150
    };static const ANTLR3_INT32 dfa44_T38[] =
    {
	313, -1, 386, 386, 386, 386, 386, 386, 386, 386, 386, 386, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144
    };static const ANTLR3_INT32 dfa44_T39[] =
    {
	61
    };static const ANTLR3_INT32 dfa44_T40[] =
    {
	285
    };static const ANTLR3_INT32 dfa44_T41[] =
    {
	362
    };static const ANTLR3_INT32 dfa44_T42[] =
    {
	363
    };static const ANTLR3_INT32 dfa44_T43[] =
    {
	59
    };static const ANTLR3_INT32 dfa44_T44[] =
    {
	317, 317, 317, 317, 317, 317, 317, 317, 317, 317, 59, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 318, 59, 318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, 59, 
	318, 59, 318
    };static const ANTLR3_INT32 dfa44_T45[] =
    {
	364
    };static const ANTLR3_INT32 dfa44_T46[] =
    {
	421
    };static const ANTLR3_INT32 dfa44_T47[] =
    {
	293
    };static const ANTLR3_INT32 dfa44_T48[] =
    {
	370
    };static const ANTLR3_INT32 dfa44_T49[] =
    {
	426
    };static const ANTLR3_INT32 dfa44_T50[] =
    {
	288
    };static const ANTLR3_INT32 dfa44_T51[] =
    {
	55
    };static const ANTLR3_INT32 dfa44_T52[] =
    {
	365
    };static const ANTLR3_INT32 dfa44_T53[] =
    {
	422
    };static const ANTLR3_INT32 dfa44_T54[] =
    {
	458
    };static const ANTLR3_INT32 dfa44_T55[] =
    {
	480
    };static const ANTLR3_INT32 dfa44_T56[] =
    {
	494
    };static const ANTLR3_INT32 dfa44_T57[] =
    {
	289
    };static const ANTLR3_INT32 dfa44_T58[] =
    {
	366
    };static const ANTLR3_INT32 dfa44_T59[] =
    {
	290
    };static const ANTLR3_INT32 dfa44_T60[] =
    {
	367
    };static const ANTLR3_INT32 dfa44_T61[] =
    {
	424
    };static const ANTLR3_INT32 dfa44_T62[] =
    {
	459
    };static const ANTLR3_INT32 dfa44_T63[] =
    {
	481
    };static const ANTLR3_INT32 dfa44_T64[] =
    {
	495
    };static const ANTLR3_INT32 dfa44_T65[] =
    {
	206
    };static const ANTLR3_INT32 dfa44_T66[] =
    {
	59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, -1, 59, 
	59, 59, 59, 59, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 
	59
    };static const ANTLR3_INT32 dfa44_T67[] =
    {
	291
    };static const ANTLR3_INT32 dfa44_T68[] =
    {
	368
    };static const ANTLR3_INT32 dfa44_T69[] =
    {
	425
    };static const ANTLR3_INT32 dfa44_T70[] =
    {
	460
    };static const ANTLR3_INT32 dfa44_T71[] =
    {
	482
    };static const ANTLR3_INT32 dfa44_T72[] =
    {
	496
    };static const ANTLR3_INT32 dfa44_T73[] =
    {
	292
    };static const ANTLR3_INT32 dfa44_T74[] =
    {
	387, -1, 388, 388, 388, 388, 388, 388, 388, 388, 388, 388, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 144, 144, 144, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144, 144, 144
    };static const ANTLR3_INT32 dfa44_T75[] =
    {
	136, -1, 314, 314, 314, 314, 314, 314, 314, 314, 314, 314, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 316, 315, 316, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 316, 315, 316
    };static const ANTLR3_INT32 dfa44_T76[] =
    {
	209
    };static const ANTLR3_INT32 dfa44_T77[] =
    {
	294
    };static const ANTLR3_INT32 dfa44_T78[] =
    {
	371
    };static const ANTLR3_INT32 dfa44_T79[] =
    {
	212, -1, -1, -1, -1, -1, -1, -1, 213
    };static const ANTLR3_INT32 dfa44_T80[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 461, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T81[] =
    {
	210
    };static const ANTLR3_INT32 dfa44_T82[] =
    {
	295
    };static const ANTLR3_INT32 dfa44_T83[] =
    {
	372
    };static const ANTLR3_INT32 dfa44_T84[] =
    {
	211
    };static const ANTLR3_INT32 dfa44_T85[] =
    {
	297
    };static const ANTLR3_INT32 dfa44_T86[] =
    {
	373
    };static const ANTLR3_INT32 dfa44_T87[] =
    {
	429
    };static const ANTLR3_INT32 dfa44_T88[] =
    {
	100, -1, -1, -1, -1, -1, -1, -1, 101, -1, 102, -1, -1, 103
    };static const ANTLR3_INT32 dfa44_T89[] =
    {
	214
    };static const ANTLR3_INT32 dfa44_T90[] =
    {
	299
    };static const ANTLR3_INT32 dfa44_T91[] =
    {
	374
    };static const ANTLR3_INT32 dfa44_T92[] =
    {
	430
    };static const ANTLR3_INT32 dfa44_T93[] =
    {
	464
    };static const ANTLR3_INT32 dfa44_T94[] =
    {
	484
    };static const ANTLR3_INT32 dfa44_T95[] =
    {
	215
    };static const ANTLR3_INT32 dfa44_T96[] =
    {
	300
    };static const ANTLR3_INT32 dfa44_T97[] =
    {
	216
    };static const ANTLR3_INT32 dfa44_T98[] =
    {
	217
    };static const ANTLR3_INT32 dfa44_T99[] =
    {
	302
    };static const ANTLR3_INT32 dfa44_T100[] =
    {
	313, -1, 437, 437, 437, 437, 437, 437, 437, 437, 437, 437, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144
    };static const ANTLR3_INT32 dfa44_T101[] =
    {
	376
    };static const ANTLR3_INT32 dfa44_T102[] =
    {
	431
    };static const ANTLR3_INT32 dfa44_T103[] =
    {
	387, -1, 388, 388, 388, 388, 388, 388, 388, 388, 388, 388, 59, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 144, 144, 144, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144, 144, 144
    };static const ANTLR3_INT32 dfa44_T104[] =
    {
	57, 57, 57, 57, 57, 57, 57, 57, 57, 57
    };static const ANTLR3_INT32 dfa44_T105[] =
    {
	218
    };static const ANTLR3_INT32 dfa44_T106[] =
    {
	303
    };static const ANTLR3_INT32 dfa44_T107[] =
    {
	246, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 247
    };static const ANTLR3_INT32 dfa44_T108[] =
    {
	219
    };static const ANTLR3_INT32 dfa44_T109[] =
    {
	304
    };static const ANTLR3_INT32 dfa44_T110[] =
    {
	378
    };static const ANTLR3_INT32 dfa44_T111[] =
    {
	432
    };static const ANTLR3_INT32 dfa44_T112[] =
    {
	466
    };static const ANTLR3_INT32 dfa44_T113[] =
    {
	68, -1, -1, -1, -1, 69
    };static const ANTLR3_INT32 dfa44_T114[] =
    {
	220
    };static const ANTLR3_INT32 dfa44_T115[] =
    {
	305
    };static const ANTLR3_INT32 dfa44_T116[] =
    {
	221
    };static const ANTLR3_INT32 dfa44_T117[] =
    {
	306
    };static const ANTLR3_INT32 dfa44_T118[] =
    {
	380
    };static const ANTLR3_INT32 dfa44_T119[] =
    {
	222
    };static const ANTLR3_INT32 dfa44_T120[] =
    {
	307
    };static const ANTLR3_INT32 dfa44_T121[] =
    {
	381
    };static const ANTLR3_INT32 dfa44_T122[] =
    {
	434
    };static const ANTLR3_INT32 dfa44_T123[] =
    {
	467
    };static const ANTLR3_INT32 dfa44_T124[] =
    {
	49, 49, -1, 49, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 49, 18, 48, 23, 24, 21, 15, 47, 9, 10, 8, 19, 5, 6, 
	7, 20, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 12, 1, 17, 2, 16, 11, -1, 
	25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 54, 41, 
	42, 43, 44, 45, 46, 54, 54, 54, 3, -1, 4, 13, 54, 51, 50, 50, 50, 50, 50, 
	50, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, -1, 14, -1, 22
    };static const ANTLR3_INT32 dfa44_T125[] =
    {
	163
    };static const ANTLR3_INT32 dfa44_T126[] =
    {
	249
    };static const ANTLR3_INT32 dfa44_T127[] =
    {
	330
    };static const ANTLR3_INT32 dfa44_T128[] =
    {
	397, -1, 398
    };static const ANTLR3_INT32 dfa44_T129[] =
    {
	383
    };static const ANTLR3_INT32 dfa44_T130[] =
    {
	310
    };static const ANTLR3_INT32 dfa44_T131[] =
    {
	384
    };static const ANTLR3_INT32 dfa44_T132[] =
    {
	225
    };static const ANTLR3_INT32 dfa44_T133[] =
    {
	311
    };static const ANTLR3_INT32 dfa44_T134[] =
    {
	437, 437, 437, 437, 437, 437, 437, 437, 437, 437, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 144
    };static const ANTLR3_INT32 dfa44_T135[] =
    {
	118, -1, -1, -1, 119, -1, -1, -1, 120, -1, -1, 121, -1, -1, 122
    };static const ANTLR3_INT32 dfa44_T136[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 83, 
	77, 77, 77, 77, 77, -1, 84, 85, -1, -1, -1, -1, -1, 86, -1, -1, 87, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T137[] =
    {
	113, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 110, -1, -1, -1, -1, -1, 111, 112
    };static const ANTLR3_INT32 dfa44_T138[] =
    {
	106, -1, -1, -1, 107
    };static const ANTLR3_INT32 dfa44_T139[] =
    {
	108, -1, -1, -1, -1, -1, -1, -1, 109
    };static const ANTLR3_INT32 dfa44_T140[] =
    {
	308, -1, -1, -1, 309
    };static const ANTLR3_INT32 dfa44_T141[] =
    {
	144, -1, 144, -1, -1, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 
	59
    };static const ANTLR3_INT32 dfa44_T142[] =
    {
	167, -1, -1, -1, -1, -1, -1, -1, -1, -1, 168
    };static const ANTLR3_INT32 dfa44_T143[] =
    {
	136, -1, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 140, 139, 140, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 140, 139, 140, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 135
    };static const ANTLR3_INT32 dfa44_T144[] =
    {
	117
    };static const ANTLR3_INT32 dfa44_T145[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 145, 146, 146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 146, 
	146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T146[] =
    {
	136, -1, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 140, 139, 140, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 140, 139, 140
    };static const ANTLR3_INT32 dfa44_T147[] =
    {
	136, -1, 227, 227, 227, 227, 227, 227, 227, 227, 227, 227, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 229, 228, 229, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 229, 228, 229
    };static const ANTLR3_INT32 dfa44_T148[] =
    {
	98
    };static const ANTLR3_INT32 dfa44_T149[] =
    {
	99
    };static const ANTLR3_INT32 dfa44_T150[] =
    {
	223, -1, -1, -1, 224
    };static const ANTLR3_INT32 dfa44_T151[] =
    {
	65, 66
    };static const ANTLR3_INT32 dfa44_T152[] =
    {
	273, -1, -1, -1, -1, -1, -1, -1, -1, -1, 272
    };static const ANTLR3_INT32 dfa44_T153[] =
    {
	104
    };static const ANTLR3_INT32 dfa44_T154[] =
    {
	105
    };static const ANTLR3_INT32 dfa44_T155[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 184, 54, 54, 54, 54, 54, 54, 54, 54, 54, 185, 54, 54, 54, 54, 54, 
	186, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T156[] =
    {
	233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 59, -1, -1, -1, -1, -1, 
	-1, 233, 233, 233, 233, 233, 233, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 233, 233, 
	233, 233, 233, 233, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54
    };static const ANTLR3_INT32 dfa44_T157[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 88, 
	77, 77, 77, 89, 77, -1, -1, 90, -1, -1, -1, -1, -1, 91, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T158[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 146, 146, 146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 169, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 146, 
	146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T159[] =
    {
	179, -1, 180
    };static const ANTLR3_INT32 dfa44_T160[] =
    {
	233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 59, -1, -1, -1, -1, -1, 
	-1, 233, 233, 233, 233, 233, 233, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, 233, 
	233, 233, 233, 233
    };static const ANTLR3_INT32 dfa44_T161[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 95, 
	77, 77, 77, 77, 77, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, 
	-1, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T162[] =
    {
	235
    };static const ANTLR3_INT32 dfa44_T163[] =
    {
	320
    };static const ANTLR3_INT32 dfa44_T164[] =
    {
	151
    };static const ANTLR3_INT32 dfa44_T165[] =
    {
	238
    };static const ANTLR3_INT32 dfa44_T166[] =
    {
	144, -1, 144, -1, -1, 317, 317, 317, 317, 317, 317, 317, 317, 317, 317, 
	59, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 59, 59, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa44_T167[] =
    {
	321
    };static const ANTLR3_INT32 dfa44_T168[] =
    {
	226, 226, 226, 226, 226, 226, 226, 226, 226, 226, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 144
    };static const ANTLR3_INT32 dfa44_T169[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 146, 146, 146, -1, -1, -1, -1, -1, 177, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 
	146, 146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T170[] =
    {
	154
    };static const ANTLR3_INT32 dfa44_T171[] =
    {
	123, -1, -1, -1, -1, -1, -1, -1, 124, -1, 125, -1, -1, -1, -1, -1, 126, 
	-1, 127
    };static const ANTLR3_INT32 dfa44_T172[] =
    {
	241
    };static const ANTLR3_INT32 dfa44_T173[] =
    {
	322
    };static const ANTLR3_INT32 dfa44_T174[] =
    {
	57, 57, 57, 57, 57, 57, 57, 57, 57, 57, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 144
    };static const ANTLR3_INT32 dfa44_T175[] =
    {
	242
    };static const ANTLR3_INT32 dfa44_T176[] =
    {
	323
    };static const ANTLR3_INT32 dfa44_T177[] =
    {
	393
    };static const ANTLR3_INT32 dfa44_T178[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 152, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T179[] =
    {
	438
    };static const ANTLR3_INT32 dfa44_T180[] =
    {
	157
    };static const ANTLR3_INT32 dfa44_T181[] =
    {
	243
    };static const ANTLR3_INT32 dfa44_T182[] =
    {
	324
    };static const ANTLR3_INT32 dfa44_T183[] =
    {
	394
    };static const ANTLR3_INT32 dfa44_T184[] =
    {
	158
    };static const ANTLR3_INT32 dfa44_T185[] =
    {
	244
    };static const ANTLR3_INT32 dfa44_T186[] =
    {
	325
    };static const ANTLR3_INT32 dfa44_T187[] =
    {
	395
    };static const ANTLR3_INT32 dfa44_T188[] =
    {
	440
    };static const ANTLR3_INT32 dfa44_T189[] =
    {
	387, -1, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 144, 144, 144, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144, 144, 144
    };static const ANTLR3_INT32 dfa44_T190[] =
    {
	159
    };static const ANTLR3_INT32 dfa44_T191[] =
    {
	245
    };static const ANTLR3_INT32 dfa44_T192[] =
    {
	326
    };static const ANTLR3_INT32 dfa44_T193[] =
    {
	136, -1, 319, 319, 319, 319, 319, 319, 319, 319, 319, 319, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 316, 315, 316, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 316, 315, 316
    };static const ANTLR3_INT32 dfa44_T194[] =
    {
	353, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 354
    };static const ANTLR3_INT32 dfa44_T195[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 77, 
	77, 77, 71, 77, 77, -1, -1, -1, -1, -1, 72, -1, 73, -1, -1, -1, 74, 75, 
	-1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T196[] =
    {
	162
    };static const ANTLR3_INT32 dfa44_T197[] =
    {
	248
    };static const ANTLR3_INT32 dfa44_T198[] =
    {
	131
    };static const ANTLR3_INT32 dfa44_T199[] =
    {
	132
    };static const ANTLR3_INT32 dfa44_T200[] =
    {
	250
    };static const ANTLR3_INT32 dfa44_T201[] =
    {
	331
    };static const ANTLR3_INT32 dfa44_T202[] =
    {
	399
    };static const ANTLR3_INT32 dfa44_T203[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 77, 
	77, 77, 77, 78, 77, -1, -1, 79, -1, -1, -1, -1, -1, 80, -1, -1, 81, -1, 
	-1, -1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T204[] =
    {
	188
    };static const ANTLR3_INT32 dfa44_T205[] =
    {
	443
    };static const ANTLR3_INT32 dfa44_T206[] =
    {
	470
    };static const ANTLR3_INT32 dfa44_T207[] =
    {
	274, -1, 275
    };static const ANTLR3_INT32 dfa44_T208[] =
    {
	251
    };static const ANTLR3_INT32 dfa44_T209[] =
    {
	332
    };static const ANTLR3_INT32 dfa44_T210[] =
    {
	400
    };static const ANTLR3_INT32 dfa44_T211[] =
    {
	444
    };static const ANTLR3_INT32 dfa44_T212[] =
    {
	471
    };static const ANTLR3_INT32 dfa44_T213[] =
    {
	252
    };static const ANTLR3_INT32 dfa44_T214[] =
    {
	333
    };static const ANTLR3_INT32 dfa44_T215[] =
    {
	313, -1, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 144, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144
    };static const ANTLR3_INT32 dfa44_T216[] =
    {
	387, -1, 389, 389, 389, 389, 389, 389, 389, 389, 389, 389, 59, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 144, 144, 144, -1, -1, -1, -1, -1, 141, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 144, 144, 144
    };static const ANTLR3_INT32 dfa44_T217[] =
    {
	253
    };static const ANTLR3_INT32 dfa44_T218[] =
    {
	334
    };static const ANTLR3_INT32 dfa44_T219[] =
    {
	402
    };static const ANTLR3_INT32 dfa44_T220[] =
    {
	128, 129, -1, -1, -1, -1, -1, -1, -1, -1, 130
    };static const ANTLR3_INT32 dfa44_T221[] =
    {
	254
    };static const ANTLR3_INT32 dfa44_T222[] =
    {
	335
    };static const ANTLR3_INT32 dfa44_T223[] =
    {
	255
    };static const ANTLR3_INT32 dfa44_T224[] =
    {
	233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 59, -1, -1, -1, -1, -1, 
	-1, 233, 233, 233, 233, 233, 233, -1, -1, 257, -1, -1, 256, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 233, 
	233, 233, 233, 233, 233
    };static const ANTLR3_INT32 dfa44_T225[] =
    {
	336
    };static const ANTLR3_INT32 dfa44_T226[] =
    {
	404
    };static const ANTLR3_INT32 dfa44_T227[] =
    {
	446
    };static const ANTLR3_INT32 dfa44_T228[] =
    {
	472
    };static const ANTLR3_INT32 dfa44_T229[] =
    {
	337
    };static const ANTLR3_INT32 dfa44_T230[] =
    {
	405
    };static const ANTLR3_INT32 dfa44_T231[] =
    {
	447
    };static const ANTLR3_INT32 dfa44_T232[] =
    {
	338
    };static const ANTLR3_INT32 dfa44_T233[] =
    {
	406
    };static const ANTLR3_INT32 dfa44_T234[] =
    {
	448
    };static const ANTLR3_INT32 dfa44_T235[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 170, 146, 146, 146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 171, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 146, 
	146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T236[] =
    {
	258
    };static const ANTLR3_INT32 dfa44_T237[] =
    {
	172
    };static const ANTLR3_INT32 dfa44_T238[] =
    {
	259
    };static const ANTLR3_INT32 dfa44_T239[] =
    {
	340
    };static const ANTLR3_INT32 dfa44_T240[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 77, 
	77, 77, 77, 77, 77, -1, -1, -1, -1, -1, 92, -1, 93, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 94, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T241[] =
    {
	407
    };static const ANTLR3_INT32 dfa44_T242[] =
    {
	449
    };static const ANTLR3_INT32 dfa44_T243[] =
    {
	475
    };static const ANTLR3_INT32 dfa44_T244[] =
    {
	173
    };static const ANTLR3_INT32 dfa44_T245[] =
    {
	260
    };static const ANTLR3_INT32 dfa44_T246[] =
    {
	341
    };static const ANTLR3_INT32 dfa44_T247[] =
    {
	408
    };static const ANTLR3_INT32 dfa44_T248[] =
    {
	174
    };static const ANTLR3_INT32 dfa44_T249[] =
    {
	261
    };static const ANTLR3_INT32 dfa44_T250[] =
    {
	175
    };static const ANTLR3_INT32 dfa44_T251[] =
    {
	176
    };static const ANTLR3_INT32 dfa44_T252[] =
    {
	263
    };static const ANTLR3_INT32 dfa44_T253[] =
    {
	343
    };static const ANTLR3_INT32 dfa44_T254[] =
    {
	409
    };static const ANTLR3_INT32 dfa44_T255[] =
    {
	77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 59, -1, -1, -1, -1, -1, -1, 77, 
	77, 77, 77, 77, 77, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, 77, 77, 77, 77, 
	77
    };static const ANTLR3_INT32 dfa44_T256[] =
    {
	164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 165, -1, -1, -1, -1, 
	-1, -1, 166
    };static const ANTLR3_INT32 dfa44_T257[] =
    {
	264
    };static const ANTLR3_INT32 dfa44_T258[] =
    {
	344
    };static const ANTLR3_INT32 dfa44_T259[] =
    {
	178
    };static const ANTLR3_INT32 dfa44_T260[] =
    {
	265
    };static const ANTLR3_INT32 dfa44_T261[] =
    {
	266
    };static const ANTLR3_INT32 dfa44_T262[] =
    {
	203, -1, -1, -1, 204, -1, -1, -1, -1, -1, 205
    };static const ANTLR3_INT32 dfa44_T263[] =
    {
	267
    };static const ANTLR3_INT32 dfa44_T264[] =
    {
	347
    };static const ANTLR3_INT32 dfa44_T265[] =
    {
	411
    };static const ANTLR3_INT32 dfa44_T266[] =
    {
	452
    };static const ANTLR3_INT32 dfa44_T267[] =
    {
	476
    };static const ANTLR3_INT32 dfa44_T268[] =
    {
	181
    };static const ANTLR3_INT32 dfa44_T269[] =
    {
	268
    };static const ANTLR3_INT32 dfa44_T270[] =
    {
	348
    };static const ANTLR3_INT32 dfa44_T271[] =
    {
	146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, -1, -1, -1, 
	-1, 146, 146, 146, 146, 146, 146, 155, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 146, 
	146, 146, 146, 146, 146
    };static const ANTLR3_INT32 dfa44_T272[] =
    {
	182
    };static const ANTLR3_INT32 dfa44_T273[] =
    {
	269
    };static const ANTLR3_INT32 dfa44_T274[] =
    {
	349
    };static const ANTLR3_INT32 dfa44_T275[] =
    {
	413
    };static const ANTLR3_INT32 dfa44_T276[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 200, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T277[] =
    {
	270
    };static const ANTLR3_INT32 dfa44_T278[] =
    {
	350
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa44_transitions[] =
{
    dfa44_T124, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T51, dfa44_T104, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T43, dfa44_T_empty, dfa44_T39, dfa44_T_empty, 
    dfa44_T36, dfa44_T151, dfa44_T_empty, dfa44_T_empty, dfa44_T113, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T195, dfa44_T203, 
    dfa44_T136, dfa44_T157, dfa44_T240, dfa44_T161, dfa44_T148, dfa44_T149, 
    dfa44_T88, dfa44_T153, dfa44_T154, dfa44_T138, dfa44_T139, dfa44_T137, 
    dfa44_T18, dfa44_T144, dfa44_T135, dfa44_T171, dfa44_T220, dfa44_T198, 
    dfa44_T199, dfa44_T12, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T255, dfa44_T_empty, dfa44_T143, dfa44_T146, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T174, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T145, dfa44_T25, dfa44_T37, dfa44_T164, dfa44_T178, dfa44_T170, 
    dfa44_T11, dfa44_T271, dfa44_T180, dfa44_T184, dfa44_T190, dfa44_T2, 
    dfa44_T16, dfa44_T196, dfa44_T125, dfa44_T256, dfa44_T142, dfa44_T158, 
    dfa44_T235, dfa44_T237, dfa44_T244, dfa44_T248, dfa44_T250, dfa44_T251, 
    dfa44_T169, dfa44_T259, dfa44_T159, dfa44_T268, dfa44_T272, dfa44_T2, 
    dfa44_T155, dfa44_T204, dfa44_T2, dfa44_T13, dfa44_T15, dfa44_T17, dfa44_T21, 
    dfa44_T23, dfa44_T24, dfa44_T26, dfa44_T27, dfa44_T30, dfa44_T_empty, 
    dfa44_T2, dfa44_T276, dfa44_T3, dfa44_T262, dfa44_T65, dfa44_T20, dfa44_T76, 
    dfa44_T81, dfa44_T84, dfa44_T79, dfa44_T89, dfa44_T95, dfa44_T97, dfa44_T98, 
    dfa44_T105, dfa44_T108, dfa44_T114, dfa44_T116, dfa44_T119, dfa44_T150, 
    dfa44_T132, dfa44_T_empty, dfa44_T168, dfa44_T147, dfa44_T_empty, dfa44_T29, 
    dfa44_T66, dfa44_T_empty, dfa44_T4, dfa44_T_empty, dfa44_T_empty, dfa44_T156, 
    dfa44_T160, dfa44_T2, dfa44_T162, dfa44_T2, dfa44_T2, dfa44_T165, dfa44_T2, 
    dfa44_T_empty, dfa44_T2, dfa44_T172, dfa44_T175, dfa44_T181, dfa44_T185, 
    dfa44_T191, dfa44_T_empty, dfa44_T107, dfa44_T197, dfa44_T126, dfa44_T200, 
    dfa44_T208, dfa44_T213, dfa44_T217, dfa44_T221, dfa44_T223, dfa44_T224, 
    dfa44_T236, dfa44_T238, dfa44_T245, dfa44_T249, dfa44_T2, dfa44_T252, 
    dfa44_T257, dfa44_T260, dfa44_T261, dfa44_T263, dfa44_T269, dfa44_T273, 
    dfa44_T_empty, dfa44_T277, dfa44_T0, dfa44_T152, dfa44_T_empty, dfa44_T207, 
    dfa44_T_empty, dfa44_T14, dfa44_T2, dfa44_T19, dfa44_T22, dfa44_T2, 
    dfa44_T2, dfa44_T2, dfa44_T28, dfa44_T31, dfa44_T_empty, dfa44_T40, 
    dfa44_T_empty, dfa44_T5, dfa44_T50, dfa44_T57, dfa44_T59, dfa44_T67, 
    dfa44_T73, dfa44_T47, dfa44_T77, dfa44_T82, dfa44_T2, dfa44_T85, dfa44_T2, 
    dfa44_T90, dfa44_T96, dfa44_T2, dfa44_T99, dfa44_T106, dfa44_T109, dfa44_T115, 
    dfa44_T117, dfa44_T120, dfa44_T140, dfa44_T130, dfa44_T133, dfa44_T215, 
    dfa44_T75, dfa44_T166, dfa44_T66, dfa44_T44, dfa44_T193, dfa44_T_empty, 
    dfa44_T43, dfa44_T_empty, dfa44_T163, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T167, dfa44_T_empty, dfa44_T_empty, dfa44_T173, dfa44_T176, dfa44_T182, 
    dfa44_T186, dfa44_T192, dfa44_T2, dfa44_T2, dfa44_T2, dfa44_T127, dfa44_T201, 
    dfa44_T209, dfa44_T214, dfa44_T218, dfa44_T222, dfa44_T225, dfa44_T229, 
    dfa44_T232, dfa44_T2, dfa44_T239, dfa44_T246, dfa44_T2, dfa44_T_empty, 
    dfa44_T253, dfa44_T258, dfa44_T2, dfa44_T2, dfa44_T264, dfa44_T270, 
    dfa44_T274, dfa44_T278, dfa44_T1, dfa44_T2, dfa44_T194, dfa44_T2, dfa44_T2, 
    dfa44_T2, dfa44_T_empty, dfa44_T2, dfa44_T2, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T2, dfa44_T32, dfa44_T41, dfa44_T42, dfa44_T45, 
    dfa44_T52, dfa44_T58, dfa44_T60, dfa44_T68, dfa44_T2, dfa44_T48, dfa44_T78, 
    dfa44_T83, dfa44_T_empty, dfa44_T86, dfa44_T_empty, dfa44_T91, dfa44_T2, 
    dfa44_T_empty, dfa44_T101, dfa44_T2, dfa44_T110, dfa44_T2, dfa44_T118, 
    dfa44_T121, dfa44_T2, dfa44_T129, dfa44_T131, dfa44_T2, dfa44_T38, dfa44_T_empty, 
    dfa44_T103, dfa44_T141, dfa44_T43, dfa44_T43, dfa44_T43, dfa44_T216, 
    dfa44_T2, dfa44_T2, dfa44_T2, dfa44_T177, dfa44_T183, dfa44_T187, dfa44_T2, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T128, dfa44_T202, 
    dfa44_T210, dfa44_T2, dfa44_T219, dfa44_T2, dfa44_T226, dfa44_T230, 
    dfa44_T233, dfa44_T_empty, dfa44_T241, dfa44_T247, dfa44_T_empty, dfa44_T254, 
    dfa44_T2, dfa44_T_empty, dfa44_T_empty, dfa44_T265, dfa44_T2, dfa44_T275, 
    dfa44_T2, dfa44_T2, dfa44_T_empty, dfa44_T6, dfa44_T8, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T33, dfa44_T2, dfa44_T2, dfa44_T46, dfa44_T53, dfa44_T2, dfa44_T61, 
    dfa44_T69, dfa44_T_empty, dfa44_T49, dfa44_T2, dfa44_T2, dfa44_T87, 
    dfa44_T92, dfa44_T_empty, dfa44_T102, dfa44_T_empty, dfa44_T111, dfa44_T_empty, 
    dfa44_T2, dfa44_T122, dfa44_T_empty, dfa44_T2, dfa44_T2, dfa44_T_empty, 
    dfa44_T100, dfa44_T134, dfa44_T74, dfa44_T189, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T179, dfa44_T2, dfa44_T188, dfa44_T_empty, dfa44_T2, 
    dfa44_T2, dfa44_T205, dfa44_T211, dfa44_T_empty, dfa44_T2, dfa44_T_empty, 
    dfa44_T227, dfa44_T231, dfa44_T234, dfa44_T242, dfa44_T2, dfa44_T2, 
    dfa44_T_empty, dfa44_T266, dfa44_T_empty, dfa44_T2, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T7, dfa44_T9, dfa44_T34, dfa44_T_empty, dfa44_T_empty, dfa44_T2, 
    dfa44_T54, dfa44_T_empty, dfa44_T62, dfa44_T70, dfa44_T80, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T2, dfa44_T93, dfa44_T2, dfa44_T112, dfa44_T_empty, 
    dfa44_T123, dfa44_T_empty, dfa44_T_empty, dfa44_T134, dfa44_T2, dfa44_T_empty, 
    dfa44_T2, dfa44_T_empty, dfa44_T_empty, dfa44_T206, dfa44_T212, dfa44_T_empty, 
    dfa44_T228, dfa44_T2, dfa44_T2, dfa44_T243, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T267, dfa44_T_empty, dfa44_T2, dfa44_T10, dfa44_T35, dfa44_T_empty, 
    dfa44_T55, dfa44_T63, dfa44_T71, dfa44_T2, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T94, dfa44_T_empty, dfa44_T2, dfa44_T2, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T2, dfa44_T2, dfa44_T2, dfa44_T_empty, dfa44_T_empty, dfa44_T2, 
    dfa44_T2, dfa44_T_empty, dfa44_T2, dfa44_T2, dfa44_T56, dfa44_T64, dfa44_T72, 
    dfa44_T_empty, dfa44_T2, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T2, dfa44_T2, dfa44_T2, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty	
};


/* Declare tracking structure for Cyclic DFA 44
 */
static
ANTLR3_CYCLIC_DFA cdfa44
    =	{
	    44,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa44_eot,	    /* EOT table			    */
	    dfa44_eof,	    /* EOF table			    */
	    dfa44_min,	    /* Minimum tokens for each state    */
	    dfa44_max,	    /* Maximum tokens for each state    */
	    dfa44_accept,	/* Accept table			    */
	    dfa44_special,	/* Special transition states	    */
	    dfa44_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 44
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:8: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__120
 *
 * Looks to match the characters the constitute the token T__120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__120(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__120;
       
    
    // IQL.g:7:8: ( ';' )
    // IQL.g:7:10: ';'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__120Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__120Ex; /* Prevent compiler warnings */
    ruleT__120Ex: ;

}
// $ANTLR end T__120

//   Comes from: 8:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__121
 *
 * Looks to match the characters the constitute the token T__121
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__121(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__121;
       
    
    // IQL.g:8:8: ( '=' )
    // IQL.g:8:10: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__121Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__121Ex; /* Prevent compiler warnings */
    ruleT__121Ex: ;

}
// $ANTLR end T__121

//   Comes from: 9:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__122
 *
 * Looks to match the characters the constitute the token T__122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__122(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__122;
       
    
    // IQL.g:9:8: ( '[' )
    // IQL.g:9:10: '['
    {
        MATCHC('['); 
        if  (HASEXCEPTION())
        {
            goto ruleT__122Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__122Ex; /* Prevent compiler warnings */
    ruleT__122Ex: ;

}
// $ANTLR end T__122

//   Comes from: 10:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__123
 *
 * Looks to match the characters the constitute the token T__123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__123(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__123;
       
    
    // IQL.g:10:8: ( ']' )
    // IQL.g:10:10: ']'
    {
        MATCHC(']'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__123Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__123Ex; /* Prevent compiler warnings */
    ruleT__123Ex: ;

}
// $ANTLR end T__123

//   Comes from: 11:8: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__124
 *
 * Looks to match the characters the constitute the token T__124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__124(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__124;
       
    
    // IQL.g:11:8: ( ',' )
    // IQL.g:11:10: ','
    {
        MATCHC(','); 
        if  (HASEXCEPTION())
        {
            goto ruleT__124Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__124Ex; /* Prevent compiler warnings */
    ruleT__124Ex: ;

}
// $ANTLR end T__124

//   Comes from: 12:8: ( '->' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__125
 *
 * Looks to match the characters the constitute the token T__125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__125(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__125;
       
    
    // IQL.g:12:8: ( '->' )
    // IQL.g:12:10: '->'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleT__125Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__125Ex; /* Prevent compiler warnings */
    ruleT__125Ex: ;

}
// $ANTLR end T__125

//   Comes from: 13:8: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__126
 *
 * Looks to match the characters the constitute the token T__126
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__126(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__126;
       
    
    // IQL.g:13:8: ( '.' )
    // IQL.g:13:10: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__126Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__126Ex; /* Prevent compiler warnings */
    ruleT__126Ex: ;

}
// $ANTLR end T__126

//   Comes from: 14:8: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__127
 *
 * Looks to match the characters the constitute the token T__127
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__127(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__127;
       
    
    // IQL.g:14:8: ( '*' )
    // IQL.g:14:10: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__127Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__127Ex; /* Prevent compiler warnings */
    ruleT__127Ex: ;

}
// $ANTLR end T__127

//   Comes from: 15:8: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__128
 *
 * Looks to match the characters the constitute the token T__128
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__128(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__128;
       
    
    // IQL.g:15:8: ( '(' )
    // IQL.g:15:10: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__128Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__128Ex; /* Prevent compiler warnings */
    ruleT__128Ex: ;

}
// $ANTLR end T__128

//   Comes from: 16:8: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__129
 *
 * Looks to match the characters the constitute the token T__129
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__129(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__129;
       
    
    // IQL.g:16:8: ( ')' )
    // IQL.g:16:10: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__129Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__129Ex; /* Prevent compiler warnings */
    ruleT__129Ex: ;

}
// $ANTLR end T__129

//   Comes from: 17:8: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__130
 *
 * Looks to match the characters the constitute the token T__130
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__130(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__130;
       
    
    // IQL.g:17:8: ( '?' )
    // IQL.g:17:10: '?'
    {
        MATCHC('?'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__130Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__130Ex; /* Prevent compiler warnings */
    ruleT__130Ex: ;

}
// $ANTLR end T__130

//   Comes from: 18:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__131
 *
 * Looks to match the characters the constitute the token T__131
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__131(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__131;
       
    
    // IQL.g:18:8: ( ':' )
    // IQL.g:18:10: ':'
    {
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__131Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__131Ex; /* Prevent compiler warnings */
    ruleT__131Ex: ;

}
// $ANTLR end T__131

//   Comes from: 19:8: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__132
 *
 * Looks to match the characters the constitute the token T__132
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__132(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__132;
       
    
    // IQL.g:19:8: ( '^' )
    // IQL.g:19:10: '^'
    {
        MATCHC('^'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__132Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__132Ex; /* Prevent compiler warnings */
    ruleT__132Ex: ;

}
// $ANTLR end T__132

//   Comes from: 20:8: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__133
 *
 * Looks to match the characters the constitute the token T__133
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__133(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__133;
       
    
    // IQL.g:20:8: ( '|' )
    // IQL.g:20:10: '|'
    {
        MATCHC('|'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__133Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__133Ex; /* Prevent compiler warnings */
    ruleT__133Ex: ;

}
// $ANTLR end T__133

//   Comes from: 21:8: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__134
 *
 * Looks to match the characters the constitute the token T__134
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__134(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__134;
       
    
    // IQL.g:21:8: ( '&' )
    // IQL.g:21:10: '&'
    {
        MATCHC('&'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__134Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__134Ex; /* Prevent compiler warnings */
    ruleT__134Ex: ;

}
// $ANTLR end T__134

//   Comes from: 22:8: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__135
 *
 * Looks to match the characters the constitute the token T__135
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__135(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__135;
       
    
    // IQL.g:22:8: ( '>' )
    // IQL.g:22:10: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__135Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__135Ex; /* Prevent compiler warnings */
    ruleT__135Ex: ;

}
// $ANTLR end T__135

//   Comes from: 23:8: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__136
 *
 * Looks to match the characters the constitute the token T__136
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__136(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__136;
       
    
    // IQL.g:23:8: ( '<' )
    // IQL.g:23:10: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__136Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__136Ex; /* Prevent compiler warnings */
    ruleT__136Ex: ;

}
// $ANTLR end T__136

//   Comes from: 24:8: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__137
 *
 * Looks to match the characters the constitute the token T__137
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__137(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__137;
       
    
    // IQL.g:24:8: ( '>=' )
    // IQL.g:24:10: '>='
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleT__137Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__137Ex; /* Prevent compiler warnings */
    ruleT__137Ex: ;

}
// $ANTLR end T__137

//   Comes from: 25:8: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__138
 *
 * Looks to match the characters the constitute the token T__138
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__138(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__138;
       
    
    // IQL.g:25:8: ( '<=' )
    // IQL.g:25:10: '<='
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleT__138Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__138Ex; /* Prevent compiler warnings */
    ruleT__138Ex: ;

}
// $ANTLR end T__138

//   Comes from: 26:8: ( '<>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__139
 *
 * Looks to match the characters the constitute the token T__139
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__139(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__139;
       
    
    // IQL.g:26:8: ( '<>' )
    // IQL.g:26:10: '<>'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleT__139Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__139Ex; /* Prevent compiler warnings */
    ruleT__139Ex: ;

}
// $ANTLR end T__139

//   Comes from: 27:8: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__140
 *
 * Looks to match the characters the constitute the token T__140
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__140(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__140;
       
    
    // IQL.g:27:8: ( '!=' )
    // IQL.g:27:10: '!='
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleT__140Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__140Ex; /* Prevent compiler warnings */
    ruleT__140Ex: ;

}
// $ANTLR end T__140

//   Comes from: 28:8: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__141
 *
 * Looks to match the characters the constitute the token T__141
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__141(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__141;
       
    
    // IQL.g:28:8: ( '+' )
    // IQL.g:28:10: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__141Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__141Ex; /* Prevent compiler warnings */
    ruleT__141Ex: ;

}
// $ANTLR end T__141

//   Comes from: 29:8: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__142
 *
 * Looks to match the characters the constitute the token T__142
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__142(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__142;
       
    
    // IQL.g:29:8: ( '-' )
    // IQL.g:29:10: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__142Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__142Ex; /* Prevent compiler warnings */
    ruleT__142Ex: ;

}
// $ANTLR end T__142

//   Comes from: 30:8: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__143
 *
 * Looks to match the characters the constitute the token T__143
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__143(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__143;
       
    
    // IQL.g:30:8: ( '||' )
    // IQL.g:30:10: '||'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleT__143Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__143Ex; /* Prevent compiler warnings */
    ruleT__143Ex: ;

}
// $ANTLR end T__143

//   Comes from: 31:8: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__144
 *
 * Looks to match the characters the constitute the token T__144
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__144(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__144;
       
    
    // IQL.g:31:8: ( '/' )
    // IQL.g:31:10: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__144Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__144Ex; /* Prevent compiler warnings */
    ruleT__144Ex: ;

}
// $ANTLR end T__144

//   Comes from: 32:8: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__145
 *
 * Looks to match the characters the constitute the token T__145
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__145(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__145;
       
    
    // IQL.g:32:8: ( '%' )
    // IQL.g:32:10: '%'
    {
        MATCHC('%'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__145Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__145Ex; /* Prevent compiler warnings */
    ruleT__145Ex: ;

}
// $ANTLR end T__145

//   Comes from: 33:8: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__146
 *
 * Looks to match the characters the constitute the token T__146
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__146(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__146;
       
    
    // IQL.g:33:8: ( '~' )
    // IQL.g:33:10: '~'
    {
        MATCHC('~'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__146Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__146Ex; /* Prevent compiler warnings */
    ruleT__146Ex: ;

}
// $ANTLR end T__146

//   Comes from: 34:8: ( '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__147
 *
 * Looks to match the characters the constitute the token T__147
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__147(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__147;
       
    
    // IQL.g:34:8: ( '#' )
    // IQL.g:34:10: '#'
    {
        MATCHC('#'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__147Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__147Ex; /* Prevent compiler warnings */
    ruleT__147Ex: ;

}
// $ANTLR end T__147

//   Comes from: 35:8: ( '$' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__148
 *
 * Looks to match the characters the constitute the token T__148
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__148(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__148;
       
    
    // IQL.g:35:8: ( '$' )
    // IQL.g:35:10: '$'
    {
        MATCHC('$'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__148Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__148Ex; /* Prevent compiler warnings */
    ruleT__148Ex: ;

}
// $ANTLR end T__148

//   Comes from: 530:8: ( 'ADD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ADD
 *
 * Looks to match the characters the constitute the token TK_ADD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ADD(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ADD;
       
    
    // IQL.g:530:8: ( 'ADD' )
    // IQL.g:530:10: 'ADD'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ADDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ADDEx; /* Prevent compiler warnings */
    ruleTK_ADDEx: ;

}
// $ANTLR end TK_ADD

//   Comes from: 531:8: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALL
 *
 * Looks to match the characters the constitute the token TK_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALL;
       
    
    // IQL.g:531:8: ( 'ALL' )
    // IQL.g:531:10: 'ALL'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALLEx; /* Prevent compiler warnings */
    ruleTK_ALLEx: ;

}
// $ANTLR end TK_ALL

//   Comes from: 532:10: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALTER
 *
 * Looks to match the characters the constitute the token TK_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALTER;
       
    
    // IQL.g:532:10: ( 'ALTER' )
    // IQL.g:532:12: 'ALTER'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALTEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALTEREx; /* Prevent compiler warnings */
    ruleTK_ALTEREx: ;

}
// $ANTLR end TK_ALTER

//   Comes from: 533:8: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AND
 *
 * Looks to match the characters the constitute the token TK_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AND(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AND;
       
    
    // IQL.g:533:8: ( 'AND' )
    // IQL.g:533:10: 'AND'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANDEx; /* Prevent compiler warnings */
    ruleTK_ANDEx: ;

}
// $ANTLR end TK_AND

//   Comes from: 534:8: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ANY
 *
 * Looks to match the characters the constitute the token TK_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ANY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ANY;
       
    
    // IQL.g:534:8: ( 'ANY' )
    // IQL.g:534:10: 'ANY'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANYEx; /* Prevent compiler warnings */
    ruleTK_ANYEx: ;

}
// $ANTLR end TK_ANY

//   Comes from: 535:10: ( 'ARRAY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ARRAY
 *
 * Looks to match the characters the constitute the token TK_ARRAY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ARRAY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ARRAY;
       
    
    // IQL.g:535:10: ( 'ARRAY' )
    // IQL.g:535:12: 'ARRAY'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ARRAYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ARRAYEx; /* Prevent compiler warnings */
    ruleTK_ARRAYEx: ;

}
// $ANTLR end TK_ARRAY

//   Comes from: 536:7: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AS
 *
 * Looks to match the characters the constitute the token TK_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AS;
       
    
    // IQL.g:536:7: ( 'AS' )
    // IQL.g:536:9: 'AS'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASEx; /* Prevent compiler warnings */
    ruleTK_ASEx: ;

}
// $ANTLR end TK_AS

//   Comes from: 537:8: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ASC
 *
 * Looks to match the characters the constitute the token TK_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ASC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ASC;
       
    
    // IQL.g:537:8: ( 'ASC' )
    // IQL.g:537:10: 'ASC'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASCEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASCEx; /* Prevent compiler warnings */
    ruleTK_ASCEx: ;

}
// $ANTLR end TK_ASC

//   Comes from: 538:8: ( 'AVG' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AVG
 *
 * Looks to match the characters the constitute the token TK_AVG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AVG(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AVG;
       
    
    // IQL.g:538:8: ( 'AVG' )
    // IQL.g:538:10: 'AVG'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_AVGEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_AVGEx; /* Prevent compiler warnings */
    ruleTK_AVGEx: ;

}
// $ANTLR end TK_AVG

//   Comes from: 539:10: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BEGIN
 *
 * Looks to match the characters the constitute the token TK_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BEGIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BEGIN;
       
    
    // IQL.g:539:10: ( 'BEGIN' )
    // IQL.g:539:12: 'BEGIN'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BEGINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BEGINEx; /* Prevent compiler warnings */
    ruleTK_BEGINEx: ;

}
// $ANTLR end TK_BEGIN

//   Comes from: 540:12: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BETWEEN
 *
 * Looks to match the characters the constitute the token TK_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BETWEEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BETWEEN;
       
    
    // IQL.g:540:12: ( 'BETWEEN' )
    // IQL.g:540:14: 'BETWEEN'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BETWEENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BETWEENEx; /* Prevent compiler warnings */
    ruleTK_BETWEENEx: ;

}
// $ANTLR end TK_BETWEEN

//   Comes from: 541:11: ( 'BIGINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BIGINT
 *
 * Looks to match the characters the constitute the token TK_BIGINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BIGINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BIGINT;
       
    
    // IQL.g:541:11: ( 'BIGINT' )
    // IQL.g:541:13: 'BIGINT'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BIGINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BIGINTEx; /* Prevent compiler warnings */
    ruleTK_BIGINTEx: ;

}
// $ANTLR end TK_BIGINT

//   Comes from: 542:12: ( 'BOOLEAN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BOOLEAN
 *
 * Looks to match the characters the constitute the token TK_BOOLEAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BOOLEAN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BOOLEAN;
       
    
    // IQL.g:542:12: ( 'BOOLEAN' )
    // IQL.g:542:14: 'BOOLEAN'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BOOLEANEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BOOLEANEx; /* Prevent compiler warnings */
    ruleTK_BOOLEANEx: ;

}
// $ANTLR end TK_BOOLEAN

//   Comes from: 543:10: ( 'BREAK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BREAK
 *
 * Looks to match the characters the constitute the token TK_BREAK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BREAK(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BREAK;
       
    
    // IQL.g:543:10: ( 'BREAK' )
    // IQL.g:543:12: 'BREAK'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BREAKEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BREAKEx; /* Prevent compiler warnings */
    ruleTK_BREAKEx: ;

}
// $ANTLR end TK_BREAK

//   Comes from: 544:7: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BY
 *
 * Looks to match the characters the constitute the token TK_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BY;
       
    
    // IQL.g:544:7: ( 'BY' )
    // IQL.g:544:9: 'BY'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BYEx; /* Prevent compiler warnings */
    ruleTK_BYEx: ;

}
// $ANTLR end TK_BY

//   Comes from: 545:9: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CASE
 *
 * Looks to match the characters the constitute the token TK_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CASE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CASE;
       
    
    // IQL.g:545:9: ( 'CASE' )
    // IQL.g:545:11: 'CASE'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASEEx; /* Prevent compiler warnings */
    ruleTK_CASEEx: ;

}
// $ANTLR end TK_CASE

//   Comes from: 546:9: ( 'CAST' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CAST
 *
 * Looks to match the characters the constitute the token TK_CAST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CAST(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CAST;
       
    
    // IQL.g:546:9: ( 'CAST' )
    // IQL.g:546:11: 'CAST'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASTEx; /* Prevent compiler warnings */
    ruleTK_CASTEx: ;

}
// $ANTLR end TK_CAST

//   Comes from: 547:9: ( 'CHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CHAR
 *
 * Looks to match the characters the constitute the token TK_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CHAR;
       
    
    // IQL.g:547:9: ( 'CHAR' )
    // IQL.g:547:11: 'CHAR'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CHAREx; /* Prevent compiler warnings */
    ruleTK_CHAREx: ;

}
// $ANTLR end TK_CHAR

//   Comes from: 548:11: ( 'CIDRV4' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CIDRV4
 *
 * Looks to match the characters the constitute the token TK_CIDRV4
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CIDRV4(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CIDRV4;
       
    
    // IQL.g:548:11: ( 'CIDRV4' )
    // IQL.g:548:13: 'CIDRV4'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CIDRV4Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CIDRV4Ex; /* Prevent compiler warnings */
    ruleTK_CIDRV4Ex: ;

}
// $ANTLR end TK_CIDRV4

//   Comes from: 549:11: ( 'CIDRV6' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CIDRV6
 *
 * Looks to match the characters the constitute the token TK_CIDRV6
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CIDRV6(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CIDRV6;
       
    
    // IQL.g:549:11: ( 'CIDRV6' )
    // IQL.g:549:13: 'CIDRV6'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CIDRV6Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CIDRV6Ex; /* Prevent compiler warnings */
    ruleTK_CIDRV6Ex: ;

}
// $ANTLR end TK_CIDRV6

//   Comes from: 550:13: ( 'COALESCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COALESCE
 *
 * Looks to match the characters the constitute the token TK_COALESCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COALESCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COALESCE;
       
    
    // IQL.g:550:13: ( 'COALESCE' )
    // IQL.g:550:15: 'COALESCE'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COALESCEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COALESCEEx; /* Prevent compiler warnings */
    ruleTK_COALESCEEx: ;

}
// $ANTLR end TK_COALESCE

//   Comes from: 551:13: ( 'CONTINUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CONTINUE
 *
 * Looks to match the characters the constitute the token TK_CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CONTINUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CONTINUE;
       
    
    // IQL.g:551:13: ( 'CONTINUE' )
    // IQL.g:551:15: 'CONTINUE'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CONTINUEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CONTINUEEx; /* Prevent compiler warnings */
    ruleTK_CONTINUEEx: ;

}
// $ANTLR end TK_CONTINUE

//   Comes from: 552:10: ( 'COUNT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COUNT
 *
 * Looks to match the characters the constitute the token TK_COUNT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COUNT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COUNT;
       
    
    // IQL.g:552:10: ( 'COUNT' )
    // IQL.g:552:12: 'COUNT'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COUNTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COUNTEx; /* Prevent compiler warnings */
    ruleTK_COUNTEx: ;

}
// $ANTLR end TK_COUNT

//   Comes from: 553:11: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CREATE
 *
 * Looks to match the characters the constitute the token TK_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CREATE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CREATE;
       
    
    // IQL.g:553:11: ( 'CREATE' )
    // IQL.g:553:13: 'CREATE'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CREATEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CREATEEx; /* Prevent compiler warnings */
    ruleTK_CREATEEx: ;

}
// $ANTLR end TK_CREATE

//   Comes from: 554:10: ( 'CROSS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CROSS
 *
 * Looks to match the characters the constitute the token TK_CROSS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CROSS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CROSS;
       
    
    // IQL.g:554:10: ( 'CROSS' )
    // IQL.g:554:12: 'CROSS'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CROSSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CROSSEx; /* Prevent compiler warnings */
    ruleTK_CROSSEx: ;

}
// $ANTLR end TK_CROSS

//   Comes from: 555:13: ( 'DATETIME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DATETIME
 *
 * Looks to match the characters the constitute the token TK_DATETIME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DATETIME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DATETIME;
       
    
    // IQL.g:555:13: ( 'DATETIME' )
    // IQL.g:555:15: 'DATETIME'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DATETIMEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DATETIMEEx; /* Prevent compiler warnings */
    ruleTK_DATETIMEEx: ;

}
// $ANTLR end TK_DATETIME

//   Comes from: 556:12: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECLARE
 *
 * Looks to match the characters the constitute the token TK_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECLARE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECLARE;
       
    
    // IQL.g:556:12: ( 'DECLARE' )
    // IQL.g:556:14: 'DECLARE'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECLAREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECLAREEx; /* Prevent compiler warnings */
    ruleTK_DECLAREEx: ;

}
// $ANTLR end TK_DECLARE

//   Comes from: 557:12: ( 'DECIMAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECIMAL
 *
 * Looks to match the characters the constitute the token TK_DECIMAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECIMAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECIMAL;
       
    
    // IQL.g:557:12: ( 'DECIMAL' )
    // IQL.g:557:14: 'DECIMAL'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECIMALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECIMALEx; /* Prevent compiler warnings */
    ruleTK_DECIMALEx: ;

}
// $ANTLR end TK_DECIMAL

//   Comes from: 558:9: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DESC
 *
 * Looks to match the characters the constitute the token TK_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DESC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DESC;
       
    
    // IQL.g:558:9: ( 'DESC' )
    // IQL.g:558:11: 'DESC'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DESCEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DESCEx; /* Prevent compiler warnings */
    ruleTK_DESCEx: ;

}
// $ANTLR end TK_DESC

//   Comes from: 559:13: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DISTINCT
 *
 * Looks to match the characters the constitute the token TK_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DISTINCT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DISTINCT;
       
    
    // IQL.g:559:13: ( 'DISTINCT' )
    // IQL.g:559:15: 'DISTINCT'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DISTINCTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DISTINCTEx; /* Prevent compiler warnings */
    ruleTK_DISTINCTEx: ;

}
// $ANTLR end TK_DISTINCT

//   Comes from: 560:11: ( 'DOUBLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DOUBLE
 *
 * Looks to match the characters the constitute the token TK_DOUBLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DOUBLE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DOUBLE;
       
    
    // IQL.g:560:11: ( 'DOUBLE' )
    // IQL.g:560:13: 'DOUBLE'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DOUBLEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DOUBLEEx; /* Prevent compiler warnings */
    ruleTK_DOUBLEEx: ;

}
// $ANTLR end TK_DOUBLE

//   Comes from: 561:9: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ELSE
 *
 * Looks to match the characters the constitute the token TK_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ELSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ELSE;
       
    
    // IQL.g:561:9: ( 'ELSE' )
    // IQL.g:561:11: 'ELSE'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ELSEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ELSEEx; /* Prevent compiler warnings */
    ruleTK_ELSEEx: ;

}
// $ANTLR end TK_ELSE

//   Comes from: 562:8: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_END
 *
 * Looks to match the characters the constitute the token TK_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_END(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_END;
       
    
    // IQL.g:562:8: ( 'END' )
    // IQL.g:562:10: 'END'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ENDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ENDEx; /* Prevent compiler warnings */
    ruleTK_ENDEx: ;

}
// $ANTLR end TK_END

//   Comes from: 563:11: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_EXISTS
 *
 * Looks to match the characters the constitute the token TK_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_EXISTS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_EXISTS;
       
    
    // IQL.g:563:11: ( 'EXISTS' )
    // IQL.g:563:13: 'EXISTS'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_EXISTSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_EXISTSEx; /* Prevent compiler warnings */
    ruleTK_EXISTSEx: ;

}
// $ANTLR end TK_EXISTS

//   Comes from: 564:10: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FALSE
 *
 * Looks to match the characters the constitute the token TK_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FALSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FALSE;
       
    
    // IQL.g:564:10: ( 'FALSE' )
    // IQL.g:564:12: 'FALSE'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FALSEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FALSEEx; /* Prevent compiler warnings */
    ruleTK_FALSEEx: ;

}
// $ANTLR end TK_FALSE

//   Comes from: 565:9: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FROM
 *
 * Looks to match the characters the constitute the token TK_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FROM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FROM;
       
    
    // IQL.g:565:9: ( 'FROM' )
    // IQL.g:565:11: 'FROM'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FROMEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FROMEx; /* Prevent compiler warnings */
    ruleTK_FROMEx: ;

}
// $ANTLR end TK_FROM

//   Comes from: 566:9: ( 'FULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FULL
 *
 * Looks to match the characters the constitute the token TK_FULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FULL;
       
    
    // IQL.g:566:9: ( 'FULL' )
    // IQL.g:566:11: 'FULL'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FULLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FULLEx; /* Prevent compiler warnings */
    ruleTK_FULLEx: ;

}
// $ANTLR end TK_FULL

//   Comes from: 567:13: ( 'FUNCTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FUNCTION
 *
 * Looks to match the characters the constitute the token TK_FUNCTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FUNCTION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FUNCTION;
       
    
    // IQL.g:567:13: ( 'FUNCTION' )
    // IQL.g:567:15: 'FUNCTION'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FUNCTIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FUNCTIONEx; /* Prevent compiler warnings */
    ruleTK_FUNCTIONEx: ;

}
// $ANTLR end TK_FUNCTION

//   Comes from: 568:10: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_GROUP
 *
 * Looks to match the characters the constitute the token TK_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_GROUP(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_GROUP;
       
    
    // IQL.g:568:10: ( 'GROUP' )
    // IQL.g:568:12: 'GROUP'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_GROUPEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_GROUPEx; /* Prevent compiler warnings */
    ruleTK_GROUPEx: ;

}
// $ANTLR end TK_GROUP

//   Comes from: 569:11: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_HAVING
 *
 * Looks to match the characters the constitute the token TK_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_HAVING(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_HAVING;
       
    
    // IQL.g:569:11: ( 'HAVING' )
    // IQL.g:569:13: 'HAVING'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_HAVINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_HAVINGEx; /* Prevent compiler warnings */
    ruleTK_HAVINGEx: ;

}
// $ANTLR end TK_HAVING

//   Comes from: 570:7: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IF
 *
 * Looks to match the characters the constitute the token TK_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IF(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IF;
       
    
    // IQL.g:570:7: ( 'IF' )
    // IQL.g:570:9: 'IF'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IFEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IFEx; /* Prevent compiler warnings */
    ruleTK_IFEx: ;

}
// $ANTLR end TK_IF

//   Comes from: 571:7: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IN
 *
 * Looks to match the characters the constitute the token TK_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IN;
       
    
    // IQL.g:571:7: ( 'IN' )
    // IQL.g:571:9: 'IN'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INEx; /* Prevent compiler warnings */
    ruleTK_INEx: ;

}
// $ANTLR end TK_IN

//   Comes from: 572:10: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INDEX
 *
 * Looks to match the characters the constitute the token TK_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INDEX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INDEX;
       
    
    // IQL.g:572:10: ( 'INDEX' )
    // IQL.g:572:12: 'INDEX'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INDEXEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INDEXEx; /* Prevent compiler warnings */
    ruleTK_INDEXEx: ;

}
// $ANTLR end TK_INDEX

//   Comes from: 573:10: ( 'INNER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INNER
 *
 * Looks to match the characters the constitute the token TK_INNER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INNER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INNER;
       
    
    // IQL.g:573:10: ( 'INNER' )
    // IQL.g:573:12: 'INNER'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INNEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INNEREx; /* Prevent compiler warnings */
    ruleTK_INNEREx: ;

}
// $ANTLR end TK_INNER

//   Comes from: 574:9: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTO
 *
 * Looks to match the characters the constitute the token TK_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTO(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTO;
       
    
    // IQL.g:574:9: ( 'INTO' )
    // IQL.g:574:11: 'INTO'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTOEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTOEx; /* Prevent compiler warnings */
    ruleTK_INTOEx: ;

}
// $ANTLR end TK_INTO

//   Comes from: 575:12: ( 'INTEGER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTEGER
 *
 * Looks to match the characters the constitute the token TK_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTEGER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTEGER;
       
    
    // IQL.g:575:12: ( 'INTEGER' )
    // IQL.g:575:14: 'INTEGER'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTEGEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTEGEREx; /* Prevent compiler warnings */
    ruleTK_INTEGEREx: ;

}
// $ANTLR end TK_INTEGER

//   Comes from: 576:13: ( 'INTERVAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTERVAL
 *
 * Looks to match the characters the constitute the token TK_INTERVAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTERVAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTERVAL;
       
    
    // IQL.g:576:13: ( 'INTERVAL' )
    // IQL.g:576:15: 'INTERVAL'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTERVALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTERVALEx; /* Prevent compiler warnings */
    ruleTK_INTERVALEx: ;

}
// $ANTLR end TK_INTERVAL

//   Comes from: 577:9: ( 'IPV4' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IPV4
 *
 * Looks to match the characters the constitute the token TK_IPV4
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IPV4(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IPV4;
       
    
    // IQL.g:577:9: ( 'IPV4' )
    // IQL.g:577:11: 'IPV4'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IPV4Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IPV4Ex; /* Prevent compiler warnings */
    ruleTK_IPV4Ex: ;

}
// $ANTLR end TK_IPV4

//   Comes from: 578:9: ( 'IPV6' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IPV6
 *
 * Looks to match the characters the constitute the token TK_IPV6
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IPV6(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IPV6;
       
    
    // IQL.g:578:9: ( 'IPV6' )
    // IQL.g:578:11: 'IPV6'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IPV6Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IPV6Ex; /* Prevent compiler warnings */
    ruleTK_IPV6Ex: ;

}
// $ANTLR end TK_IPV6

//   Comes from: 579:7: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IS
 *
 * Looks to match the characters the constitute the token TK_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IS;
       
    
    // IQL.g:579:7: ( 'IS' )
    // IQL.g:579:9: 'IS'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ISEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ISEx; /* Prevent compiler warnings */
    ruleTK_ISEx: ;

}
// $ANTLR end TK_IS

//   Comes from: 580:9: ( 'JOIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_JOIN
 *
 * Looks to match the characters the constitute the token TK_JOIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_JOIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_JOIN;
       
    
    // IQL.g:580:9: ( 'JOIN' )
    // IQL.g:580:11: 'JOIN'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_JOINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_JOINEx; /* Prevent compiler warnings */
    ruleTK_JOINEx: ;

}
// $ANTLR end TK_JOIN

//   Comes from: 581:8: ( 'KEY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_KEY
 *
 * Looks to match the characters the constitute the token TK_KEY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_KEY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_KEY;
       
    
    // IQL.g:581:8: ( 'KEY' )
    // IQL.g:581:10: 'KEY'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_KEYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_KEYEx; /* Prevent compiler warnings */
    ruleTK_KEYEx: ;

}
// $ANTLR end TK_KEY

//   Comes from: 582:9: ( 'LEFT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LEFT
 *
 * Looks to match the characters the constitute the token TK_LEFT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LEFT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LEFT;
       
    
    // IQL.g:582:9: ( 'LEFT' )
    // IQL.g:582:11: 'LEFT'
    {
        MATCHS(lit_59); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LEFTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LEFTEx; /* Prevent compiler warnings */
    ruleTK_LEFTEx: ;

}
// $ANTLR end TK_LEFT

//   Comes from: 583:9: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LIKE
 *
 * Looks to match the characters the constitute the token TK_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LIKE;
       
    
    // IQL.g:583:9: ( 'LIKE' )
    // IQL.g:583:11: 'LIKE'
    {
        MATCHS(lit_60); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LIKEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LIKEEx; /* Prevent compiler warnings */
    ruleTK_LIKEEx: ;

}
// $ANTLR end TK_LIKE

//   Comes from: 584:8: ( 'MAX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MAX
 *
 * Looks to match the characters the constitute the token TK_MAX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MAX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MAX;
       
    
    // IQL.g:584:8: ( 'MAX' )
    // IQL.g:584:10: 'MAX'
    {
        MATCHS(lit_61); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MAXEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MAXEx; /* Prevent compiler warnings */
    ruleTK_MAXEx: ;

}
// $ANTLR end TK_MAX

//   Comes from: 585:8: ( 'MIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MIN
 *
 * Looks to match the characters the constitute the token TK_MIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MIN;
       
    
    // IQL.g:585:8: ( 'MIN' )
    // IQL.g:585:10: 'MIN'
    {
        MATCHS(lit_62); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MINEx; /* Prevent compiler warnings */
    ruleTK_MINEx: ;

}
// $ANTLR end TK_MIN

//   Comes from: 586:8: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NOT
 *
 * Looks to match the characters the constitute the token TK_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NOT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NOT;
       
    
    // IQL.g:586:8: ( 'NOT' )
    // IQL.g:586:10: 'NOT'
    {
        MATCHS(lit_63); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NOTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NOTEx; /* Prevent compiler warnings */
    ruleTK_NOTEx: ;

}
// $ANTLR end TK_NOT

//   Comes from: 587:9: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NULL
 *
 * Looks to match the characters the constitute the token TK_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NULL;
       
    
    // IQL.g:587:9: ( 'NULL' )
    // IQL.g:587:11: 'NULL'
    {
        MATCHS(lit_64); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NULLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NULLEx; /* Prevent compiler warnings */
    ruleTK_NULLEx: ;

}
// $ANTLR end TK_NULL

//   Comes from: 588:13: ( 'NVARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NVARCHAR
 *
 * Looks to match the characters the constitute the token TK_NVARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NVARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NVARCHAR;
       
    
    // IQL.g:588:13: ( 'NVARCHAR' )
    // IQL.g:588:15: 'NVARCHAR'
    {
        MATCHS(lit_65); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NVARCHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NVARCHAREx; /* Prevent compiler warnings */
    ruleTK_NVARCHAREx: ;

}
// $ANTLR end TK_NVARCHAR

//   Comes from: 589:7: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ON
 *
 * Looks to match the characters the constitute the token TK_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ON(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ON;
       
    
    // IQL.g:589:7: ( 'ON' )
    // IQL.g:589:9: 'ON'
    {
        MATCHS(lit_66); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ONEx; /* Prevent compiler warnings */
    ruleTK_ONEx: ;

}
// $ANTLR end TK_ON

//   Comes from: 590:7: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OR
 *
 * Looks to match the characters the constitute the token TK_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OR;
       
    
    // IQL.g:590:7: ( 'OR' )
    // IQL.g:590:9: 'OR'
    {
        MATCHS(lit_67); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OREx; /* Prevent compiler warnings */
    ruleTK_OREx: ;

}
// $ANTLR end TK_OR

//   Comes from: 591:10: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ORDER
 *
 * Looks to match the characters the constitute the token TK_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ORDER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ORDER;
       
    
    // IQL.g:591:10: ( 'ORDER' )
    // IQL.g:591:12: 'ORDER'
    {
        MATCHS(lit_68); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ORDEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ORDEREx; /* Prevent compiler warnings */
    ruleTK_ORDEREx: ;

}
// $ANTLR end TK_ORDER

//   Comes from: 592:10: ( 'OUTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTER
 *
 * Looks to match the characters the constitute the token TK_OUTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTER;
       
    
    // IQL.g:592:10: ( 'OUTER' )
    // IQL.g:592:12: 'OUTER'
    {
        MATCHS(lit_69); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTEREx; /* Prevent compiler warnings */
    ruleTK_OUTEREx: ;

}
// $ANTLR end TK_OUTER

//   Comes from: 593:11: ( 'OUTPUT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTPUT
 *
 * Looks to match the characters the constitute the token TK_OUTPUT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTPUT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTPUT;
       
    
    // IQL.g:593:11: ( 'OUTPUT' )
    // IQL.g:593:13: 'OUTPUT'
    {
        MATCHS(lit_70); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTPUTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTPUTEx; /* Prevent compiler warnings */
    ruleTK_OUTPUTEx: ;

}
// $ANTLR end TK_OUTPUT

//   Comes from: 594:14: ( 'PRECISION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRECISION
 *
 * Looks to match the characters the constitute the token TK_PRECISION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRECISION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRECISION;
       
    
    // IQL.g:594:14: ( 'PRECISION' )
    // IQL.g:594:16: 'PRECISION'
    {
        MATCHS(lit_71); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRECISIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRECISIONEx; /* Prevent compiler warnings */
    ruleTK_PRECISIONEx: ;

}
// $ANTLR end TK_PRECISION

//   Comes from: 595:10: ( 'PRINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRINT
 *
 * Looks to match the characters the constitute the token TK_PRINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRINT;
       
    
    // IQL.g:595:10: ( 'PRINT' )
    // IQL.g:595:12: 'PRINT'
    {
        MATCHS(lit_72); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRINTEx; /* Prevent compiler warnings */
    ruleTK_PRINTEx: ;

}
// $ANTLR end TK_PRINT

//   Comes from: 596:14: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PROCEDURE
 *
 * Looks to match the characters the constitute the token TK_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PROCEDURE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PROCEDURE;
       
    
    // IQL.g:596:14: ( 'PROCEDURE' )
    // IQL.g:596:16: 'PROCEDURE'
    {
        MATCHS(lit_73); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PROCEDUREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PROCEDUREEx; /* Prevent compiler warnings */
    ruleTK_PROCEDUREEx: ;

}
// $ANTLR end TK_PROCEDURE

//   Comes from: 597:14: ( 'RAISERROR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RAISERROR
 *
 * Looks to match the characters the constitute the token TK_RAISERROR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RAISERROR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RAISERROR;
       
    
    // IQL.g:597:14: ( 'RAISERROR' )
    // IQL.g:597:16: 'RAISERROR'
    {
        MATCHS(lit_74); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RAISERROREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RAISERROREx; /* Prevent compiler warnings */
    ruleTK_RAISERROREx: ;

}
// $ANTLR end TK_RAISERROR

//   Comes from: 598:9: ( 'REAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_REAL
 *
 * Looks to match the characters the constitute the token TK_REAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_REAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_REAL;
       
    
    // IQL.g:598:9: ( 'REAL' )
    // IQL.g:598:11: 'REAL'
    {
        MATCHS(lit_75); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_REALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_REALEx; /* Prevent compiler warnings */
    ruleTK_REALEx: ;

}
// $ANTLR end TK_REAL

//   Comes from: 599:11: ( 'RETURN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURN
 *
 * Looks to match the characters the constitute the token TK_RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURN;
       
    
    // IQL.g:599:11: ( 'RETURN' )
    // IQL.g:599:13: 'RETURN'
    {
        MATCHS(lit_76); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNEx; /* Prevent compiler warnings */
    ruleTK_RETURNEx: ;

}
// $ANTLR end TK_RETURN

//   Comes from: 600:12: ( 'RETURNS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURNS
 *
 * Looks to match the characters the constitute the token TK_RETURNS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURNS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURNS;
       
    
    // IQL.g:600:12: ( 'RETURNS' )
    // IQL.g:600:14: 'RETURNS'
    {
        MATCHS(lit_77); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNSEx; /* Prevent compiler warnings */
    ruleTK_RETURNSEx: ;

}
// $ANTLR end TK_RETURNS

//   Comes from: 601:10: ( 'RIGHT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RIGHT
 *
 * Looks to match the characters the constitute the token TK_RIGHT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RIGHT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RIGHT;
       
    
    // IQL.g:601:10: ( 'RIGHT' )
    // IQL.g:601:12: 'RIGHT'
    {
        MATCHS(lit_78); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RIGHTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RIGHTEx; /* Prevent compiler warnings */
    ruleTK_RIGHTEx: ;

}
// $ANTLR end TK_RIGHT

//   Comes from: 602:10: ( 'RLIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RLIKE
 *
 * Looks to match the characters the constitute the token TK_RLIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RLIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RLIKE;
       
    
    // IQL.g:602:10: ( 'RLIKE' )
    // IQL.g:602:12: 'RLIKE'
    {
        MATCHS(lit_79); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RLIKEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RLIKEEx; /* Prevent compiler warnings */
    ruleTK_RLIKEEx: ;

}
// $ANTLR end TK_RLIKE

//   Comes from: 603:8: ( 'ROW' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ROW
 *
 * Looks to match the characters the constitute the token TK_ROW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ROW(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ROW;
       
    
    // IQL.g:603:8: ( 'ROW' )
    // IQL.g:603:10: 'ROW'
    {
        MATCHS(lit_80); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ROWEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ROWEx; /* Prevent compiler warnings */
    ruleTK_ROWEx: ;

}
// $ANTLR end TK_ROW

//   Comes from: 604:11: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SELECT
 *
 * Looks to match the characters the constitute the token TK_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SELECT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SELECT;
       
    
    // IQL.g:604:11: ( 'SELECT' )
    // IQL.g:604:13: 'SELECT'
    {
        MATCHS(lit_81); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SELECTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SELECTEx; /* Prevent compiler warnings */
    ruleTK_SELECTEx: ;

}
// $ANTLR end TK_SELECT

//   Comes from: 605:8: ( 'SET' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SET
 *
 * Looks to match the characters the constitute the token TK_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SET(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SET;
       
    
    // IQL.g:605:8: ( 'SET' )
    // IQL.g:605:10: 'SET'
    {
        MATCHS(lit_82); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SETEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SETEx; /* Prevent compiler warnings */
    ruleTK_SETEx: ;

}
// $ANTLR end TK_SET

//   Comes from: 606:13: ( 'SMALLINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SMALLINT
 *
 * Looks to match the characters the constitute the token TK_SMALLINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SMALLINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SMALLINT;
       
    
    // IQL.g:606:13: ( 'SMALLINT' )
    // IQL.g:606:15: 'SMALLINT'
    {
        MATCHS(lit_83); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SMALLINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SMALLINTEx; /* Prevent compiler warnings */
    ruleTK_SMALLINTEx: ;

}
// $ANTLR end TK_SMALLINT

//   Comes from: 607:9: ( 'SOME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SOME
 *
 * Looks to match the characters the constitute the token TK_SOME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SOME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SOME;
       
    
    // IQL.g:607:9: ( 'SOME' )
    // IQL.g:607:11: 'SOME'
    {
        MATCHS(lit_84); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SOMEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SOMEEx; /* Prevent compiler warnings */
    ruleTK_SOMEEx: ;

}
// $ANTLR end TK_SOME

//   Comes from: 608:8: ( 'SUM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SUM
 *
 * Looks to match the characters the constitute the token TK_SUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SUM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SUM;
       
    
    // IQL.g:608:8: ( 'SUM' )
    // IQL.g:608:10: 'SUM'
    {
        MATCHS(lit_85); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SUMEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SUMEx; /* Prevent compiler warnings */
    ruleTK_SUMEx: ;

}
// $ANTLR end TK_SUM

//   Comes from: 609:11: ( 'SWITCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SWITCH
 *
 * Looks to match the characters the constitute the token TK_SWITCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SWITCH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SWITCH;
       
    
    // IQL.g:609:11: ( 'SWITCH' )
    // IQL.g:609:13: 'SWITCH'
    {
        MATCHS(lit_86); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SWITCHEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SWITCHEx; /* Prevent compiler warnings */
    ruleTK_SWITCHEx: ;

}
// $ANTLR end TK_SWITCH

//   Comes from: 610:9: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_THEN
 *
 * Looks to match the characters the constitute the token TK_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_THEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_THEN;
       
    
    // IQL.g:610:9: ( 'THEN' )
    // IQL.g:610:11: 'THEN'
    {
        MATCHS(lit_87); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_THENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_THENEx; /* Prevent compiler warnings */
    ruleTK_THENEx: ;

}
// $ANTLR end TK_THEN

//   Comes from: 611:12: ( 'TINYINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_TINYINT
 *
 * Looks to match the characters the constitute the token TK_TINYINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_TINYINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_TINYINT;
       
    
    // IQL.g:611:12: ( 'TINYINT' )
    // IQL.g:611:14: 'TINYINT'
    {
        MATCHS(lit_88); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_TINYINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_TINYINTEx; /* Prevent compiler warnings */
    ruleTK_TINYINTEx: ;

}
// $ANTLR end TK_TINYINT

//   Comes from: 612:9: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_TRUE
 *
 * Looks to match the characters the constitute the token TK_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_TRUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_TRUE;
       
    
    // IQL.g:612:9: ( 'TRUE' )
    // IQL.g:612:11: 'TRUE'
    {
        MATCHS(lit_89); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_TRUEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_TRUEEx; /* Prevent compiler warnings */
    ruleTK_TRUEEx: ;

}
// $ANTLR end TK_TRUE

//   Comes from: 613:10: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_UNION
 *
 * Looks to match the characters the constitute the token TK_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_UNION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_UNION;
       
    
    // IQL.g:613:10: ( 'UNION' )
    // IQL.g:613:12: 'UNION'
    {
        MATCHS(lit_90); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_UNIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_UNIONEx; /* Prevent compiler warnings */
    ruleTK_UNIONEx: ;

}
// $ANTLR end TK_UNION

//   Comes from: 614:12: ( 'VARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_VARCHAR
 *
 * Looks to match the characters the constitute the token TK_VARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_VARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_VARCHAR;
       
    
    // IQL.g:614:12: ( 'VARCHAR' )
    // IQL.g:614:14: 'VARCHAR'
    {
        MATCHS(lit_91); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_VARCHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_VARCHAREx; /* Prevent compiler warnings */
    ruleTK_VARCHAREx: ;

}
// $ANTLR end TK_VARCHAR

//   Comes from: 615:9: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHEN
 *
 * Looks to match the characters the constitute the token TK_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHEN;
       
    
    // IQL.g:615:9: ( 'WHEN' )
    // IQL.g:615:11: 'WHEN'
    {
        MATCHS(lit_92); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHENEx; /* Prevent compiler warnings */
    ruleTK_WHENEx: ;

}
// $ANTLR end TK_WHEN

//   Comes from: 616:10: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHERE
 *
 * Looks to match the characters the constitute the token TK_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHERE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHERE;
       
    
    // IQL.g:616:10: ( 'WHERE' )
    // IQL.g:616:12: 'WHERE'
    {
        MATCHS(lit_93); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHEREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHEREEx; /* Prevent compiler warnings */
    ruleTK_WHEREEx: ;

}
// $ANTLR end TK_WHERE

//   Comes from: 617:10: ( 'WHILE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHILE
 *
 * Looks to match the characters the constitute the token TK_WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHILE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHILE;
       
    
    // IQL.g:617:10: ( 'WHILE' )
    // IQL.g:617:12: 'WHILE'
    {
        MATCHS(lit_94); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHILEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHILEEx; /* Prevent compiler warnings */
    ruleTK_WHILEEx: ;

}
// $ANTLR end TK_WHILE

//   Comes from: 618:9: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WITH
 *
 * Looks to match the characters the constitute the token TK_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WITH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WITH;
       
    
    // IQL.g:618:9: ( 'WITH' )
    // IQL.g:618:11: 'WITH'
    {
        MATCHS(lit_95); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WITHEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WITHEx; /* Prevent compiler warnings */
    ruleTK_WITHEx: ;

}
// $ANTLR end TK_WITH

//   Comes from: 621:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL;
       
    
    // IQL.g:621:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:621:8: '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:621:13: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt1=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (LA1_0 == '\\') ) 
                {
                    alt1=1;
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= '[')) || ((LA1_0 >= ']') && (LA1_0 <= 0xFFFF))) ) 
                {
                    alt1=2;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // IQL.g:621:15: ESCAPE_SEQUENCE
        	    {
        	        /* 621:15: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:621:33: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 625:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WSTRING_LITERAL
 *
 * Looks to match the characters the constitute the token WSTRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WSTRING_LITERAL;
       
    
    // IQL.g:625:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:625:8: 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHS(lit_96); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:625:14: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt2=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                if ( (LA2_0 == '\\') ) 
                {
                    alt2=1;
                }
                else if ( (((LA2_0 >= 0x0000) && (LA2_0 <= '&')) || ((LA2_0 >= '(') && (LA2_0 <= '[')) || ((LA2_0 >= ']') && (LA2_0 <= 0xFFFF))) ) 
                {
                    alt2=2;
                }

            }
            switch (alt2) 
            {
        	case 1:
        	    // IQL.g:625:16: ESCAPE_SEQUENCE
        	    {
        	        /* 625:16: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleWSTRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:625:34: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleWSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleWSTRING_LITERALEx: ;

}
// $ANTLR end WSTRING_LITERAL

//   Comes from: 629:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTED_STRING_LITERAL
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTED_STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTED_STRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_QUOTED_STRING_LITERAL;
       
    
    // IQL.g:629:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
    // IQL.g:629:8: '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:629:12: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt3=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (LA3_0 == '\\') ) 
                {
                    alt3=1;
                }
                else if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= '[')) || ((LA3_0 >= ']') && (LA3_0 <= 0xFFFF))) ) 
                {
                    alt3=2;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // IQL.g:629:14: ESCAPE_SEQUENCE
        	    {
        	        /* 629:14: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:629:32: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTED_STRING_LITERALEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTED_STRING_LITERALEx: ;

}
// $ANTLR end DOUBLE_QUOTED_STRING_LITERAL

//   Comes from: 634:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESCAPE_SEQUENCE
 *
 * Looks to match the characters the constitute the token ESCAPE_SEQUENCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESCAPE_SEQUENCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:634:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
        
        ANTLR3_UINT32 alt4;

        alt4=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '"':
        		case '\'':
        		case 'B':
        		case 'F':
        		case 'N':
        		case 'R':
        		case 'T':
        		case '\\':
        		case 'b':
        		case 'f':
        		case 'n':
        		case 'r':
        		case 't':
        			{
        				alt4=1;
        			}
        		    break;
        		case 'u':
        			{
        				alt4=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				alt4=3;
        			}
        		    break;

        		default:
        		    if (BACKTRACKING>0)
        		    {
        		        FAILEDFLAG = ANTLR3_TRUE;
        		        return ;
        		    }
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 4;
        		    EXCEPTION->state        = 1;


        		    goto ruleESCAPE_SEQUENCEEx;
        		}

        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleESCAPE_SEQUENCEEx;
        }

        switch (alt4) 
        {
    	case 1:
    	    // IQL.g:634:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == 'B' || LA(1) == 'F' || LA(1) == 'N' || LA(1) == 'R' || LA(1) == 'T' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();
    	        FAILEDFLAG=ANTLR3_FALSE;

    	        }
    	        else 
    	        {
    	            if (BACKTRACKING>0)
    	            {
    	                FAILEDFLAG = ANTLR3_TRUE;
    	                return ;
    	            }
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleESCAPE_SEQUENCEEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:635:9: UNICODE_ESCAPE
    	    {
    	        /* 635:9: UNICODE_ESCAPE */
    	        mUNICODE_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:636:9: OCTAL_ESCAPE
    	    {
    	        /* 636:9: OCTAL_ESCAPE */
    	        mOCTAL_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESCAPE_SEQUENCEEx; /* Prevent compiler warnings */
    ruleESCAPE_SEQUENCEEx: ;

}
// $ANTLR end ESCAPE_SEQUENCE

//   Comes from: 641:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESCAPE
 *
 * Looks to match the characters the constitute the token OCTAL_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:641:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt5;

        alt5=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						switch ( LA(4) ) 
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        							{
        								alt5=1;
        							}
        						    break;

        						default:
        						    alt5=2;}

        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						alt5=2;
        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;

        		default:
        		    if (BACKTRACKING>0)
        		    {
        		        FAILEDFLAG = ANTLR3_TRUE;
        		        return ;
        		    }
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 1;


        		    goto ruleOCTAL_ESCAPEEx;
        		}

        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCAPEEx;
        }

        switch (alt5) 
        {
    	case 1:
    	    // IQL.g:641:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:641:14: ( '0' .. '3' )
    	        // IQL.g:641:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:641:25: ( '0' .. '7' )
    	        // IQL.g:641:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:641:36: ( '0' .. '7' )
    	        // IQL.g:641:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:642:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:642:14: ( '0' .. '7' )
    	        // IQL.g:642:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:642:25: ( '0' .. '7' )
    	        // IQL.g:642:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;
    	case 3:
    	    // IQL.g:643:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:643:14: ( '0' .. '7' )
    	        // IQL.g:643:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCAPEEx; /* Prevent compiler warnings */
    ruleOCTAL_ESCAPEEx: ;

}
// $ANTLR end OCTAL_ESCAPE

//   Comes from: 648:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:648:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
    // IQL.g:648:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
    ruleHEX_DIGITEx: ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 652:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESCAPE
 *
 * Looks to match the characters the constitute the token UNICODE_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:652:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // IQL.g:652:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('u'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 652:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 652:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 652:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 652:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCAPEEx; /* Prevent compiler warnings */
    ruleUNICODE_ESCAPEEx: ;

}
// $ANTLR end UNICODE_ESCAPE

//   Comes from: 655:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;
       
    
    // IQL.g:655:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
    // IQL.g:655:8: ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSEx;
        }

        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 659:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ML_COMMENT
 *
 * Looks to match the characters the constitute the token ML_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mML_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ML_COMMENT;
       
    
    // IQL.g:659:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // IQL.g:659:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_97); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:659:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt6=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA6_0 = LA(1);
                if ( (LA6_0 == '*') ) 
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == '/') ) 
                        {
                            alt6=2;
                        }
                        else if ( (((LA6_1 >= 0x0000) && (LA6_1 <= '.')) || ((LA6_1 >= '0') && (LA6_1 <= 0xFFFF))) ) 
                        {
                            alt6=1;
                        }

                    }
                }
                else if ( (((LA6_0 >= 0x0000) && (LA6_0 <= ')')) || ((LA6_0 >= '+') && (LA6_0 <= 0xFFFF))) ) 
                {
                    alt6=1;
                }

            }
            switch (alt6) 
            {
        	case 1:
        	    // IQL.g:659:42: .
        	    {
        	        MATCHANY(); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleML_COMMENTEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop6;	/* break out of the loop */
        	    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */

        MATCHS(lit_98); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleML_COMMENTEx; /* Prevent compiler warnings */
    ruleML_COMMENTEx: ;

}
// $ANTLR end ML_COMMENT

//   Comes from: 663:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SL_COMMENT
 *
 * Looks to match the characters the constitute the token SL_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSL_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SL_COMMENT;
       
    
    // IQL.g:663:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // IQL.g:663:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_99); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:663:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt7=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA7_0 = LA(1);
                if ( (((LA7_0 >= 0x0000) && (LA7_0 <= '\t')) || ((LA7_0 >= 0x000B) && (LA7_0 <= '\f')) || ((LA7_0 >= 0x000E) && (LA7_0 <= 0xFFFF))) ) 
                {
                    alt7=1;
                }

            }
            switch (alt7) 
            {
        	case 1:
        	    // IQL.g:663:12: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSL_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop7;	/* break out of the loop */
        	    break;
            }
        }
        loop7: ; /* Jump out to here if this rule does not match */


        // IQL.g:663:26: ( '\\r' )?
        {
            int alt8=2;
            switch ( LA(1) ) 
            {
                case '\r':
                	{
                		alt8=1;
                	}
                    break;
            }

            switch (alt8) 
            {
        	case 1:
        	    // IQL.g:663:26: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSL_COMMENTEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSL_COMMENTEx; /* Prevent compiler warnings */
    ruleSL_COMMENTEx: ;

}
// $ANTLR end SL_COMMENT

//   Comes from: 667:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ID;
       
    
    // IQL.g:667:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
    // IQL.g:667:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDEx;
        }


        // IQL.g:667:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*

        for (;;)
        {
            int alt9=2;
            switch ( LA(1) ) 
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt9=1;
            	}
                break;

            }

            switch (alt9) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop9;	/* break out of the loop */
        	    break;
            }
        }
        loop9: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 671:2: ( '`' (~ ( '`' ) )* '`' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTED_ID
 *
 * Looks to match the characters the constitute the token QUOTED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUOTED_ID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUOTED_ID;
       
    
    // IQL.g:671:2: ( '`' (~ ( '`' ) )* '`' )
    // IQL.g:671:4: '`' (~ ( '`' ) )* '`'
    {
        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:671:8: (~ ( '`' ) )*

        for (;;)
        {
            int alt10=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA10_0 = LA(1);
                if ( (((LA10_0 >= 0x0000) && (LA10_0 <= '_')) || ((LA10_0 >= 'a') && (LA10_0 <= 0xFFFF))) ) 
                {
                    alt10=1;
                }

            }
            switch (alt10) 
            {
        	case 1:
        	    // IQL.g:671:8: ~ ( '`' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '_')) || ((LA(1) >= 'a') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleQUOTED_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop10;	/* break out of the loop */
        	    break;
            }
        }
        loop10: ; /* Jump out to here if this rule does not match */

        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUOTED_IDEx; /* Prevent compiler warnings */
    ruleQUOTED_IDEx: ;

}
// $ANTLR end QUOTED_ID

//   Comes from: 677:2: ( 'L' 'L' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIGINT_SUFFIX
 *
 * Looks to match the characters the constitute the token BIGINT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIGINT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:677:2: ( 'L' 'L' )
    // IQL.g:677:4: 'L' 'L'
    {
        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleBIGINT_SUFFIXEx; /* Prevent compiler warnings */
    ruleBIGINT_SUFFIXEx: ;

}
// $ANTLR end BIGINT_SUFFIX

//   Comes from: 682:5: ( '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THREE_DIGIT_NUMBER
 *
 * Looks to match the characters the constitute the token THREE_DIGIT_NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHREE_DIGIT_NUMBER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:682:5: ( '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )? )
    // IQL.g:683:5: '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )?
    {
        MATCHRANGE('0', '9'); 
        if  (HASEXCEPTION())
        {
            goto ruleTHREE_DIGIT_NUMBEREx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:683:14: ( '0' .. '9' ( '0' .. '9' )? )?
        {
            int alt12=2;
            switch ( LA(1) ) 
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                	{
                		alt12=1;
                	}
                    break;
            }

            switch (alt12) 
            {
        	case 1:
        	    // IQL.g:683:15: '0' .. '9' ( '0' .. '9' )?
        	    {
        	        MATCHRANGE('0', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleTHREE_DIGIT_NUMBEREx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:683:24: ( '0' .. '9' )?
        	        {
        	            int alt11=2;
        	            switch ( LA(1) ) 
        	            {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11) 
        	            {
        	        	case 1:
        	        	    // IQL.g:683:25: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleTHREE_DIGIT_NUMBEREx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleTHREE_DIGIT_NUMBEREx; /* Prevent compiler warnings */
    ruleTHREE_DIGIT_NUMBEREx: ;

}
// $ANTLR end THREE_DIGIT_NUMBER

//   Comes from: 688:5: ( HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOUR_DIGIT_HEX
 *
 * Looks to match the characters the constitute the token FOUR_DIGIT_HEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOUR_DIGIT_HEX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:688:5: ( HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? )
    // IQL.g:688:7: HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )?
    {
        /* 688:7: HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleFOUR_DIGIT_HEXEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:688:17: ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )?
        {
            int alt15=2;
            switch ( LA(1) ) 
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                	{
                		alt15=1;
                	}
                    break;
            }

            switch (alt15) 
            {
        	case 1:
        	    // IQL.g:688:18: ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )?
        	    {
        	        // IQL.g:688:18: ( HEX_DIGIT )
        	        // IQL.g:688:19: HEX_DIGIT
        	        {
        	            /* 688:19: HEX_DIGIT */
        	            mHEX_DIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleFOUR_DIGIT_HEXEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	        // IQL.g:688:30: ( ( HEX_DIGIT ) ( HEX_DIGIT )? )?
        	        {
        	            int alt14=2;
        	            switch ( LA(1) ) 
        	            {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                case 'A':
        	                case 'B':
        	                case 'C':
        	                case 'D':
        	                case 'E':
        	                case 'F':
        	                case 'a':
        	                case 'b':
        	                case 'c':
        	                case 'd':
        	                case 'e':
        	                case 'f':
        	                	{
        	                		alt14=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt14) 
        	            {
        	        	case 1:
        	        	    // IQL.g:688:31: ( HEX_DIGIT ) ( HEX_DIGIT )?
        	        	    {
        	        	        // IQL.g:688:31: ( HEX_DIGIT )
        	        	        // IQL.g:688:32: HEX_DIGIT
        	        	        {
        	        	            /* 688:32: HEX_DIGIT */
        	        	            mHEX_DIGIT(ctx ); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleFOUR_DIGIT_HEXEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }

        	        	        }


        	        	        // IQL.g:688:43: ( HEX_DIGIT )?
        	        	        {
        	        	            int alt13=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	                case '0':
        	        	                case '1':
        	        	                case '2':
        	        	                case '3':
        	        	                case '4':
        	        	                case '5':
        	        	                case '6':
        	        	                case '7':
        	        	                case '8':
        	        	                case '9':
        	        	                case 'A':
        	        	                case 'B':
        	        	                case 'C':
        	        	                case 'D':
        	        	                case 'E':
        	        	                case 'F':
        	        	                case 'a':
        	        	                case 'b':
        	        	                case 'c':
        	        	                case 'd':
        	        	                case 'e':
        	        	                case 'f':
        	        	                	{
        	        	                		alt13=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt13) 
        	        	            {
        	        	        	case 1:
        	        	        	    // IQL.g:688:44: HEX_DIGIT
        	        	        	    {
        	        	        	        /* 688:44: HEX_DIGIT */
        	        	        	        mHEX_DIGIT(ctx ); 
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleFOUR_DIGIT_HEXEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleFOUR_DIGIT_HEXEx; /* Prevent compiler warnings */
    ruleFOUR_DIGIT_HEXEx: ;

}
// $ANTLR end FOUR_DIGIT_HEX

//   Comes from: 692:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token HEX_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HEX_INTEGER_LITERAL;
       
    
    // IQL.g:692:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
    // IQL.g:693:5: '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )?
    {
        MATCHC('0'); 
        if  (HASEXCEPTION())
        {
            goto ruleHEX_INTEGER_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_INTEGER_LITERALEx;
        }

        // IQL.g:693:19: ( HEX_DIGIT )+
        {
            int cnt16=0;

            for (;;)
            {
                int alt16=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        		{
        			alt16=1;
        		}
        	    break;

        	}

        	switch (alt16) 
        	{
        	    case 1:
        	        // IQL.g:693:19: HEX_DIGIT
        	        {
        	            /* 693:19: HEX_DIGIT */
        	            mHEX_DIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleHEX_INTEGER_LITERALEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt16 >= 1 )
        		{
        		    goto loop16;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_INTEGER_LITERALEx;
        	}
        	cnt16++;
            }
            loop16: ;	/* Jump to here if this rule does not match */
        }

        // IQL.g:693:30: ( BIGINT_SUFFIX )?
        {
            int alt17=2;
            switch ( LA(1) ) 
            {
                case 'L':
                	{
                		alt17=1;
                	}
                    break;
            }

            switch (alt17) 
            {
        	case 1:
        	    // IQL.g:693:30: BIGINT_SUFFIX
        	    {
        	        /* 693:30: BIGINT_SUFFIX */
        	        mBIGINT_SUFFIX(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEX_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEX_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleHEX_INTEGER_LITERALEx: ;

}
// $ANTLR end HEX_INTEGER_LITERAL

//   Comes from: 697:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_INTEGER_LITERAL;
       
    
    // IQL.g:697:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
    // IQL.g:698:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
    {

        // IQL.g:698:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt19=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt19=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt19=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_INTEGER_LITERALEx;
            }

            switch (alt19) 
            {
        	case 1:
        	    // IQL.g:698:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:698:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:698:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt18=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt18=1;
        	            	}
        	                break;

        	            }

        	            switch (alt18) 
        	            {
        	        	case 1:
        	        	    // IQL.g:698:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop18;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop18: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_INTEGER_LITERALEx: ;

}
// $ANTLR end DECIMAL_INTEGER_LITERAL

//   Comes from: 702:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_BIGINT_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_BIGINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_BIGINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_BIGINT_LITERAL;
       
    
    // IQL.g:702:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
    // IQL.g:703:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX
    {

        // IQL.g:703:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt21=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt21=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt21=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_BIGINT_LITERALEx;
            }

            switch (alt21) 
            {
        	case 1:
        	    // IQL.g:703:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:703:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:703:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt20=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt20=1;
        	            	}
        	                break;

        	            }

        	            switch (alt20) 
        	            {
        	        	case 1:
        	        	    // IQL.g:703:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop20;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop20: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
        /* 703:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX */
        mBIGINT_SUFFIX(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_BIGINT_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_BIGINT_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_BIGINT_LITERALEx: ;

}
// $ANTLR end DECIMAL_BIGINT_LITERAL

//   Comes from: 707:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOATING_POINT_LITERAL
 *
 * Looks to match the characters the constitute the token FLOATING_POINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOATING_POINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOATING_POINT_LITERAL;
       
    
    {
        //  IQL.g:707:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
        
        ANTLR3_UINT32 alt30;

        alt30=3;

        alt30 = cdfa30.predict(ctx, RECOGNIZER, ISTREAM, &cdfa30);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATING_POINT_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt30) 
        {
    	case 1:
    	    // IQL.g:707:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        // IQL.g:707:9: ( '0' .. '9' )+
    	        {
    	            int cnt22=0;

    	            for (;;)
    	            {
    	                int alt22=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt22=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt22) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:707:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt22 >= 1 )
    	        		{
    	        		    goto loop22;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt22++;
    	            }
    	            loop22: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:707:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt23=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt23=1;
    	            	}
    	                break;

    	            }

    	            switch (alt23) 
    	            {
    	        	case 1:
    	        	    // IQL.g:707:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop23;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop23: ; /* Jump out to here if this rule does not match */

    	        /* 707:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:707:46: ( FLOAT_SUFFIX )?
    	        {
    	            int alt24=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt24=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt24) 
    	            {
    	        	case 1:
    	        	    // IQL.g:707:46: FLOAT_SUFFIX
    	        	    {
    	        	        /* 707:46: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:708:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:708:13: ( '0' .. '9' )+
    	        {
    	            int cnt25=0;

    	            for (;;)
    	            {
    	                int alt25=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt25=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt25) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:708:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt25 >= 1 )
    	        		{
    	        		    goto loop25;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt25++;
    	            }
    	            loop25: ;	/* Jump to here if this rule does not match */
    	        }
    	        /* 708:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:708:34: ( FLOAT_SUFFIX )?
    	        {
    	            int alt26=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt26=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt26) 
    	            {
    	        	case 1:
    	        	    // IQL.g:708:34: FLOAT_SUFFIX
    	        	    {
    	        	        /* 708:34: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:709:9: ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	    {
    	        // IQL.g:709:9: ( '0' .. '9' )+
    	        {
    	            int cnt27=0;

    	            for (;;)
    	            {
    	                int alt27=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt27=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt27) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:709:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt27 >= 1 )
    	        		{
    	        		    goto loop27;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt27++;
    	            }
    	            loop27: ;	/* Jump to here if this rule does not match */
    	        }

    	        // IQL.g:709:21: ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	        {
    	            int alt29=2;
    	            switch ( LA(1) ) 
    	            {
    	            case 'E':
    	            case 'e':
    	            	{
    	            		alt29=1;
    	            	}
    	                break;
    	            case 'D':
    	            case 'F':
    	            case 'd':
    	            case 'f':
    	            	{
    	            		alt29=2;
    	            	}
    	                break;

    	            default:
    	                if (BACKTRACKING>0)
    	                {
    	                    FAILEDFLAG = ANTLR3_TRUE;
    	                    return ;
    	                }
    	                CONSTRUCTEX();
    	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    	                EXCEPTION->message      = (void *)"";
    	                EXCEPTION->decisionNum  = 29;
    	                EXCEPTION->state        = 0;


    	                goto ruleFLOATING_POINT_LITERALEx;
    	            }

    	            switch (alt29) 
    	            {
    	        	case 1:
    	        	    // IQL.g:709:25: EXPONENT ( FLOAT_SUFFIX )?
    	        	    {
    	        	        /* 709:25: EXPONENT ( FLOAT_SUFFIX )? */
    	        	        mEXPONENT(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:709:34: ( FLOAT_SUFFIX )?
    	        	        {
    	        	            int alt28=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	                case 'D':
    	        	                case 'F':
    	        	                case 'd':
    	        	                case 'f':
    	        	                	{
    	        	                		alt28=1;
    	        	                	}
    	        	                    break;
    	        	            }

    	        	            switch (alt28) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:709:34: FLOAT_SUFFIX
    	        	        	    {
    	        	        	        /* 709:34: FLOAT_SUFFIX */
    	        	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	            }
    	        	        }

    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // IQL.g:710:9: FLOAT_SUFFIX
    	        	    {
    	        	        /* 710:9: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATING_POINT_LITERALEx; /* Prevent compiler warnings */
    ruleFLOATING_POINT_LITERALEx: ;

}
// $ANTLR end FLOATING_POINT_LITERAL

//   Comes from: 715:5: ( THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IPV4_LITERAL
 *
 * Looks to match the characters the constitute the token IPV4_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIPV4_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IPV4_LITERAL;
       
    
    // IQL.g:715:5: ( THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER )
    // IQL.g:716:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER
    {
        /* 716:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 716:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 716:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 716:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIPV4_LITERALEx; /* Prevent compiler warnings */
    ruleIPV4_LITERALEx: ;

}
// $ANTLR end IPV4_LITERAL

//   Comes from: 720:5: ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IPV6_LITERAL
 *
 * Looks to match the characters the constitute the token IPV6_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIPV6_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IPV6_LITERAL;
       
    
    {
        //  IQL.g:720:5: ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? )
        
        ANTLR3_UINT32 alt37;

        alt37=3;

        alt37 = cdfa37.predict(ctx, RECOGNIZER, ISTREAM, &cdfa37);
        if  (HASEXCEPTION())
        {
            goto ruleIPV6_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt37) 
        {
    	case 1:
    	    // IQL.g:721:5: ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	    {
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:721:13: ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	        {
    	            int alt32=2;
    	            switch ( LA(1) ) 
    	            {
    	                case '0':
    	                case '1':
    	                case '2':
    	                case '3':
    	                case '4':
    	                case '5':
    	                case '6':
    	                case '7':
    	                case '8':
    	                case '9':
    	                case 'A':
    	                case 'B':
    	                case 'C':
    	                case 'D':
    	                case 'E':
    	                case 'F':
    	                case 'a':
    	                case 'b':
    	                case 'c':
    	                case 'd':
    	                case 'e':
    	                case 'f':
    	                	{
    	                		alt32=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt32) 
    	            {
    	        	case 1:
    	        	    // IQL.g:721:14: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )*
    	        	    {
    	        	        /* 721:14: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* */
    	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleIPV6_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:721:29: ( ':' FOUR_DIGIT_HEX )*

    	        	        for (;;)
    	        	        {
    	        	            int alt31=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	            case ':':
    	        	            	{
    	        	            		alt31=1;
    	        	            	}
    	        	                break;

    	        	            }

    	        	            switch (alt31) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:721:30: ':' FOUR_DIGIT_HEX
    	        	        	    {
    	        	        	        MATCHC(':'); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }
    	        	        	        /* 721:30: ':' FOUR_DIGIT_HEX */
    	        	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	        	default:
    	        	        	    goto loop31;	/* break out of the loop */
    	        	        	    break;
    	        	            }
    	        	        }
    	        	        loop31: ; /* Jump out to here if this rule does not match */


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:723:5: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+
    	    {
    	        /* 723:5: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ */
    	        mFOUR_DIGIT_HEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:723:20: ( ':' FOUR_DIGIT_HEX )+
    	        {
    	            int cnt33=0;

    	            for (;;)
    	            {
    	                int alt33=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case ':':
    	        		{
    	        			alt33=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt33) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:723:21: ':' FOUR_DIGIT_HEX
    	        	        {
    	        	            MATCHC(':'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }
    	        	            /* 723:21: ':' FOUR_DIGIT_HEX */
    	        	            mFOUR_DIGIT_HEX(ctx ); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt33 >= 1 )
    	        		{
    	        		    goto loop33;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleIPV6_LITERALEx;
    	        	}
    	        	cnt33++;
    	            }
    	            loop33: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:725:5: ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	    {
    	        // IQL.g:726:5: ( FOUR_DIGIT_HEX ':' )+
    	        {
    	            int cnt34=0;

    	            for (;;)
    	            {
    	                int alt34=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        	case 'A':
    	        	case 'B':
    	        	case 'C':
    	        	case 'D':
    	        	case 'E':
    	        	case 'F':
    	        	case 'a':
    	        	case 'b':
    	        	case 'c':
    	        	case 'd':
    	        	case 'e':
    	        	case 'f':
    	        		{
    	        			alt34=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt34) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:726:6: FOUR_DIGIT_HEX ':'
    	        	        {
    	        	            /* 726:6: FOUR_DIGIT_HEX ':' */
    	        	            mFOUR_DIGIT_HEX(ctx ); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }
    	        	            MATCHC(':'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt34 >= 1 )
    	        		{
    	        		    goto loop34;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleIPV6_LITERALEx;
    	        	}
    	        	cnt34++;
    	            }
    	            loop34: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:727:5: ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	        {
    	            int alt36=2;
    	            switch ( LA(1) ) 
    	            {
    	                case '0':
    	                case '1':
    	                case '2':
    	                case '3':
    	                case '4':
    	                case '5':
    	                case '6':
    	                case '7':
    	                case '8':
    	                case '9':
    	                case 'A':
    	                case 'B':
    	                case 'C':
    	                case 'D':
    	                case 'E':
    	                case 'F':
    	                case 'a':
    	                case 'b':
    	                case 'c':
    	                case 'd':
    	                case 'e':
    	                case 'f':
    	                	{
    	                		alt36=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt36) 
    	            {
    	        	case 1:
    	        	    // IQL.g:727:6: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )*
    	        	    {
    	        	        /* 727:6: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* */
    	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleIPV6_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:727:21: ( ':' FOUR_DIGIT_HEX )*

    	        	        for (;;)
    	        	        {
    	        	            int alt35=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	            case ':':
    	        	            	{
    	        	            		alt35=1;
    	        	            	}
    	        	                break;

    	        	            }

    	        	            switch (alt35) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:727:22: ':' FOUR_DIGIT_HEX
    	        	        	    {
    	        	        	        MATCHC(':'); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }
    	        	        	        /* 727:22: ':' FOUR_DIGIT_HEX */
    	        	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	        	default:
    	        	        	    goto loop35;	/* break out of the loop */
    	        	        	    break;
    	        	            }
    	        	        }
    	        	        loop35: ; /* Jump out to here if this rule does not match */


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIPV6_LITERALEx; /* Prevent compiler warnings */
    ruleIPV6_LITERALEx: ;

}
// $ANTLR end IPV6_LITERAL

//   Comes from: 733:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:733:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // IQL.g:733:4: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleEXPONENTEx;
        }


        // IQL.g:733:14: ( '+' | '-' )?
        {
            int alt38=2;
            switch ( LA(1) ) 
            {
                case '+':
                case '-':
                	{
                		alt38=1;
                	}
                    break;
            }

            switch (alt38) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }
        // IQL.g:733:25: ( '0' .. '9' )+
        {
            int cnt39=0;

            for (;;)
            {
                int alt39=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt39=1;
        		}
        	    break;

        	}

        	switch (alt39) 
        	{
        	    case 1:
        	        // IQL.g:733:26: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleEXPONENTEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt39 >= 1 )
        		{
        		    goto loop39;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt39++;
            }
            loop39: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 739:2: ( 'f' | 'F' | 'd' | 'D' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT_SUFFIX
 *
 * Looks to match the characters the constitute the token FLOAT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:739:2: ( 'f' | 'F' | 'd' | 'D' )
    // IQL.g:
    {
        if ( LA(1) == 'D' || LA(1) == 'F' || LA(1) == 'd' || LA(1) == 'f' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFLOAT_SUFFIXEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFLOAT_SUFFIXEx; /* Prevent compiler warnings */
    ruleFLOAT_SUFFIXEx: ;

}
// $ANTLR end FLOAT_SUFFIX

//   Comes from: 743:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_LITERAL;
       
    
    {
        //  IQL.g:743:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
        
        ANTLR3_UINT32 alt43;

        alt43=2;

        switch ( LA(1) ) 
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
        		alt43=1;
        	}
            break;
        case '.':
        	{
        		alt43=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 43;
            EXCEPTION->state        = 0;


            goto ruleDECIMAL_LITERALEx;
        }

        switch (alt43) 
        {
    	case 1:
    	    // IQL.g:743:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )*
    	    {
    	        // IQL.g:743:9: ( '0' .. '9' )+
    	        {
    	            int cnt40=0;

    	            for (;;)
    	            {
    	                int alt40=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt40=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt40) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:743:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt40 >= 1 )
    	        		{
    	        		    goto loop40;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt40++;
    	            }
    	            loop40: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:743:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt41=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt41=1;
    	            	}
    	                break;

    	            }

    	            switch (alt41) 
    	            {
    	        	case 1:
    	        	    // IQL.g:743:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleDECIMAL_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop41;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop41: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // IQL.g:744:9: '.' ( '0' .. '9' )+
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:744:13: ( '0' .. '9' )+
    	        {
    	            int cnt42=0;

    	            for (;;)
    	            {
    	                int alt42=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt42=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt42) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:744:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt42 >= 1 )
    	        		{
    	        		    goto loop42;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt42++;
    	            }
    	            loop42: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_LITERALEx: ;

}
// $ANTLR end DECIMAL_LITERAL

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pIQLLexer ctx)
{
    {
        //  IQL.g:1:8: ( T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL )
        
        ANTLR3_UINT32 alt44;

        alt44=133;

        alt44 = cdfa44.predict(ctx, RECOGNIZER, ISTREAM, &cdfa44);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt44) 
        {
    	case 1:
    	    // IQL.g:1:10: T__120
    	    {
    	        /* 1:10: T__120 */
    	        mT__120(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:1:17: T__121
    	    {
    	        /* 1:17: T__121 */
    	        mT__121(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:1:24: T__122
    	    {
    	        /* 1:24: T__122 */
    	        mT__122(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 4:
    	    // IQL.g:1:31: T__123
    	    {
    	        /* 1:31: T__123 */
    	        mT__123(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 5:
    	    // IQL.g:1:38: T__124
    	    {
    	        /* 1:38: T__124 */
    	        mT__124(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 6:
    	    // IQL.g:1:45: T__125
    	    {
    	        /* 1:45: T__125 */
    	        mT__125(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 7:
    	    // IQL.g:1:52: T__126
    	    {
    	        /* 1:52: T__126 */
    	        mT__126(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 8:
    	    // IQL.g:1:59: T__127
    	    {
    	        /* 1:59: T__127 */
    	        mT__127(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 9:
    	    // IQL.g:1:66: T__128
    	    {
    	        /* 1:66: T__128 */
    	        mT__128(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 10:
    	    // IQL.g:1:73: T__129
    	    {
    	        /* 1:73: T__129 */
    	        mT__129(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 11:
    	    // IQL.g:1:80: T__130
    	    {
    	        /* 1:80: T__130 */
    	        mT__130(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 12:
    	    // IQL.g:1:87: T__131
    	    {
    	        /* 1:87: T__131 */
    	        mT__131(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 13:
    	    // IQL.g:1:94: T__132
    	    {
    	        /* 1:94: T__132 */
    	        mT__132(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 14:
    	    // IQL.g:1:101: T__133
    	    {
    	        /* 1:101: T__133 */
    	        mT__133(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 15:
    	    // IQL.g:1:108: T__134
    	    {
    	        /* 1:108: T__134 */
    	        mT__134(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 16:
    	    // IQL.g:1:115: T__135
    	    {
    	        /* 1:115: T__135 */
    	        mT__135(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 17:
    	    // IQL.g:1:122: T__136
    	    {
    	        /* 1:122: T__136 */
    	        mT__136(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 18:
    	    // IQL.g:1:129: T__137
    	    {
    	        /* 1:129: T__137 */
    	        mT__137(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 19:
    	    // IQL.g:1:136: T__138
    	    {
    	        /* 1:136: T__138 */
    	        mT__138(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 20:
    	    // IQL.g:1:143: T__139
    	    {
    	        /* 1:143: T__139 */
    	        mT__139(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 21:
    	    // IQL.g:1:150: T__140
    	    {
    	        /* 1:150: T__140 */
    	        mT__140(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 22:
    	    // IQL.g:1:157: T__141
    	    {
    	        /* 1:157: T__141 */
    	        mT__141(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 23:
    	    // IQL.g:1:164: T__142
    	    {
    	        /* 1:164: T__142 */
    	        mT__142(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 24:
    	    // IQL.g:1:171: T__143
    	    {
    	        /* 1:171: T__143 */
    	        mT__143(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 25:
    	    // IQL.g:1:178: T__144
    	    {
    	        /* 1:178: T__144 */
    	        mT__144(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 26:
    	    // IQL.g:1:185: T__145
    	    {
    	        /* 1:185: T__145 */
    	        mT__145(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 27:
    	    // IQL.g:1:192: T__146
    	    {
    	        /* 1:192: T__146 */
    	        mT__146(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 28:
    	    // IQL.g:1:199: T__147
    	    {
    	        /* 1:199: T__147 */
    	        mT__147(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 29:
    	    // IQL.g:1:206: T__148
    	    {
    	        /* 1:206: T__148 */
    	        mT__148(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 30:
    	    // IQL.g:1:213: TK_ADD
    	    {
    	        /* 1:213: TK_ADD */
    	        mTK_ADD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 31:
    	    // IQL.g:1:220: TK_ALL
    	    {
    	        /* 1:220: TK_ALL */
    	        mTK_ALL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 32:
    	    // IQL.g:1:227: TK_ALTER
    	    {
    	        /* 1:227: TK_ALTER */
    	        mTK_ALTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 33:
    	    // IQL.g:1:236: TK_AND
    	    {
    	        /* 1:236: TK_AND */
    	        mTK_AND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 34:
    	    // IQL.g:1:243: TK_ANY
    	    {
    	        /* 1:243: TK_ANY */
    	        mTK_ANY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 35:
    	    // IQL.g:1:250: TK_ARRAY
    	    {
    	        /* 1:250: TK_ARRAY */
    	        mTK_ARRAY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 36:
    	    // IQL.g:1:259: TK_AS
    	    {
    	        /* 1:259: TK_AS */
    	        mTK_AS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 37:
    	    // IQL.g:1:265: TK_ASC
    	    {
    	        /* 1:265: TK_ASC */
    	        mTK_ASC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 38:
    	    // IQL.g:1:272: TK_AVG
    	    {
    	        /* 1:272: TK_AVG */
    	        mTK_AVG(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 39:
    	    // IQL.g:1:279: TK_BEGIN
    	    {
    	        /* 1:279: TK_BEGIN */
    	        mTK_BEGIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 40:
    	    // IQL.g:1:288: TK_BETWEEN
    	    {
    	        /* 1:288: TK_BETWEEN */
    	        mTK_BETWEEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 41:
    	    // IQL.g:1:299: TK_BIGINT
    	    {
    	        /* 1:299: TK_BIGINT */
    	        mTK_BIGINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 42:
    	    // IQL.g:1:309: TK_BOOLEAN
    	    {
    	        /* 1:309: TK_BOOLEAN */
    	        mTK_BOOLEAN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 43:
    	    // IQL.g:1:320: TK_BREAK
    	    {
    	        /* 1:320: TK_BREAK */
    	        mTK_BREAK(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 44:
    	    // IQL.g:1:329: TK_BY
    	    {
    	        /* 1:329: TK_BY */
    	        mTK_BY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 45:
    	    // IQL.g:1:335: TK_CASE
    	    {
    	        /* 1:335: TK_CASE */
    	        mTK_CASE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 46:
    	    // IQL.g:1:343: TK_CAST
    	    {
    	        /* 1:343: TK_CAST */
    	        mTK_CAST(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 47:
    	    // IQL.g:1:351: TK_CHAR
    	    {
    	        /* 1:351: TK_CHAR */
    	        mTK_CHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 48:
    	    // IQL.g:1:359: TK_CIDRV4
    	    {
    	        /* 1:359: TK_CIDRV4 */
    	        mTK_CIDRV4(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 49:
    	    // IQL.g:1:369: TK_CIDRV6
    	    {
    	        /* 1:369: TK_CIDRV6 */
    	        mTK_CIDRV6(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 50:
    	    // IQL.g:1:379: TK_COALESCE
    	    {
    	        /* 1:379: TK_COALESCE */
    	        mTK_COALESCE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 51:
    	    // IQL.g:1:391: TK_CONTINUE
    	    {
    	        /* 1:391: TK_CONTINUE */
    	        mTK_CONTINUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 52:
    	    // IQL.g:1:403: TK_COUNT
    	    {
    	        /* 1:403: TK_COUNT */
    	        mTK_COUNT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 53:
    	    // IQL.g:1:412: TK_CREATE
    	    {
    	        /* 1:412: TK_CREATE */
    	        mTK_CREATE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 54:
    	    // IQL.g:1:422: TK_CROSS
    	    {
    	        /* 1:422: TK_CROSS */
    	        mTK_CROSS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 55:
    	    // IQL.g:1:431: TK_DATETIME
    	    {
    	        /* 1:431: TK_DATETIME */
    	        mTK_DATETIME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 56:
    	    // IQL.g:1:443: TK_DECLARE
    	    {
    	        /* 1:443: TK_DECLARE */
    	        mTK_DECLARE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 57:
    	    // IQL.g:1:454: TK_DECIMAL
    	    {
    	        /* 1:454: TK_DECIMAL */
    	        mTK_DECIMAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 58:
    	    // IQL.g:1:465: TK_DESC
    	    {
    	        /* 1:465: TK_DESC */
    	        mTK_DESC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 59:
    	    // IQL.g:1:473: TK_DISTINCT
    	    {
    	        /* 1:473: TK_DISTINCT */
    	        mTK_DISTINCT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 60:
    	    // IQL.g:1:485: TK_DOUBLE
    	    {
    	        /* 1:485: TK_DOUBLE */
    	        mTK_DOUBLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 61:
    	    // IQL.g:1:495: TK_ELSE
    	    {
    	        /* 1:495: TK_ELSE */
    	        mTK_ELSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 62:
    	    // IQL.g:1:503: TK_END
    	    {
    	        /* 1:503: TK_END */
    	        mTK_END(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 63:
    	    // IQL.g:1:510: TK_EXISTS
    	    {
    	        /* 1:510: TK_EXISTS */
    	        mTK_EXISTS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 64:
    	    // IQL.g:1:520: TK_FALSE
    	    {
    	        /* 1:520: TK_FALSE */
    	        mTK_FALSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 65:
    	    // IQL.g:1:529: TK_FROM
    	    {
    	        /* 1:529: TK_FROM */
    	        mTK_FROM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 66:
    	    // IQL.g:1:537: TK_FULL
    	    {
    	        /* 1:537: TK_FULL */
    	        mTK_FULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 67:
    	    // IQL.g:1:545: TK_FUNCTION
    	    {
    	        /* 1:545: TK_FUNCTION */
    	        mTK_FUNCTION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 68:
    	    // IQL.g:1:557: TK_GROUP
    	    {
    	        /* 1:557: TK_GROUP */
    	        mTK_GROUP(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 69:
    	    // IQL.g:1:566: TK_HAVING
    	    {
    	        /* 1:566: TK_HAVING */
    	        mTK_HAVING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 70:
    	    // IQL.g:1:576: TK_IF
    	    {
    	        /* 1:576: TK_IF */
    	        mTK_IF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 71:
    	    // IQL.g:1:582: TK_IN
    	    {
    	        /* 1:582: TK_IN */
    	        mTK_IN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 72:
    	    // IQL.g:1:588: TK_INDEX
    	    {
    	        /* 1:588: TK_INDEX */
    	        mTK_INDEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 73:
    	    // IQL.g:1:597: TK_INNER
    	    {
    	        /* 1:597: TK_INNER */
    	        mTK_INNER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 74:
    	    // IQL.g:1:606: TK_INTO
    	    {
    	        /* 1:606: TK_INTO */
    	        mTK_INTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 75:
    	    // IQL.g:1:614: TK_INTEGER
    	    {
    	        /* 1:614: TK_INTEGER */
    	        mTK_INTEGER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 76:
    	    // IQL.g:1:625: TK_INTERVAL
    	    {
    	        /* 1:625: TK_INTERVAL */
    	        mTK_INTERVAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 77:
    	    // IQL.g:1:637: TK_IPV4
    	    {
    	        /* 1:637: TK_IPV4 */
    	        mTK_IPV4(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 78:
    	    // IQL.g:1:645: TK_IPV6
    	    {
    	        /* 1:645: TK_IPV6 */
    	        mTK_IPV6(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 79:
    	    // IQL.g:1:653: TK_IS
    	    {
    	        /* 1:653: TK_IS */
    	        mTK_IS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 80:
    	    // IQL.g:1:659: TK_JOIN
    	    {
    	        /* 1:659: TK_JOIN */
    	        mTK_JOIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 81:
    	    // IQL.g:1:667: TK_KEY
    	    {
    	        /* 1:667: TK_KEY */
    	        mTK_KEY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 82:
    	    // IQL.g:1:674: TK_LEFT
    	    {
    	        /* 1:674: TK_LEFT */
    	        mTK_LEFT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 83:
    	    // IQL.g:1:682: TK_LIKE
    	    {
    	        /* 1:682: TK_LIKE */
    	        mTK_LIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 84:
    	    // IQL.g:1:690: TK_MAX
    	    {
    	        /* 1:690: TK_MAX */
    	        mTK_MAX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 85:
    	    // IQL.g:1:697: TK_MIN
    	    {
    	        /* 1:697: TK_MIN */
    	        mTK_MIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 86:
    	    // IQL.g:1:704: TK_NOT
    	    {
    	        /* 1:704: TK_NOT */
    	        mTK_NOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 87:
    	    // IQL.g:1:711: TK_NULL
    	    {
    	        /* 1:711: TK_NULL */
    	        mTK_NULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 88:
    	    // IQL.g:1:719: TK_NVARCHAR
    	    {
    	        /* 1:719: TK_NVARCHAR */
    	        mTK_NVARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 89:
    	    // IQL.g:1:731: TK_ON
    	    {
    	        /* 1:731: TK_ON */
    	        mTK_ON(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 90:
    	    // IQL.g:1:737: TK_OR
    	    {
    	        /* 1:737: TK_OR */
    	        mTK_OR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 91:
    	    // IQL.g:1:743: TK_ORDER
    	    {
    	        /* 1:743: TK_ORDER */
    	        mTK_ORDER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 92:
    	    // IQL.g:1:752: TK_OUTER
    	    {
    	        /* 1:752: TK_OUTER */
    	        mTK_OUTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 93:
    	    // IQL.g:1:761: TK_OUTPUT
    	    {
    	        /* 1:761: TK_OUTPUT */
    	        mTK_OUTPUT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 94:
    	    // IQL.g:1:771: TK_PRECISION
    	    {
    	        /* 1:771: TK_PRECISION */
    	        mTK_PRECISION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 95:
    	    // IQL.g:1:784: TK_PRINT
    	    {
    	        /* 1:784: TK_PRINT */
    	        mTK_PRINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 96:
    	    // IQL.g:1:793: TK_PROCEDURE
    	    {
    	        /* 1:793: TK_PROCEDURE */
    	        mTK_PROCEDURE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 97:
    	    // IQL.g:1:806: TK_RAISERROR
    	    {
    	        /* 1:806: TK_RAISERROR */
    	        mTK_RAISERROR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 98:
    	    // IQL.g:1:819: TK_REAL
    	    {
    	        /* 1:819: TK_REAL */
    	        mTK_REAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 99:
    	    // IQL.g:1:827: TK_RETURN
    	    {
    	        /* 1:827: TK_RETURN */
    	        mTK_RETURN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 100:
    	    // IQL.g:1:837: TK_RETURNS
    	    {
    	        /* 1:837: TK_RETURNS */
    	        mTK_RETURNS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 101:
    	    // IQL.g:1:848: TK_RIGHT
    	    {
    	        /* 1:848: TK_RIGHT */
    	        mTK_RIGHT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 102:
    	    // IQL.g:1:857: TK_RLIKE
    	    {
    	        /* 1:857: TK_RLIKE */
    	        mTK_RLIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 103:
    	    // IQL.g:1:866: TK_ROW
    	    {
    	        /* 1:866: TK_ROW */
    	        mTK_ROW(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 104:
    	    // IQL.g:1:873: TK_SELECT
    	    {
    	        /* 1:873: TK_SELECT */
    	        mTK_SELECT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 105:
    	    // IQL.g:1:883: TK_SET
    	    {
    	        /* 1:883: TK_SET */
    	        mTK_SET(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 106:
    	    // IQL.g:1:890: TK_SMALLINT
    	    {
    	        /* 1:890: TK_SMALLINT */
    	        mTK_SMALLINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 107:
    	    // IQL.g:1:902: TK_SOME
    	    {
    	        /* 1:902: TK_SOME */
    	        mTK_SOME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 108:
    	    // IQL.g:1:910: TK_SUM
    	    {
    	        /* 1:910: TK_SUM */
    	        mTK_SUM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 109:
    	    // IQL.g:1:917: TK_SWITCH
    	    {
    	        /* 1:917: TK_SWITCH */
    	        mTK_SWITCH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 110:
    	    // IQL.g:1:927: TK_THEN
    	    {
    	        /* 1:927: TK_THEN */
    	        mTK_THEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 111:
    	    // IQL.g:1:935: TK_TINYINT
    	    {
    	        /* 1:935: TK_TINYINT */
    	        mTK_TINYINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 112:
    	    // IQL.g:1:946: TK_TRUE
    	    {
    	        /* 1:946: TK_TRUE */
    	        mTK_TRUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 113:
    	    // IQL.g:1:954: TK_UNION
    	    {
    	        /* 1:954: TK_UNION */
    	        mTK_UNION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 114:
    	    // IQL.g:1:963: TK_VARCHAR
    	    {
    	        /* 1:963: TK_VARCHAR */
    	        mTK_VARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 115:
    	    // IQL.g:1:974: TK_WHEN
    	    {
    	        /* 1:974: TK_WHEN */
    	        mTK_WHEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 116:
    	    // IQL.g:1:982: TK_WHERE
    	    {
    	        /* 1:982: TK_WHERE */
    	        mTK_WHERE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 117:
    	    // IQL.g:1:991: TK_WHILE
    	    {
    	        /* 1:991: TK_WHILE */
    	        mTK_WHILE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 118:
    	    // IQL.g:1:1000: TK_WITH
    	    {
    	        /* 1:1000: TK_WITH */
    	        mTK_WITH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 119:
    	    // IQL.g:1:1008: STRING_LITERAL
    	    {
    	        /* 1:1008: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 120:
    	    // IQL.g:1:1023: WSTRING_LITERAL
    	    {
    	        /* 1:1023: WSTRING_LITERAL */
    	        mWSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 121:
    	    // IQL.g:1:1039: DOUBLE_QUOTED_STRING_LITERAL
    	    {
    	        /* 1:1039: DOUBLE_QUOTED_STRING_LITERAL */
    	        mDOUBLE_QUOTED_STRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 122:
    	    // IQL.g:1:1068: WS
    	    {
    	        /* 1:1068: WS */
    	        mWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 123:
    	    // IQL.g:1:1071: ML_COMMENT
    	    {
    	        /* 1:1071: ML_COMMENT */
    	        mML_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 124:
    	    // IQL.g:1:1082: SL_COMMENT
    	    {
    	        /* 1:1082: SL_COMMENT */
    	        mSL_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 125:
    	    // IQL.g:1:1093: ID
    	    {
    	        /* 1:1093: ID */
    	        mID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 126:
    	    // IQL.g:1:1096: QUOTED_ID
    	    {
    	        /* 1:1096: QUOTED_ID */
    	        mQUOTED_ID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 127:
    	    // IQL.g:1:1106: HEX_INTEGER_LITERAL
    	    {
    	        /* 1:1106: HEX_INTEGER_LITERAL */
    	        mHEX_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 128:
    	    // IQL.g:1:1126: DECIMAL_INTEGER_LITERAL
    	    {
    	        /* 1:1126: DECIMAL_INTEGER_LITERAL */
    	        mDECIMAL_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 129:
    	    // IQL.g:1:1150: DECIMAL_BIGINT_LITERAL
    	    {
    	        /* 1:1150: DECIMAL_BIGINT_LITERAL */
    	        mDECIMAL_BIGINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 130:
    	    // IQL.g:1:1173: FLOATING_POINT_LITERAL
    	    {
    	        /* 1:1173: FLOATING_POINT_LITERAL */
    	        mFLOATING_POINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 131:
    	    // IQL.g:1:1196: IPV4_LITERAL
    	    {
    	        /* 1:1196: IPV4_LITERAL */
    	        mIPV4_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 132:
    	    // IQL.g:1:1209: IPV6_LITERAL
    	    {
    	        /* 1:1209: IPV6_LITERAL */
    	        mIPV6_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 133:
    	    // IQL.g:1:1222: DECIMAL_LITERAL
    	    {
    	        /* 1:1222: DECIMAL_LITERAL */
    	        mDECIMAL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1_IQL
static void synpred1_IQL_fragment(pIQLLexer ctx ) 
{
    // IQL.g:725:5: ( ( FOUR_DIGIT_HEX ':' )+ ':' )
    // IQL.g:725:6: ( FOUR_DIGIT_HEX ':' )+ ':'
    {
        // IQL.g:725:6: ( FOUR_DIGIT_HEX ':' )+
        {
            int cnt45=0;

            for (;;)
            {
                int alt45=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        		{
        			alt45=1;
        		}
        	    break;

        	}

        	switch (alt45) 
        	{
        	    case 1:
        	        // IQL.g:725:7: FOUR_DIGIT_HEX ':'
        	        {
        	            /* 725:7: FOUR_DIGIT_HEX ':' */
        	            mFOUR_DIGIT_HEX(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_IQLEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC(':'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_IQLEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt45 >= 1 )
        		{
        		    goto loop45;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred1_IQLEx;
        	}
        	cnt45++;
            }
            loop45: ;	/* Jump to here if this rule does not match */
        }
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_IQLEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_IQLEx; /* Prevent compiler warnings */
rulesynpred1_IQLEx: ;

}
// $ANTLR end synpred1_IQL

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_IQL(pIQLLexer ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_IQL_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
