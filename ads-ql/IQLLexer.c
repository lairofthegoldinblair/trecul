/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : IQL.g
 *     -                            On : 2022-10-06 14:59:53
 *     -                 for the lexer : IQLLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "IQLLexer.h"
/* ----------------------------------------- */


/** String literals used by IQLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2D, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3C, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x3E, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x3E, 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x3C, 0x3C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x3C, 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x26, 0x26,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x41, 0x44, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x41, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x41, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x41, 0x4E, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x41, 0x52, 0x52, 0x41, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x41, 0x52, 0x52, 0x41, 0x59, 0x5F, 0x43, 0x4F, 0x4E, 0x43, 0x41, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x41, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x41, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x41, 0x56, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x42, 0x49, 0x47, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x42, 0x4F, 0x4F, 0x4C, 0x45, 0x41, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x42, 0x52, 0x45, 0x41, 0x4B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x42, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x43, 0x41, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x43, 0x41, 0x53, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x43, 0x49, 0x44, 0x52, 0x56, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x43, 0x49, 0x44, 0x52, 0x56, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x43, 0x4F, 0x41, 0x4C, 0x45, 0x53, 0x43, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x43, 0x4F, 0x4E, 0x54, 0x49, 0x4E, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x43, 0x4F, 0x55, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x43, 0x52, 0x4F, 0x53, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x44, 0x41, 0x54, 0x45, 0x54, 0x49, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x44, 0x45, 0x43, 0x4C, 0x54, 0x59, 0x50, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x44, 0x45, 0x43, 0x49, 0x4D, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x44, 0x45, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x44, 0x4F, 0x55, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x45, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x45, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x46, 0x52, 0x4F, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x46, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x46, 0x55, 0x4E, 0x43, 0x54, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x49, 0x46,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x49, 0x4E, 0x4E, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x49, 0x4E, 0x54, 0x4F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x49, 0x4E, 0x54, 0x45, 0x47, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x56, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x49, 0x50, 0x56, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x49, 0x50, 0x56, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x49, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x4A, 0x4F, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x4B, 0x45, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x4C, 0x45, 0x46, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x4D, 0x41, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x4D, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x4E, 0x4F, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x4E, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x4E, 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_74[]  = { 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_75[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_76[]  = { 0x4F, 0x55, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_77[]  = { 0x4F, 0x55, 0x54, 0x50, 0x55, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_78[]  = { 0x50, 0x52, 0x45, 0x43, 0x49, 0x53, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_79[]  = { 0x50, 0x52, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_80[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_81[]  = { 0x52, 0x41, 0x49, 0x53, 0x45, 0x52, 0x52, 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_82[]  = { 0x52, 0x45, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_83[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_84[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_85[]  = { 0x52, 0x49, 0x47, 0x48, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_86[]  = { 0x52, 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_87[]  = { 0x52, 0x4F, 0x57,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_88[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_89[]  = { 0x53, 0x45, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_90[]  = { 0x53, 0x4D, 0x41, 0x4C, 0x4C, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_91[]  = { 0x53, 0x4F, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_92[]  = { 0x53, 0x55, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_93[]  = { 0x53, 0x57, 0x49, 0x54, 0x43, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_94[]  = { 0x54, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_95[]  = { 0x54, 0x49, 0x4E, 0x59, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_96[]  = { 0x54, 0x52, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_97[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_98[]  = { 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_99[]  = { 0x57, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_100[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_101[]  = { 0x57, 0x48, 0x49, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_102[]  = { 0x57, 0x49, 0x54, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_103[]  = { 0x4E, 0x27,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_104[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_105[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_106[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pIQLLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pIQLLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pIQLLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pIQLLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mT__122    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__123    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__124    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__125    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__126    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__127    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__128    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__129    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__130    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__131    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__132    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__133    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__134    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__135    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__136    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__137    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__138    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__139    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__140    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__141    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__142    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__143    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__144    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__145    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__146    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__147    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__148    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__149    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__150    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__151    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__152    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__153    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__154    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__155    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ADD    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AND    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ANY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ARRAY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ARRAY_CONCAT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ASC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AVG    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BEGIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BETWEEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BIGINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BOOLEAN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BREAK    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CASE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CAST    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CIDRV4    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CIDRV6    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COALESCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CONTINUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COUNT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CREATE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CROSS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DATETIME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECLARE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECLTYPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECIMAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DESC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DISTINCT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DOUBLE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ELSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_END    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_EXISTS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FALSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FROM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FUNCTION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_GROUP    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_HAVING    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IF    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INDEX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INNER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTO    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTEGER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTERVAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IPV4    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IPV6    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_JOIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_KEY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LEFT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MAX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NOT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NVARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ON    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ORDER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTPUT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRECISION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PROCEDURE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RAISERROR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_REAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURNS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RIGHT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RLIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ROW    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SELECT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SET    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SMALLINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SOME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SUM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SWITCH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_THEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_TINYINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_TRUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_UNION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_VARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHERE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHILE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WITH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDOUBLE_QUOTED_STRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mESCAPE_SEQUENCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mOCTAL_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_DIGIT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mUNICODE_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mML_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSL_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mQUOTED_ID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mBIGINT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTHREE_DIGIT_NUMBER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFOUR_DIGIT_HEX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_BIGINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOATING_POINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mIPV4_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mIPV6_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mEXPONENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOAT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pIQLLexer ctx);
static ANTLR3_INLINE ANTLR3_BOOLEAN	synpred1_IQL    (pIQLLexer ctx);
static void	IQLLexerFree(pIQLLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
IQLLexerFree  (pIQLLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "IQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return IQLLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pIQLLexer ctx; // Context structure we will build and return

    ctx = (pIQLLexer) ANTLR3_CALLOC(1, sizeof(IQLLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in IQLLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our IQLLexer interface
     */
    ctx->mT__122	= mT__122;
    ctx->mT__123	= mT__123;
    ctx->mT__124	= mT__124;
    ctx->mT__125	= mT__125;
    ctx->mT__126	= mT__126;
    ctx->mT__127	= mT__127;
    ctx->mT__128	= mT__128;
    ctx->mT__129	= mT__129;
    ctx->mT__130	= mT__130;
    ctx->mT__131	= mT__131;
    ctx->mT__132	= mT__132;
    ctx->mT__133	= mT__133;
    ctx->mT__134	= mT__134;
    ctx->mT__135	= mT__135;
    ctx->mT__136	= mT__136;
    ctx->mT__137	= mT__137;
    ctx->mT__138	= mT__138;
    ctx->mT__139	= mT__139;
    ctx->mT__140	= mT__140;
    ctx->mT__141	= mT__141;
    ctx->mT__142	= mT__142;
    ctx->mT__143	= mT__143;
    ctx->mT__144	= mT__144;
    ctx->mT__145	= mT__145;
    ctx->mT__146	= mT__146;
    ctx->mT__147	= mT__147;
    ctx->mT__148	= mT__148;
    ctx->mT__149	= mT__149;
    ctx->mT__150	= mT__150;
    ctx->mT__151	= mT__151;
    ctx->mT__152	= mT__152;
    ctx->mT__153	= mT__153;
    ctx->mT__154	= mT__154;
    ctx->mT__155	= mT__155;
    ctx->mTK_ADD	= mTK_ADD;
    ctx->mTK_ALL	= mTK_ALL;
    ctx->mTK_ALTER	= mTK_ALTER;
    ctx->mTK_AND	= mTK_AND;
    ctx->mTK_ANY	= mTK_ANY;
    ctx->mTK_ARRAY	= mTK_ARRAY;
    ctx->mTK_ARRAY_CONCAT	= mTK_ARRAY_CONCAT;
    ctx->mTK_AS	= mTK_AS;
    ctx->mTK_ASC	= mTK_ASC;
    ctx->mTK_AVG	= mTK_AVG;
    ctx->mTK_BEGIN	= mTK_BEGIN;
    ctx->mTK_BETWEEN	= mTK_BETWEEN;
    ctx->mTK_BIGINT	= mTK_BIGINT;
    ctx->mTK_BOOLEAN	= mTK_BOOLEAN;
    ctx->mTK_BREAK	= mTK_BREAK;
    ctx->mTK_BY	= mTK_BY;
    ctx->mTK_CASE	= mTK_CASE;
    ctx->mTK_CAST	= mTK_CAST;
    ctx->mTK_CHAR	= mTK_CHAR;
    ctx->mTK_CIDRV4	= mTK_CIDRV4;
    ctx->mTK_CIDRV6	= mTK_CIDRV6;
    ctx->mTK_COALESCE	= mTK_COALESCE;
    ctx->mTK_CONTINUE	= mTK_CONTINUE;
    ctx->mTK_COUNT	= mTK_COUNT;
    ctx->mTK_CREATE	= mTK_CREATE;
    ctx->mTK_CROSS	= mTK_CROSS;
    ctx->mTK_DATETIME	= mTK_DATETIME;
    ctx->mTK_DECLARE	= mTK_DECLARE;
    ctx->mTK_DECLTYPE	= mTK_DECLTYPE;
    ctx->mTK_DECIMAL	= mTK_DECIMAL;
    ctx->mTK_DESC	= mTK_DESC;
    ctx->mTK_DISTINCT	= mTK_DISTINCT;
    ctx->mTK_DOUBLE	= mTK_DOUBLE;
    ctx->mTK_ELSE	= mTK_ELSE;
    ctx->mTK_END	= mTK_END;
    ctx->mTK_EXISTS	= mTK_EXISTS;
    ctx->mTK_FALSE	= mTK_FALSE;
    ctx->mTK_FROM	= mTK_FROM;
    ctx->mTK_FULL	= mTK_FULL;
    ctx->mTK_FUNCTION	= mTK_FUNCTION;
    ctx->mTK_GROUP	= mTK_GROUP;
    ctx->mTK_HAVING	= mTK_HAVING;
    ctx->mTK_IF	= mTK_IF;
    ctx->mTK_IN	= mTK_IN;
    ctx->mTK_INDEX	= mTK_INDEX;
    ctx->mTK_INNER	= mTK_INNER;
    ctx->mTK_INTO	= mTK_INTO;
    ctx->mTK_INTEGER	= mTK_INTEGER;
    ctx->mTK_INTERVAL	= mTK_INTERVAL;
    ctx->mTK_IPV4	= mTK_IPV4;
    ctx->mTK_IPV6	= mTK_IPV6;
    ctx->mTK_IS	= mTK_IS;
    ctx->mTK_JOIN	= mTK_JOIN;
    ctx->mTK_KEY	= mTK_KEY;
    ctx->mTK_LEFT	= mTK_LEFT;
    ctx->mTK_LIKE	= mTK_LIKE;
    ctx->mTK_MAX	= mTK_MAX;
    ctx->mTK_MIN	= mTK_MIN;
    ctx->mTK_NOT	= mTK_NOT;
    ctx->mTK_NULL	= mTK_NULL;
    ctx->mTK_NVARCHAR	= mTK_NVARCHAR;
    ctx->mTK_ON	= mTK_ON;
    ctx->mTK_OR	= mTK_OR;
    ctx->mTK_ORDER	= mTK_ORDER;
    ctx->mTK_OUTER	= mTK_OUTER;
    ctx->mTK_OUTPUT	= mTK_OUTPUT;
    ctx->mTK_PRECISION	= mTK_PRECISION;
    ctx->mTK_PRINT	= mTK_PRINT;
    ctx->mTK_PROCEDURE	= mTK_PROCEDURE;
    ctx->mTK_RAISERROR	= mTK_RAISERROR;
    ctx->mTK_REAL	= mTK_REAL;
    ctx->mTK_RETURN	= mTK_RETURN;
    ctx->mTK_RETURNS	= mTK_RETURNS;
    ctx->mTK_RIGHT	= mTK_RIGHT;
    ctx->mTK_RLIKE	= mTK_RLIKE;
    ctx->mTK_ROW	= mTK_ROW;
    ctx->mTK_SELECT	= mTK_SELECT;
    ctx->mTK_SET	= mTK_SET;
    ctx->mTK_SMALLINT	= mTK_SMALLINT;
    ctx->mTK_SOME	= mTK_SOME;
    ctx->mTK_SUM	= mTK_SUM;
    ctx->mTK_SWITCH	= mTK_SWITCH;
    ctx->mTK_THEN	= mTK_THEN;
    ctx->mTK_TINYINT	= mTK_TINYINT;
    ctx->mTK_TRUE	= mTK_TRUE;
    ctx->mTK_UNION	= mTK_UNION;
    ctx->mTK_VARCHAR	= mTK_VARCHAR;
    ctx->mTK_WHEN	= mTK_WHEN;
    ctx->mTK_WHERE	= mTK_WHERE;
    ctx->mTK_WHILE	= mTK_WHILE;
    ctx->mTK_WITH	= mTK_WITH;
    ctx->mSTRING_LITERAL	= mSTRING_LITERAL;
    ctx->mWSTRING_LITERAL	= mWSTRING_LITERAL;
    ctx->mDOUBLE_QUOTED_STRING_LITERAL	= mDOUBLE_QUOTED_STRING_LITERAL;
    ctx->mESCAPE_SEQUENCE	= mESCAPE_SEQUENCE;
    ctx->mOCTAL_ESCAPE	= mOCTAL_ESCAPE;
    ctx->mHEX_DIGIT	= mHEX_DIGIT;
    ctx->mUNICODE_ESCAPE	= mUNICODE_ESCAPE;
    ctx->mWS	= mWS;
    ctx->mML_COMMENT	= mML_COMMENT;
    ctx->mSL_COMMENT	= mSL_COMMENT;
    ctx->mID	= mID;
    ctx->mQUOTED_ID	= mQUOTED_ID;
    ctx->mBIGINT_SUFFIX	= mBIGINT_SUFFIX;
    ctx->mTHREE_DIGIT_NUMBER	= mTHREE_DIGIT_NUMBER;
    ctx->mFOUR_DIGIT_HEX	= mFOUR_DIGIT_HEX;
    ctx->mHEX_INTEGER_LITERAL	= mHEX_INTEGER_LITERAL;
    ctx->mDECIMAL_INTEGER_LITERAL	= mDECIMAL_INTEGER_LITERAL;
    ctx->mDECIMAL_BIGINT_LITERAL	= mDECIMAL_BIGINT_LITERAL;
    ctx->mFLOATING_POINT_LITERAL	= mFLOATING_POINT_LITERAL;
    ctx->mIPV4_LITERAL	= mIPV4_LITERAL;
    ctx->mIPV6_LITERAL	= mIPV6_LITERAL;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mFLOAT_SUFFIX	= mFLOAT_SUFFIX;
    ctx->mDECIMAL_LITERAL	= mDECIMAL_LITERAL;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= IQLLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    721:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );
 */
static const ANTLR3_INT32 dfa30_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_max[5] =
    {
	57, 102, -1, -1, -1
    };
static const ANTLR3_INT32 dfa30_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa30_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa30_T_empty	    NULL

static const ANTLR3_INT32 dfa30_T0[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };static const ANTLR3_INT32 dfa30_T1[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa30_transitions[] =
{
    dfa30_T0, dfa30_T1, dfa30_T_empty, dfa30_T_empty, dfa30_T_empty	
};


/* Declare tracking structure for Cyclic DFA 30
 */
static
ANTLR3_CYCLIC_DFA cdfa30
    =	{
	    30,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"721:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa30_eot,	    /* EOT table			    */
	    dfa30_eof,	    /* EOF table			    */
	    dfa30_min,	    /* Minimum tokens for each state    */
	    dfa30_max,	    /* Maximum tokens for each state    */
	    dfa30_accept,	/* Accept table			    */
	    dfa30_special,	/* Special transition states	    */
	    dfa30_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 30
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    734:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );
 */
static const ANTLR3_INT32 dfa37_eot[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 9, 9, 9
    };
static const ANTLR3_INT32 dfa37_eof[13] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa37_min[13] =
    {
	48, -1, 48, 48, 48, 48, -1, 48, 58, -1, 48, 48, 58
    };
static const ANTLR3_INT32 dfa37_max[13] =
    {
	102, -1, 102, 102, 102, 102, -1, 102, 58, -1, 102, 102, 58
    };
static const ANTLR3_INT32 dfa37_accept[13] =
    {
	-1, 1, -1, -1, -1, -1, 3, -1, -1, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa37_special[13] =
    {	
	-1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa37_T_empty	    NULL

static const ANTLR3_INT32 dfa37_T0[] =
    {
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, 2, 2
    };static const ANTLR3_INT32 dfa37_T1[] =
    {
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8
    };static const ANTLR3_INT32 dfa37_T2[] =
    {
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, -1, -1, -1, -1, -1, -1, 12, 
	12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, 12, 12, 12, 
	12
    };static const ANTLR3_INT32 dfa37_T3[] =
    {
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, -1, -1, -1, -1, -1, -1, 7, 7, 7, 7, 7, 
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 7, 7, 7, 7, 7
    };static const ANTLR3_INT32 dfa37_T4[] =
    {
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 5
    };static const ANTLR3_INT32 dfa37_T5[] =
    {
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3
    };static const ANTLR3_INT32 dfa37_T6[] =
    {
	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 4, -1, -1, -1, -1, -1, -1, 11, 
	11, 11, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 11, 11, 11, 11, 
	11
    };static const ANTLR3_INT32 dfa37_T7[] =
    {
	10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 4, -1, -1, -1, -1, -1, -1, 10, 
	10, 10, 10, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 
	10
    };static const ANTLR3_INT32 dfa37_T8[] =
    {
	4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa37_transitions[] =
{
    dfa37_T0, dfa37_T_empty, dfa37_T5, dfa37_T4, dfa37_T3, dfa37_T1, dfa37_T_empty, 
    dfa37_T7, dfa37_T8, dfa37_T_empty, dfa37_T6, dfa37_T2, dfa37_T8	
};

static ANTLR3_INT32 dfa37_sst(pIQLLexer ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;
    
    _s	    = s;
    switch  (s)
    {
        case 0:
        
    	{
    	    ANTLR3_UINT32 LA37_4;

    	    ANTLR3_MARKER index37_4;


    		LA37_4 = LA(1);

    	 
    	    index37_4 = INDEX();

    	    REWINDLAST();

    	    s = -1;
    	    if ( (LA37_4 == ':') && (synpred1_IQL(ctx)))
    	    {
    	        s = 6;
    	    }

    	    else if ( (((LA37_4 >= '0') && (LA37_4 <= '9')) || ((LA37_4 >= 'A') && (LA37_4 <= 'F')) || ((LA37_4 >= 'a') && (LA37_4 <= 'f'))) )
    	    {
    	        s = 7;
    	    }

    	 
    		SEEK(index37_4);

    	    if ( s>=0 ) 
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }    
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"734:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );";
    EXCEPTION->decisionNum  = 37;
    EXCEPTION->state        = _s;
    return -1;
}

/* Declare tracking structure for Cyclic DFA 37
 */
static
ANTLR3_CYCLIC_DFA cdfa37
    =	{
	    37,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"734:1: IPV6_LITERAL : ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? );",	
	    (CDFA_SPECIAL_FUNC) dfa37_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa37_eot,	    /* EOT table			    */
	    dfa37_eof,	    /* EOF table			    */
	    dfa37_min,	    /* Minimum tokens for each state    */
	    dfa37_max,	    /* Maximum tokens for each state    */
	    dfa37_accept,	/* Accept table			    */
	    dfa37_special,	/* Special transition states	    */
	    dfa37_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 37
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | T__149 | T__150 | T__151 | T__152 | T__153 | T__154 | T__155 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_ARRAY_CONCAT | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECLTYPE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL );
 */
static const ANTLR3_INT32 dfa44_eot[522] =
    {
	-1, -1, -1, -1, -1, -1, 56, 58, -1, -1, -1, -1, 60, -1, 62, 64, 67, 71, 
	-1, -1, 74, -1, -1, -1, -1, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, 54, -1, 140, 140, 
	-1, -1, -1, 147, -1, -1, -1, -1, -1, -1, -1, -1, 150, -1, -1, -1, 152, 
	-1, -1, -1, -1, 54, 54, 54, 54, 161, 54, 54, 54, 54, 54, 54, 168, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 191, 195, 54, 
	197, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, 207, 209, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, 
	147, -1, -1, 148, 140, -1, -1, -1, -1, -1, -1, 240, 54, 242, 54, 244, 245, 
	54, 247, -1, 248, 54, 54, 54, 54, 54, -1, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 270, 54, 54, 54, 54, 54, 54, 54, -1, 54, 54, 54, 
	-1, 54, -1, 54, 285, 54, 54, 288, 289, 290, 54, 54, -1, 54, -1, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 304, 54, 306, 54, 54, 309, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, -1, -1, 148, 147, 148, 140, -1, 54, -1, 54, -1, -1, 
	54, -1, -1, 54, 54, 54, 54, 54, 335, 336, 337, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 348, 54, 54, 351, -1, 54, 54, 354, 355, 54, 54, 54, 54, 54, 
	361, 54, 364, 365, 366, -1, 367, 368, -1, -1, -1, 369, 54, 54, 54, 54, 
	54, 54, 54, 54, 378, 54, 54, 54, -1, 54, -1, 54, 384, -1, 54, 386, 54, 
	388, 54, 54, 391, 54, 54, 394, -1, -1, 148, 148, 147, -1, 148, 140, 399, 
	401, 402, 54, 54, 54, 406, -1, -1, -1, 54, 54, 54, 411, 54, 413, 54, 54, 
	54, 54, -1, 54, 54, -1, 54, 421, -1, -1, 54, 423, 54, 425, 426, -1, 54, 
	54, -1, -1, -1, -1, -1, -1, 54, 430, 431, 54, 54, 434, 54, 54, -1, 54, 
	438, 439, 54, 54, -1, 54, -1, 54, -1, 444, 54, -1, 446, 447, -1, 147, -1, 
	147, 140, -1, 54, -1, -1, 54, 451, 54, -1, 453, 454, 54, 54, -1, 457, -1, 
	54, 54, 54, 54, 54, 463, 464, -1, 54, -1, 466, -1, -1, 54, 54, 54, -1, 
	-1, 470, 54, -1, 54, 54, 475, -1, -1, 476, 54, 478, 54, -1, 54, -1, -1, 
	147, 54, 482, -1, 483, -1, -1, 54, 54, -1, 54, 487, 54, 489, 54, -1, -1, 
	54, -1, 492, 54, 54, -1, 54, 54, 54, 498, -1, -1, 54, -1, 500, 501, 54, 
	-1, -1, 503, 504, 505, -1, 506, -1, 507, 508, -1, 509, 510, 54, 54, 54, 
	-1, 514, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, 516, 517, 518, -1, 
	54, -1, -1, -1, 54, 521, -1
    };
static const ANTLR3_INT32 dfa44_eof[522] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_min[522] =
    {
	9, -1, -1, -1, -1, -1, 62, 48, -1, -1, -1, -1, 58, -1, 124, 38, 61, 60, 
	-1, -1, 42, -1, -1, -1, -1, 48, 48, 48, 48, 48, 48, 82, 65, 70, 79, 69, 
	69, 65, 39, 78, 82, 65, 69, 72, 78, 65, 72, -1, -1, -1, 48, -1, 46, 46, 
	-1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, 61, -1, 
	-1, -1, -1, 48, 76, 68, 82, 48, 71, 48, 48, 71, 79, 69, 48, 48, 65, 68, 
	65, 69, 48, 48, 83, 85, 83, 68, 73, 48, 79, 76, 79, 86, 48, 48, 86, 48, 
	73, 89, 70, 75, 88, 78, 84, 76, 65, -1, 48, 48, 84, 69, 73, 65, 71, 73, 
	87, 76, 65, 77, 77, 73, 69, 78, 85, 73, 82, 69, 84, -1, -1, 46, 48, 43, 
	-1, 48, 46, -1, -1, -1, -1, -1, -1, 48, 48, 48, 69, 48, 48, 65, 48, -1, 
	48, 73, 87, 73, 76, 65, -1, 69, 82, 82, 76, 84, 78, 65, 83, 69, 48, 67, 
	84, 66, 69, 48, 83, 83, 77, 76, 67, 85, 73, -1, 69, 69, 69, -1, 52, -1, 
	78, 48, 84, 69, 48, 48, 48, 76, 82, -1, 69, -1, 69, 67, 78, 67, 83, 76, 
	85, 72, 75, 48, 69, 48, 76, 69, 48, 84, 78, 89, 69, 79, 67, 78, 76, 72, 
	46, 43, 48, 46, 48, 46, -1, 58, -1, 82, -1, -1, 89, -1, -1, 78, 69, 78, 
	69, 75, 48, 48, 48, 86, 69, 73, 84, 84, 83, 84, 65, 77, 48, 73, 76, 48, 
	-1, 84, 69, 48, 48, 84, 80, 78, 88, 82, 48, 71, 48, 48, 48, -1, 48, 48, 
	-1, -1, -1, 48, 67, 82, 82, 85, 73, 84, 69, 69, 48, 82, 84, 69, -1, 67, 
	-1, 76, 48, -1, 67, 48, 73, 48, 78, 72, 48, 69, 69, 48, 46, 43, 58, 58, 
	46, -1, 58, 46, 48, 48, 48, 69, 84, 65, 48, -1, -1, -1, 52, 83, 78, 48, 
	69, 48, 73, 82, 89, 65, -1, 78, 69, -1, 83, 48, -1, -1, 73, 48, 71, 48, 
	48, -1, 69, 86, -1, -1, -1, -1, -1, -1, 72, 48, 48, 84, 83, 48, 68, 82, 
	-1, 78, 48, 48, 84, 73, -1, 72, -1, 78, -1, 48, 65, -1, 48, 48, -1, 48, 
	46, 46, 46, -1, 67, -1, -1, 78, 48, 78, -1, 48, 48, 67, 85, -1, 48, -1, 
	77, 69, 80, 76, 67, 48, 48, -1, 79, -1, 48, -1, -1, 82, 65, 65, -1, -1, 
	48, 73, -1, 85, 82, 48, -1, -1, 48, 78, 48, 84, -1, 82, -1, -1, 48, 79, 
	48, -1, 48, -1, -1, 69, 69, -1, 69, 48, 69, 48, 84, -1, -1, 78, -1, 48, 
	76, 82, -1, 79, 82, 79, 48, -1, -1, 84, -1, 48, 48, 78, -1, -1, 48, 48, 
	48, -1, 48, -1, 48, 48, -1, 48, 48, 78, 69, 82, -1, 48, -1, -1, 67, -1, 
	-1, -1, -1, -1, -1, -1, -1, 48, 48, 48, -1, 65, -1, -1, -1, 84, 48, -1
    };
static const ANTLR3_INT32 dfa44_max[522] =
    {
	126, -1, -1, -1, -1, -1, 62, 57, -1, -1, -1, -1, 58, -1, 124, 38, 62, 62, 
	-1, -1, 47, -1, -1, -1, -1, 102, 102, 102, 102, 102, 102, 82, 65, 83, 79, 
	69, 73, 73, 86, 85, 82, 79, 87, 82, 78, 65, 73, -1, -1, -1, 102, -1, 120, 
	102, -1, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, 61, 
	-1, -1, -1, -1, 102, 84, 89, 82, 122, 71, 102, 102, 71, 79, 69, 122, 102, 
	65, 68, 85, 79, 102, 102, 83, 85, 83, 68, 73, 102, 79, 78, 79, 86, 122, 
	122, 86, 122, 73, 89, 70, 75, 88, 78, 84, 76, 65, -1, 122, 122, 84, 79, 
	73, 84, 71, 73, 87, 84, 65, 77, 77, 73, 69, 78, 85, 73, 82, 73, 84, -1, 
	-1, 102, 101, 102, -1, 102, 102, -1, -1, -1, -1, -1, -1, 122, 102, 122, 
	69, 122, 122, 65, 122, -1, 122, 73, 87, 73, 76, 65, -1, 84, 82, 82, 76, 
	84, 78, 65, 83, 69, 102, 67, 84, 66, 69, 122, 83, 83, 77, 76, 67, 85, 73, 
	-1, 69, 69, 79, -1, 54, -1, 78, 122, 84, 69, 122, 122, 122, 76, 82, -1, 
	69, -1, 80, 67, 78, 67, 83, 76, 85, 72, 75, 122, 69, 122, 76, 69, 122, 
	84, 78, 89, 69, 79, 67, 82, 76, 72, 102, 102, 102, 101, 102, 102, -1, 58, 
	-1, 82, -1, -1, 89, -1, -1, 78, 69, 78, 69, 75, 122, 122, 122, 86, 69, 
	73, 84, 84, 83, 84, 84, 77, 122, 73, 76, 122, -1, 84, 69, 122, 122, 84, 
	80, 78, 88, 82, 122, 82, 122, 122, 122, -1, 122, 122, -1, -1, -1, 122, 
	67, 82, 82, 85, 73, 84, 69, 69, 122, 82, 84, 69, -1, 67, -1, 76, 122, -1, 
	67, 122, 73, 122, 78, 72, 122, 69, 69, 122, 102, 58, 58, 58, 101, -1, 58, 
	102, 122, 122, 122, 69, 84, 65, 122, -1, -1, -1, 54, 83, 78, 122, 69, 122, 
	73, 82, 89, 65, -1, 78, 69, -1, 83, 122, -1, -1, 73, 122, 71, 122, 122, 
	-1, 69, 86, -1, -1, -1, -1, -1, -1, 72, 122, 122, 84, 83, 122, 68, 82, 
	-1, 78, 122, 122, 84, 73, -1, 72, -1, 78, -1, 122, 65, -1, 122, 122, -1, 
	101, 102, 101, 102, -1, 67, -1, -1, 78, 122, 78, -1, 122, 122, 67, 85, 
	-1, 122, -1, 77, 69, 80, 76, 67, 122, 122, -1, 79, -1, 122, -1, -1, 82, 
	65, 65, -1, -1, 122, 73, -1, 85, 82, 122, -1, -1, 122, 78, 122, 84, -1, 
	82, -1, -1, 101, 79, 122, -1, 122, -1, -1, 69, 69, -1, 69, 122, 69, 122, 
	84, -1, -1, 78, -1, 122, 76, 82, -1, 79, 82, 79, 122, -1, -1, 84, -1, 122, 
	122, 78, -1, -1, 122, 122, 122, -1, 122, -1, 122, 122, -1, 122, 122, 78, 
	69, 82, -1, 122, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, -1, 122, 122, 
	122, -1, 65, -1, -1, -1, 84, 122, -1
    };
static const ANTLR3_INT32 dfa44_accept[522] =
    {
	-1, 1, 2, 3, 4, 5, -1, -1, 8, 9, 10, 11, -1, 13, -1, -1, -1, -1, 21, 27, 
	-1, 31, 32, 33, 34, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 126, 128, 129, -1, 133, -1, -1, 132, 
	6, 28, -1, 7, 139, 12, 29, 14, 26, 15, 18, -1, 16, 19, 20, -1, 17, 130, 
	131, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 127, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 134, 135, -1, -1, -1, 136, 
	-1, -1, 140, 137, 23, 22, 25, 24, -1, -1, -1, -1, -1, -1, -1, -1, 42, -1, 
	-1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, 78, -1, 86, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 96, -1, 97, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 35, -1, 36, -1, 38, 39, -1, 43, 44, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 88, -1, -1, 91, 
	92, 93, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 110, -1, 112, 
	-1, -1, 115, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	138, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, 52, 53, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 65, -1, -1, 68, -1, -1, 72, 73, -1, -1, -1, -1, -1, 
	81, -1, -1, 84, 85, 87, 89, 90, 94, -1, -1, -1, -1, -1, -1, -1, -1, 105, 
	-1, -1, -1, -1, -1, 114, -1, 117, -1, 119, -1, -1, 122, -1, -1, 125, -1, 
	-1, -1, -1, 37, -1, 40, 45, -1, -1, -1, 49, -1, -1, -1, -1, 58, -1, 60, 
	-1, -1, -1, -1, -1, -1, -1, 71, -1, 75, -1, 79, 80, -1, -1, -1, 98, 99, 
	-1, -1, 102, -1, -1, -1, 108, 109, -1, -1, -1, -1, 120, -1, 123, 124, -1, 
	-1, -1, 47, -1, 54, 55, -1, -1, 59, -1, -1, -1, -1, -1, 67, 70, -1, 76, 
	-1, -1, -1, 100, -1, -1, -1, -1, 106, 111, -1, 116, -1, -1, -1, 46, 48, 
	-1, -1, -1, 62, -1, 64, -1, -1, 82, -1, -1, -1, -1, -1, 107, -1, 118, 121, 
	-1, 56, 57, 61, 63, 66, 74, 83, 95, -1, -1, -1, 113, -1, 101, 103, 104, 
	-1, -1, 41
    };
static const ANTLR3_INT32 dfa44_special[522] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa44_T_empty	    NULL

static const ANTLR3_INT32 dfa44_T0[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T1[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 474, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T2[] =
    {
	345, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 346
    };static const ANTLR3_INT32 dfa44_T3[] =
    {
	65, 66
    };static const ANTLR3_INT32 dfa44_T4[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 154, 154, 154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 154, 
	154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T5[] =
    {
	110, -1, -1, -1, 111
    };static const ANTLR3_INT32 dfa44_T6[] =
    {
	142, -1, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 322, 321, 322, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 322, 321, 322
    };static const ANTLR3_INT32 dfa44_T7[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 154, 154, 154, 163, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 164, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 
	154, 154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T8[] =
    {
	395, -1, 398, 398, 398, 398, 398, 398, 398, 398, 398, 398, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 148, 148, 148, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148, 148, 148
    };static const ANTLR3_INT32 dfa44_T9[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 81, 
	81, 81, 81, 81, 81, -1, -1, -1, -1, -1, 96, -1, 97, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T10[] =
    {
	102
    };static const ANTLR3_INT32 dfa44_T11[] =
    {
	112, -1, -1, -1, -1, -1, -1, -1, 113
    };static const ANTLR3_INT32 dfa44_T12[] =
    {
	237, 237, 237, 237, 237, 237, 237, 237, 237, 237, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 148
    };static const ANTLR3_INT32 dfa44_T13[] =
    {
	103
    };static const ANTLR3_INT32 dfa44_T14[] =
    {
	148, -1, 148, -1, -1, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 
	59, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 59, 59, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa44_T15[] =
    {
	231, -1, -1, -1, 232
    };static const ANTLR3_INT32 dfa44_T16[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 81, 
	81, 81, 81, 82, 81, -1, -1, 83, -1, -1, -1, -1, -1, 84, -1, -1, 85, -1, 
	-1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T17[] =
    {
	281, -1, -1, -1, -1, -1, -1, -1, -1, -1, 280
    };static const ANTLR3_INT32 dfa44_T18[] =
    {
	243
    };static const ANTLR3_INT32 dfa44_T19[] =
    {
	328
    };static const ANTLR3_INT32 dfa44_T20[] =
    {
	325, -1, 324, 324, 324, 324, 324, 324, 324, 324, 324, 324, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa44_T21[] =
    {
	395, -1, 398, 398, 398, 398, 398, 398, 398, 398, 398, 398, 59, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 148, 148, 148, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148, 148, 148
    };static const ANTLR3_INT32 dfa44_T22[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 154, 154, 154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 169, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 154, 
	154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T23[] =
    {
	108
    };static const ANTLR3_INT32 dfa44_T24[] =
    {
	109
    };static const ANTLR3_INT32 dfa44_T25[] =
    {
	449
    };static const ANTLR3_INT32 dfa44_T26[] =
    {
	481
    };static const ANTLR3_INT32 dfa44_T27[] =
    {
	502
    };static const ANTLR3_INT32 dfa44_T28[] =
    {
	515
    };static const ANTLR3_INT32 dfa44_T29[] =
    {
	519
    };static const ANTLR3_INT32 dfa44_T30[] =
    {
	520
    };static const ANTLR3_INT32 dfa44_T31[] =
    {
	117, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 114, -1, -1, -1, -1, -1, 115, 116
    };static const ANTLR3_INT32 dfa44_T32[] =
    {
	59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, -1, 59, 
	59, 59, 59, 59, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 
	59
    };static const ANTLR3_INT32 dfa44_T33[] =
    {
	121
    };static const ANTLR3_INT32 dfa44_T34[] =
    {
	187, -1, 188
    };static const ANTLR3_INT32 dfa44_T35[] =
    {
	162
    };static const ANTLR3_INT32 dfa44_T36[] =
    {
	249
    };static const ANTLR3_INT32 dfa44_T37[] =
    {
	330
    };static const ANTLR3_INT32 dfa44_T38[] =
    {
	250
    };static const ANTLR3_INT32 dfa44_T39[] =
    {
	331
    };static const ANTLR3_INT32 dfa44_T40[] =
    {
	403
    };static const ANTLR3_INT32 dfa44_T41[] =
    {
	450
    };static const ANTLR3_INT32 dfa44_T42[] =
    {
	165
    };static const ANTLR3_INT32 dfa44_T43[] =
    {
	251
    };static const ANTLR3_INT32 dfa44_T44[] =
    {
	332
    };static const ANTLR3_INT32 dfa44_T45[] =
    {
	404
    };static const ANTLR3_INT32 dfa44_T46[] =
    {
	166
    };static const ANTLR3_INT32 dfa44_T47[] =
    {
	252
    };static const ANTLR3_INT32 dfa44_T48[] =
    {
	333
    };static const ANTLR3_INT32 dfa44_T49[] =
    {
	405
    };static const ANTLR3_INT32 dfa44_T50[] =
    {
	452
    };static const ANTLR3_INT32 dfa44_T51[] =
    {
	167
    };static const ANTLR3_INT32 dfa44_T52[] =
    {
	253
    };static const ANTLR3_INT32 dfa44_T53[] =
    {
	334
    };static const ANTLR3_INT32 dfa44_T54[] =
    {
	170
    };static const ANTLR3_INT32 dfa44_T55[] =
    {
	256
    };static const ANTLR3_INT32 dfa44_T56[] =
    {
	142, -1, 141, 141, 141, 141, 141, 141, 141, 141, 141, 141, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 145, 143, 145, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 139, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 145, 143, 145, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 139
    };static const ANTLR3_INT32 dfa44_T57[] =
    {
	63
    };static const ANTLR3_INT32 dfa44_T58[] =
    {
	61
    };static const ANTLR3_INT32 dfa44_T59[] =
    {
	258
    };static const ANTLR3_INT32 dfa44_T60[] =
    {
	339
    };static const ANTLR3_INT32 dfa44_T61[] =
    {
	409
    };static const ANTLR3_INT32 dfa44_T62[] =
    {
	455
    };static const ANTLR3_INT32 dfa44_T63[] =
    {
	484
    };static const ANTLR3_INT32 dfa44_T64[] =
    {
	259
    };static const ANTLR3_INT32 dfa44_T65[] =
    {
	340
    };static const ANTLR3_INT32 dfa44_T66[] =
    {
	410
    };static const ANTLR3_INT32 dfa44_T67[] =
    {
	456
    };static const ANTLR3_INT32 dfa44_T68[] =
    {
	485
    };static const ANTLR3_INT32 dfa44_T69[] =
    {
	260
    };static const ANTLR3_INT32 dfa44_T70[] =
    {
	341
    };static const ANTLR3_INT32 dfa44_T71[] =
    {
	261
    };static const ANTLR3_INT32 dfa44_T72[] =
    {
	342
    };static const ANTLR3_INT32 dfa44_T73[] =
    {
	412
    };static const ANTLR3_INT32 dfa44_T74[] =
    {
	59
    };static const ANTLR3_INT32 dfa44_T75[] =
    {
	262
    };static const ANTLR3_INT32 dfa44_T76[] =
    {
	343
    };static const ANTLR3_INT32 dfa44_T77[] =
    {
	362, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 363
    };static const ANTLR3_INT32 dfa44_T78[] =
    {
	263
    };static const ANTLR3_INT32 dfa44_T79[] =
    {
	344
    };static const ANTLR3_INT32 dfa44_T80[] =
    {
	414
    };static const ANTLR3_INT32 dfa44_T81[] =
    {
	458
    };static const ANTLR3_INT32 dfa44_T82[] =
    {
	486
    };static const ANTLR3_INT32 dfa44_T83[] =
    {
	415
    };static const ANTLR3_INT32 dfa44_T84[] =
    {
	149
    };static const ANTLR3_INT32 dfa44_T85[] =
    {
	459
    };static const ANTLR3_INT32 dfa44_T86[] =
    {
	55
    };static const ANTLR3_INT32 dfa44_T87[] =
    {
	416
    };static const ANTLR3_INT32 dfa44_T88[] =
    {
	460
    };static const ANTLR3_INT32 dfa44_T89[] =
    {
	488
    };static const ANTLR3_INT32 dfa44_T90[] =
    {
	347
    };static const ANTLR3_INT32 dfa44_T91[] =
    {
	196
    };static const ANTLR3_INT32 dfa44_T92[] =
    {
	417
    };static const ANTLR3_INT32 dfa44_T93[] =
    {
	461
    };static const ANTLR3_INT32 dfa44_T94[] =
    {
	282, -1, 283
    };static const ANTLR3_INT32 dfa44_T95[] =
    {
	142, -1, 239, 239, 239, 239, 239, 239, 239, 239, 239, 239, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 236, 235, 236, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 236, 235, 236
    };static const ANTLR3_INT32 dfa44_T96[] =
    {
	122, -1, -1, -1, 123, -1, -1, -1, 124, -1, -1, 125, -1, -1, 126
    };static const ANTLR3_INT32 dfa44_T97[] =
    {
	266
    };static const ANTLR3_INT32 dfa44_T98[] =
    {
	180
    };static const ANTLR3_INT32 dfa44_T99[] =
    {
	267
    };static const ANTLR3_INT32 dfa44_T100[] =
    {
	349
    };static const ANTLR3_INT32 dfa44_T101[] =
    {
	418
    };static const ANTLR3_INT32 dfa44_T102[] =
    {
	151
    };static const ANTLR3_INT32 dfa44_T103[] =
    {
	462
    };static const ANTLR3_INT32 dfa44_T104[] =
    {
	490
    };static const ANTLR3_INT32 dfa44_T105[] =
    {
	181
    };static const ANTLR3_INT32 dfa44_T106[] =
    {
	268
    };static const ANTLR3_INT32 dfa44_T107[] =
    {
	350
    };static const ANTLR3_INT32 dfa44_T108[] =
    {
	419
    };static const ANTLR3_INT32 dfa44_T109[] =
    {
	182
    };static const ANTLR3_INT32 dfa44_T110[] =
    {
	269
    };static const ANTLR3_INT32 dfa44_T111[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 400, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T112[] =
    {
	183
    };static const ANTLR3_INT32 dfa44_T113[] =
    {
	184
    };static const ANTLR3_INT32 dfa44_T114[] =
    {
	271
    };static const ANTLR3_INT32 dfa44_T115[] =
    {
	352
    };static const ANTLR3_INT32 dfa44_T116[] =
    {
	420
    };static const ANTLR3_INT32 dfa44_T117[] =
    {
	135
    };static const ANTLR3_INT32 dfa44_T118[] =
    {
	272
    };static const ANTLR3_INT32 dfa44_T119[] =
    {
	353
    };static const ANTLR3_INT32 dfa44_T120[] =
    {
	136
    };static const ANTLR3_INT32 dfa44_T121[] =
    {
	186
    };static const ANTLR3_INT32 dfa44_T122[] =
    {
	273
    };static const ANTLR3_INT32 dfa44_T123[] =
    {
	70, 68, 69
    };static const ANTLR3_INT32 dfa44_T124[] =
    {
	274
    };static const ANTLR3_INT32 dfa44_T125[] =
    {
	275
    };static const ANTLR3_INT32 dfa44_T126[] =
    {
	356
    };static const ANTLR3_INT32 dfa44_T127[] =
    {
	422
    };static const ANTLR3_INT32 dfa44_T128[] =
    {
	465
    };static const ANTLR3_INT32 dfa44_T129[] =
    {
	491
    };static const ANTLR3_INT32 dfa44_T130[] =
    {
	104, -1, -1, -1, -1, -1, -1, -1, 105, -1, 106, -1, -1, 107
    };static const ANTLR3_INT32 dfa44_T131[] =
    {
	189
    };static const ANTLR3_INT32 dfa44_T132[] =
    {
	276
    };static const ANTLR3_INT32 dfa44_T133[] =
    {
	357
    };static const ANTLR3_INT32 dfa44_T134[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 160, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T135[] =
    {
	190
    };static const ANTLR3_INT32 dfa44_T136[] =
    {
	325, -1, 448, 448, 448, 448, 448, 448, 448, 448, 448, 448, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa44_T137[] =
    {
	277
    };static const ANTLR3_INT32 dfa44_T138[] =
    {
	358
    };static const ANTLR3_INT32 dfa44_T139[] =
    {
	424
    };static const ANTLR3_INT32 dfa44_T140[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 153, 154, 154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 154, 
	154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T141[] =
    {
	278
    };static const ANTLR3_INT32 dfa44_T142[] =
    {
	359
    };static const ANTLR3_INT32 dfa44_T143[] =
    {
	49, 49, -1, 49, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 49, 18, 48, 23, 24, 21, 15, 47, 9, 10, 8, 19, 5, 6, 
	7, 20, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 12, 1, 17, 2, 16, 11, -1, 
	25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 54, 41, 
	42, 43, 44, 45, 46, 54, 54, 54, 3, -1, 4, 13, 54, 51, 50, 50, 50, 50, 50, 
	50, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, -1, 14, -1, 22
    };static const ANTLR3_INT32 dfa44_T144[] =
    {
	279
    };static const ANTLR3_INT32 dfa44_T145[] =
    {
	360
    };static const ANTLR3_INT32 dfa44_T146[] =
    {
	325, -1, 397, 397, 397, 397, 397, 397, 397, 397, 397, 397, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa44_T147[] =
    {
	142, -1, 320, 320, 320, 320, 320, 320, 320, 320, 320, 320, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 322, 321, 322, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 322, 321, 322
    };static const ANTLR3_INT32 dfa44_T148[] =
    {
	427
    };static const ANTLR3_INT32 dfa44_T149[] =
    {
	467
    };static const ANTLR3_INT32 dfa44_T150[] =
    {
	395, -1, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 148, 148, 148, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148, 148, 148
    };static const ANTLR3_INT32 dfa44_T151[] =
    {
	428
    };static const ANTLR3_INT32 dfa44_T152[] =
    {
	448, 448, 448, 448, 448, 448, 448, 448, 448, 448, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 148
    };static const ANTLR3_INT32 dfa44_T153[] =
    {
	468
    };static const ANTLR3_INT32 dfa44_T154[] =
    {
	493
    };static const ANTLR3_INT32 dfa44_T155[] =
    {
	172, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 173, -1, -1, -1, -1, 
	-1, -1, 174
    };static const ANTLR3_INT32 dfa44_T156[] =
    {
	198
    };static const ANTLR3_INT32 dfa44_T157[] =
    {
	284
    };static const ANTLR3_INT32 dfa44_T158[] =
    {
	199
    };static const ANTLR3_INT32 dfa44_T159[] =
    {
	200
    };static const ANTLR3_INT32 dfa44_T160[] =
    {
	286
    };static const ANTLR3_INT32 dfa44_T161[] =
    {
	201
    };static const ANTLR3_INT32 dfa44_T162[] =
    {
	287
    };static const ANTLR3_INT32 dfa44_T163[] =
    {
	210
    };static const ANTLR3_INT32 dfa44_T164[] =
    {
	294, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 295
    };static const ANTLR3_INT32 dfa44_T165[] =
    {
	202
    };static const ANTLR3_INT32 dfa44_T166[] =
    {
	211, -1, -1, -1, 212, -1, -1, -1, -1, -1, 213
    };static const ANTLR3_INT32 dfa44_T167[] =
    {
	203
    };static const ANTLR3_INT32 dfa44_T168[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 192, 54, 54, 54, 54, 54, 54, 54, 54, 54, 193, 54, 54, 54, 54, 54, 
	194, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T169[] =
    {
	204
    };static const ANTLR3_INT32 dfa44_T170[] =
    {
	205
    };static const ANTLR3_INT32 dfa44_T171[] =
    {
	291
    };static const ANTLR3_INT32 dfa44_T172[] =
    {
	155, -1, -1, -1, -1, -1, -1, -1, 156
    };static const ANTLR3_INT32 dfa44_T173[] =
    {
	395, -1, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 59, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 148, 148, 148, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 148, 148, 148
    };static const ANTLR3_INT32 dfa44_T174[] =
    {
	206
    };static const ANTLR3_INT32 dfa44_T175[] =
    {
	292
    };static const ANTLR3_INT32 dfa44_T176[] =
    {
	132, 133, -1, -1, -1, -1, -1, -1, -1, -1, 134
    };static const ANTLR3_INT32 dfa44_T177[] =
    {
	370
    };static const ANTLR3_INT32 dfa44_T178[] =
    {
	429
    };static const ANTLR3_INT32 dfa44_T179[] =
    {
	469
    };static const ANTLR3_INT32 dfa44_T180[] =
    {
	494
    };static const ANTLR3_INT32 dfa44_T181[] =
    {
	293
    };static const ANTLR3_INT32 dfa44_T182[] =
    {
	371
    };static const ANTLR3_INT32 dfa44_T183[] =
    {
	72, -1, -1, -1, -1, 73
    };static const ANTLR3_INT32 dfa44_T184[] =
    {
	157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 158
    };static const ANTLR3_INT32 dfa44_T185[] =
    {
	372
    };static const ANTLR3_INT32 dfa44_T186[] =
    {
	57, 57, 57, 57, 57, 57, 57, 57, 57, 57, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 148, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 148
    };static const ANTLR3_INT32 dfa44_T187[] =
    {
	373
    };static const ANTLR3_INT32 dfa44_T188[] =
    {
	432
    };static const ANTLR3_INT32 dfa44_T189[] =
    {
	296
    };static const ANTLR3_INT32 dfa44_T190[] =
    {
	374
    };static const ANTLR3_INT32 dfa44_T191[] =
    {
	433
    };static const ANTLR3_INT32 dfa44_T192[] =
    {
	471
    };static const ANTLR3_INT32 dfa44_T193[] =
    {
	495
    };static const ANTLR3_INT32 dfa44_T194[] =
    {
	159
    };static const ANTLR3_INT32 dfa44_T195[] =
    {
	511
    };static const ANTLR3_INT32 dfa44_T196[] =
    {
	246
    };static const ANTLR3_INT32 dfa44_T197[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 92, 
	81, 81, 81, 93, 81, -1, -1, 94, -1, -1, -1, -1, -1, 95, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T198[] =
    {
	329
    };static const ANTLR3_INT32 dfa44_T199[] =
    {
	297
    };static const ANTLR3_INT32 dfa44_T200[] =
    {
	375
    };static const ANTLR3_INT32 dfa44_T201[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 81, 
	81, 81, 75, 81, 81, -1, -1, -1, -1, -1, 76, -1, 77, -1, -1, -1, 78, 79, 
	-1, -1, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T202[] =
    {
	298
    };static const ANTLR3_INT32 dfa44_T203[] =
    {
	376
    };static const ANTLR3_INT32 dfa44_T204[] =
    {
	435
    };static const ANTLR3_INT32 dfa44_T205[] =
    {
	472
    };static const ANTLR3_INT32 dfa44_T206[] =
    {
	496
    };static const ANTLR3_INT32 dfa44_T207[] =
    {
	512
    };static const ANTLR3_INT32 dfa44_T208[] =
    {
	214
    };static const ANTLR3_INT32 dfa44_T209[] =
    {
	127, -1, -1, -1, -1, -1, -1, -1, 128, -1, 129, -1, -1, -1, -1, -1, 130, 
	-1, 131
    };static const ANTLR3_INT32 dfa44_T210[] =
    {
	299
    };static const ANTLR3_INT32 dfa44_T211[] =
    {
	377
    };static const ANTLR3_INT32 dfa44_T212[] =
    {
	436
    };static const ANTLR3_INT32 dfa44_T213[] =
    {
	473
    };static const ANTLR3_INT32 dfa44_T214[] =
    {
	497
    };static const ANTLR3_INT32 dfa44_T215[] =
    {
	513
    };static const ANTLR3_INT32 dfa44_T216[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 154, 154, 154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 177, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 154, 
	154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T217[] =
    {
	300
    };static const ANTLR3_INT32 dfa44_T218[] =
    {
	215, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 216
    };static const ANTLR3_INT32 dfa44_T219[] =
    {
	301
    };static const ANTLR3_INT32 dfa44_T220[] =
    {
	379
    };static const ANTLR3_INT32 dfa44_T221[] =
    {
	437
    };static const ANTLR3_INT32 dfa44_T222[] =
    {
	217
    };static const ANTLR3_INT32 dfa44_T223[] =
    {
	302
    };static const ANTLR3_INT32 dfa44_T224[] =
    {
	380
    };static const ANTLR3_INT32 dfa44_T225[] =
    {
	218
    };static const ANTLR3_INT32 dfa44_T226[] =
    {
	303
    };static const ANTLR3_INT32 dfa44_T227[] =
    {
	381
    };static const ANTLR3_INT32 dfa44_T228[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 178, 154, 154, 154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 179, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 154, 
	154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T229[] =
    {
	219
    };static const ANTLR3_INT32 dfa44_T230[] =
    {
	305
    };static const ANTLR3_INT32 dfa44_T231[] =
    {
	382
    };static const ANTLR3_INT32 dfa44_T232[] =
    {
	440
    };static const ANTLR3_INT32 dfa44_T233[] =
    {
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, 54, 
	54, 54, 208, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54
    };static const ANTLR3_INT32 dfa44_T234[] =
    {
	222
    };static const ANTLR3_INT32 dfa44_T235[] =
    {
	307
    };static const ANTLR3_INT32 dfa44_T236[] =
    {
	383
    };static const ANTLR3_INT32 dfa44_T237[] =
    {
	441
    };static const ANTLR3_INT32 dfa44_T238[] =
    {
	477
    };static const ANTLR3_INT32 dfa44_T239[] =
    {
	499
    };static const ANTLR3_INT32 dfa44_T240[] =
    {
	223
    };static const ANTLR3_INT32 dfa44_T241[] =
    {
	308
    };static const ANTLR3_INT32 dfa44_T242[] =
    {
	241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 59, -1, -1, -1, -1, -1, 
	-1, 241, 241, 241, 241, 241, 241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, 241, 
	241, 241, 241, 241
    };static const ANTLR3_INT32 dfa44_T243[] =
    {
	224
    };static const ANTLR3_INT32 dfa44_T244[] =
    {
	241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 59, -1, -1, -1, -1, -1, 
	-1, 241, 241, 241, 241, 241, 241, -1, -1, 265, -1, -1, 264, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241, 
	241, 241, 241, 241, 241
    };static const ANTLR3_INT32 dfa44_T245[] =
    {
	154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 59, -1, -1, -1, -1, -1, 
	-1, 154, 154, 154, 154, 154, 154, -1, -1, -1, -1, -1, 185, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 154, 
	154, 154, 154, 154, 154
    };static const ANTLR3_INT32 dfa44_T246[] =
    {
	225
    };static const ANTLR3_INT32 dfa44_T247[] =
    {
	310
    };static const ANTLR3_INT32 dfa44_T248[] =
    {
	385
    };static const ANTLR3_INT32 dfa44_T249[] =
    {
	442
    };static const ANTLR3_INT32 dfa44_T250[] =
    {
	226
    };static const ANTLR3_INT32 dfa44_T251[] =
    {
	311
    };static const ANTLR3_INT32 dfa44_T252[] =
    {
	220, -1, -1, -1, -1, -1, -1, -1, 221
    };static const ANTLR3_INT32 dfa44_T253[] =
    {
	227
    };static const ANTLR3_INT32 dfa44_T254[] =
    {
	312
    };static const ANTLR3_INT32 dfa44_T255[] =
    {
	387
    };static const ANTLR3_INT32 dfa44_T256[] =
    {
	443
    };static const ANTLR3_INT32 dfa44_T257[] =
    {
	479
    };static const ANTLR3_INT32 dfa44_T258[] =
    {
	228
    };static const ANTLR3_INT32 dfa44_T259[] =
    {
	313
    };static const ANTLR3_INT32 dfa44_T260[] =
    {
	57, 57, 57, 57, 57, 57, 57, 57, 57, 57
    };static const ANTLR3_INT32 dfa44_T261[] =
    {
	229
    };static const ANTLR3_INT32 dfa44_T262[] =
    {
	314
    };static const ANTLR3_INT32 dfa44_T263[] =
    {
	389
    };static const ANTLR3_INT32 dfa44_T264[] =
    {
	230
    };static const ANTLR3_INT32 dfa44_T265[] =
    {
	315
    };static const ANTLR3_INT32 dfa44_T266[] =
    {
	390
    };static const ANTLR3_INT32 dfa44_T267[] =
    {
	445
    };static const ANTLR3_INT32 dfa44_T268[] =
    {
	142, -1, 234, 234, 234, 234, 234, 234, 234, 234, 234, 234, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 236, 235, 236, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 236, 235, 236
    };static const ANTLR3_INT32 dfa44_T269[] =
    {
	480
    };static const ANTLR3_INT32 dfa44_T270[] =
    {
	148, -1, 148, -1, -1, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 
	59, -1, -1, -1, -1, -1, -1, 59, 59, 59, 59, 59, 59, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 59, 59, 59, 59, 59, 59
    };static const ANTLR3_INT32 dfa44_T271[] =
    {
	254, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 255
    };static const ANTLR3_INT32 dfa44_T272[] =
    {
	148, -1, 148, -1, -1, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 
	59
    };static const ANTLR3_INT32 dfa44_T273[] =
    {
	392
    };static const ANTLR3_INT32 dfa44_T274[] =
    {
	318
    };static const ANTLR3_INT32 dfa44_T275[] =
    {
	393
    };static const ANTLR3_INT32 dfa44_T276[] =
    {
	233
    };static const ANTLR3_INT32 dfa44_T277[] =
    {
	319
    };static const ANTLR3_INT32 dfa44_T278[] =
    {
	171
    };static const ANTLR3_INT32 dfa44_T279[] =
    {
	257
    };static const ANTLR3_INT32 dfa44_T280[] =
    {
	338
    };static const ANTLR3_INT32 dfa44_T281[] =
    {
	137, 138
    };static const ANTLR3_INT32 dfa44_T282[] =
    {
	407, -1, 408
    };static const ANTLR3_INT32 dfa44_T283[] =
    {
	142, -1, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 59, -1, -1, 
	-1, -1, -1, -1, 59, 59, 59, 145, 143, 145, -1, -1, -1, -1, -1, 144, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 145, 143, 145
    };static const ANTLR3_INT32 dfa44_T284[] =
    {
	323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 59, -1, -1, -1, -1, -1, 
	-1, 59, 59, 59, 326, 59, 326, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, 59, 
	326, 59, 326
    };static const ANTLR3_INT32 dfa44_T285[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 87, 
	81, 81, 81, 81, 81, -1, 88, 89, -1, -1, -1, -1, -1, 90, -1, -1, 91, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T286[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 99, 
	81, 81, 81, 81, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 100, -1, 
	-1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T287[] =
    {
	241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 59, -1, -1, -1, -1, -1, 
	-1, 241, 241, 241, 241, 241, 241, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54, 54, 54, 54, -1, -1, -1, -1, 54, -1, 241, 241, 
	241, 241, 241, 241, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 
	54, 54, 54, 54, 54, 54, 54
    };static const ANTLR3_INT32 dfa44_T288[] =
    {
	81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 59, -1, -1, -1, -1, -1, -1, 81, 
	81, 81, 81, 81, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, 81, 81, 81, 81, 
	81
    };static const ANTLR3_INT32 dfa44_T289[] =
    {
	118, -1, -1, -1, 119, -1, -1, 120
    };static const ANTLR3_INT32 dfa44_T290[] =
    {
	316, -1, -1, -1, 317
    };static const ANTLR3_INT32 dfa44_T291[] =
    {
	175, -1, -1, -1, -1, -1, -1, -1, -1, -1, 176
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa44_transitions[] =
{
    dfa44_T143, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T86, dfa44_T260, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T74, dfa44_T_empty, dfa44_T58, dfa44_T57, 
    dfa44_T3, dfa44_T123, dfa44_T_empty, dfa44_T_empty, dfa44_T183, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T201, dfa44_T16, 
    dfa44_T285, dfa44_T197, dfa44_T9, dfa44_T286, dfa44_T10, dfa44_T13, 
    dfa44_T130, dfa44_T23, dfa44_T24, dfa44_T5, dfa44_T11, dfa44_T31, dfa44_T289, 
    dfa44_T33, dfa44_T96, dfa44_T209, dfa44_T176, dfa44_T117, dfa44_T120, 
    dfa44_T281, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T288, 
    dfa44_T_empty, dfa44_T56, dfa44_T283, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T186, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T84, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T102, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T140, 
    dfa44_T172, dfa44_T184, dfa44_T194, dfa44_T134, dfa44_T35, dfa44_T4, 
    dfa44_T7, dfa44_T42, dfa44_T46, dfa44_T51, dfa44_T0, dfa44_T22, dfa44_T54, 
    dfa44_T278, dfa44_T155, dfa44_T291, dfa44_T216, dfa44_T228, dfa44_T98, 
    dfa44_T105, dfa44_T109, dfa44_T112, dfa44_T113, dfa44_T245, dfa44_T121, 
    dfa44_T34, dfa44_T131, dfa44_T135, dfa44_T0, dfa44_T168, dfa44_T91, 
    dfa44_T0, dfa44_T156, dfa44_T158, dfa44_T159, dfa44_T161, dfa44_T165, 
    dfa44_T167, dfa44_T169, dfa44_T170, dfa44_T174, dfa44_T_empty, dfa44_T0, 
    dfa44_T233, dfa44_T163, dfa44_T166, dfa44_T208, dfa44_T218, dfa44_T222, 
    dfa44_T225, dfa44_T229, dfa44_T252, dfa44_T234, dfa44_T240, dfa44_T243, 
    dfa44_T246, dfa44_T250, dfa44_T253, dfa44_T258, dfa44_T261, dfa44_T264, 
    dfa44_T15, dfa44_T276, dfa44_T_empty, dfa44_T_empty, dfa44_T268, dfa44_T12, 
    dfa44_T14, dfa44_T_empty, dfa44_T32, dfa44_T95, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T287, 
    dfa44_T242, dfa44_T0, dfa44_T18, dfa44_T0, dfa44_T0, dfa44_T196, dfa44_T0, 
    dfa44_T_empty, dfa44_T0, dfa44_T36, dfa44_T38, dfa44_T43, dfa44_T47, 
    dfa44_T52, dfa44_T_empty, dfa44_T271, dfa44_T55, dfa44_T279, dfa44_T59, 
    dfa44_T64, dfa44_T69, dfa44_T71, dfa44_T75, dfa44_T78, dfa44_T244, dfa44_T97, 
    dfa44_T99, dfa44_T106, dfa44_T110, dfa44_T0, dfa44_T114, dfa44_T118, 
    dfa44_T122, dfa44_T124, dfa44_T125, dfa44_T132, dfa44_T137, dfa44_T_empty, 
    dfa44_T141, dfa44_T144, dfa44_T17, dfa44_T_empty, dfa44_T94, dfa44_T_empty, 
    dfa44_T157, dfa44_T0, dfa44_T160, dfa44_T162, dfa44_T0, dfa44_T0, dfa44_T0, 
    dfa44_T171, dfa44_T175, dfa44_T_empty, dfa44_T181, dfa44_T_empty, dfa44_T164, 
    dfa44_T189, dfa44_T199, dfa44_T202, dfa44_T210, dfa44_T217, dfa44_T219, 
    dfa44_T223, dfa44_T226, dfa44_T0, dfa44_T230, dfa44_T0, dfa44_T235, 
    dfa44_T241, dfa44_T0, dfa44_T247, dfa44_T251, dfa44_T254, dfa44_T259, 
    dfa44_T262, dfa44_T265, dfa44_T290, dfa44_T274, dfa44_T277, dfa44_T147, 
    dfa44_T270, dfa44_T32, dfa44_T20, dfa44_T284, dfa44_T6, dfa44_T_empty, 
    dfa44_T74, dfa44_T_empty, dfa44_T19, dfa44_T_empty, dfa44_T_empty, dfa44_T198, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T37, dfa44_T39, dfa44_T44, dfa44_T48, 
    dfa44_T53, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T280, dfa44_T60, dfa44_T65, 
    dfa44_T70, dfa44_T72, dfa44_T76, dfa44_T79, dfa44_T2, dfa44_T90, dfa44_T0, 
    dfa44_T100, dfa44_T107, dfa44_T0, dfa44_T_empty, dfa44_T115, dfa44_T119, 
    dfa44_T0, dfa44_T0, dfa44_T126, dfa44_T133, dfa44_T138, dfa44_T142, 
    dfa44_T145, dfa44_T0, dfa44_T77, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T_empty, 
    dfa44_T0, dfa44_T0, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T0, 
    dfa44_T177, dfa44_T182, dfa44_T185, dfa44_T187, dfa44_T190, dfa44_T200, 
    dfa44_T203, dfa44_T211, dfa44_T0, dfa44_T220, dfa44_T224, dfa44_T227, 
    dfa44_T_empty, dfa44_T231, dfa44_T_empty, dfa44_T236, dfa44_T0, dfa44_T_empty, 
    dfa44_T248, dfa44_T0, dfa44_T255, dfa44_T0, dfa44_T263, dfa44_T266, 
    dfa44_T0, dfa44_T273, dfa44_T275, dfa44_T0, dfa44_T173, dfa44_T272, 
    dfa44_T74, dfa44_T74, dfa44_T146, dfa44_T_empty, dfa44_T74, dfa44_T21, 
    dfa44_T0, dfa44_T111, dfa44_T0, dfa44_T40, dfa44_T45, dfa44_T49, dfa44_T0, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T282, dfa44_T61, 
    dfa44_T66, dfa44_T0, dfa44_T73, dfa44_T0, dfa44_T80, dfa44_T83, dfa44_T87, 
    dfa44_T92, dfa44_T_empty, dfa44_T101, dfa44_T108, dfa44_T_empty, dfa44_T116, 
    dfa44_T0, dfa44_T_empty, dfa44_T_empty, dfa44_T127, dfa44_T0, dfa44_T139, 
    dfa44_T0, dfa44_T0, dfa44_T_empty, dfa44_T148, dfa44_T151, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T178, dfa44_T0, dfa44_T0, dfa44_T188, dfa44_T191, dfa44_T0, dfa44_T204, 
    dfa44_T212, dfa44_T_empty, dfa44_T221, dfa44_T0, dfa44_T0, dfa44_T232, 
    dfa44_T237, dfa44_T_empty, dfa44_T249, dfa44_T_empty, dfa44_T256, dfa44_T_empty, 
    dfa44_T0, dfa44_T267, dfa44_T_empty, dfa44_T0, dfa44_T0, dfa44_T_empty, 
    dfa44_T152, dfa44_T150, dfa44_T136, dfa44_T8, dfa44_T_empty, dfa44_T25, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T41, dfa44_T0, dfa44_T50, dfa44_T_empty, 
    dfa44_T0, dfa44_T0, dfa44_T62, dfa44_T67, dfa44_T_empty, dfa44_T0, dfa44_T_empty, 
    dfa44_T81, dfa44_T85, dfa44_T88, dfa44_T93, dfa44_T103, dfa44_T0, dfa44_T0, 
    dfa44_T_empty, dfa44_T128, dfa44_T_empty, dfa44_T0, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T149, dfa44_T153, dfa44_T179, dfa44_T_empty, dfa44_T_empty, dfa44_T0, 
    dfa44_T192, dfa44_T_empty, dfa44_T205, dfa44_T213, dfa44_T1, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T0, dfa44_T238, dfa44_T0, dfa44_T257, dfa44_T_empty, 
    dfa44_T269, dfa44_T_empty, dfa44_T_empty, dfa44_T152, dfa44_T26, dfa44_T0, 
    dfa44_T_empty, dfa44_T0, dfa44_T_empty, dfa44_T_empty, dfa44_T63, dfa44_T68, 
    dfa44_T_empty, dfa44_T82, dfa44_T0, dfa44_T89, dfa44_T0, dfa44_T104, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T129, dfa44_T_empty, dfa44_T0, dfa44_T154, 
    dfa44_T180, dfa44_T_empty, dfa44_T193, dfa44_T206, dfa44_T214, dfa44_T0, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T239, dfa44_T_empty, dfa44_T0, dfa44_T0, 
    dfa44_T27, dfa44_T_empty, dfa44_T_empty, dfa44_T0, dfa44_T0, dfa44_T0, 
    dfa44_T_empty, dfa44_T0, dfa44_T_empty, dfa44_T0, dfa44_T0, dfa44_T_empty, 
    dfa44_T0, dfa44_T0, dfa44_T195, dfa44_T207, dfa44_T215, dfa44_T_empty, 
    dfa44_T0, dfa44_T_empty, dfa44_T_empty, dfa44_T28, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, 
    dfa44_T_empty, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T_empty, dfa44_T29, 
    dfa44_T_empty, dfa44_T_empty, dfa44_T_empty, dfa44_T30, dfa44_T0, dfa44_T_empty	
};


/* Declare tracking structure for Cyclic DFA 44
 */
static
ANTLR3_CYCLIC_DFA cdfa44
    =	{
	    44,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | T__149 | T__150 | T__151 | T__152 | T__153 | T__154 | T__155 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_ARRAY_CONCAT | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECLTYPE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa44_eot,	    /* EOT table			    */
	    dfa44_eof,	    /* EOF table			    */
	    dfa44_min,	    /* Minimum tokens for each state    */
	    dfa44_max,	    /* Maximum tokens for each state    */
	    dfa44_accept,	/* Accept table			    */
	    dfa44_special,	/* Special transition states	    */
	    dfa44_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 44
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:8: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__122
 *
 * Looks to match the characters the constitute the token T__122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__122(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__122;
       
    
    // IQL.g:7:8: ( ';' )
    // IQL.g:7:10: ';'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__122Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__122Ex; /* Prevent compiler warnings */
    ruleT__122Ex: ;

}
// $ANTLR end T__122

//   Comes from: 8:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__123
 *
 * Looks to match the characters the constitute the token T__123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__123(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__123;
       
    
    // IQL.g:8:8: ( '=' )
    // IQL.g:8:10: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__123Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__123Ex; /* Prevent compiler warnings */
    ruleT__123Ex: ;

}
// $ANTLR end T__123

//   Comes from: 9:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__124
 *
 * Looks to match the characters the constitute the token T__124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__124(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__124;
       
    
    // IQL.g:9:8: ( '[' )
    // IQL.g:9:10: '['
    {
        MATCHC('['); 
        if  (HASEXCEPTION())
        {
            goto ruleT__124Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__124Ex; /* Prevent compiler warnings */
    ruleT__124Ex: ;

}
// $ANTLR end T__124

//   Comes from: 10:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__125
 *
 * Looks to match the characters the constitute the token T__125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__125(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__125;
       
    
    // IQL.g:10:8: ( ']' )
    // IQL.g:10:10: ']'
    {
        MATCHC(']'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__125Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__125Ex; /* Prevent compiler warnings */
    ruleT__125Ex: ;

}
// $ANTLR end T__125

//   Comes from: 11:8: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__126
 *
 * Looks to match the characters the constitute the token T__126
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__126(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__126;
       
    
    // IQL.g:11:8: ( ',' )
    // IQL.g:11:10: ','
    {
        MATCHC(','); 
        if  (HASEXCEPTION())
        {
            goto ruleT__126Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__126Ex; /* Prevent compiler warnings */
    ruleT__126Ex: ;

}
// $ANTLR end T__126

//   Comes from: 12:8: ( '->' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__127
 *
 * Looks to match the characters the constitute the token T__127
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__127(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__127;
       
    
    // IQL.g:12:8: ( '->' )
    // IQL.g:12:10: '->'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleT__127Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__127Ex; /* Prevent compiler warnings */
    ruleT__127Ex: ;

}
// $ANTLR end T__127

//   Comes from: 13:8: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__128
 *
 * Looks to match the characters the constitute the token T__128
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__128(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__128;
       
    
    // IQL.g:13:8: ( '.' )
    // IQL.g:13:10: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__128Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__128Ex; /* Prevent compiler warnings */
    ruleT__128Ex: ;

}
// $ANTLR end T__128

//   Comes from: 14:8: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__129
 *
 * Looks to match the characters the constitute the token T__129
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__129(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__129;
       
    
    // IQL.g:14:8: ( '*' )
    // IQL.g:14:10: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__129Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__129Ex; /* Prevent compiler warnings */
    ruleT__129Ex: ;

}
// $ANTLR end T__129

//   Comes from: 15:8: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__130
 *
 * Looks to match the characters the constitute the token T__130
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__130(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__130;
       
    
    // IQL.g:15:8: ( '(' )
    // IQL.g:15:10: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__130Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__130Ex; /* Prevent compiler warnings */
    ruleT__130Ex: ;

}
// $ANTLR end T__130

//   Comes from: 16:8: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__131
 *
 * Looks to match the characters the constitute the token T__131
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__131(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__131;
       
    
    // IQL.g:16:8: ( ')' )
    // IQL.g:16:10: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__131Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__131Ex; /* Prevent compiler warnings */
    ruleT__131Ex: ;

}
// $ANTLR end T__131

//   Comes from: 17:8: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__132
 *
 * Looks to match the characters the constitute the token T__132
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__132(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__132;
       
    
    // IQL.g:17:8: ( '?' )
    // IQL.g:17:10: '?'
    {
        MATCHC('?'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__132Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__132Ex; /* Prevent compiler warnings */
    ruleT__132Ex: ;

}
// $ANTLR end T__132

//   Comes from: 18:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__133
 *
 * Looks to match the characters the constitute the token T__133
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__133(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__133;
       
    
    // IQL.g:18:8: ( ':' )
    // IQL.g:18:10: ':'
    {
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__133Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__133Ex; /* Prevent compiler warnings */
    ruleT__133Ex: ;

}
// $ANTLR end T__133

//   Comes from: 19:8: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__134
 *
 * Looks to match the characters the constitute the token T__134
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__134(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__134;
       
    
    // IQL.g:19:8: ( '^' )
    // IQL.g:19:10: '^'
    {
        MATCHC('^'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__134Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__134Ex; /* Prevent compiler warnings */
    ruleT__134Ex: ;

}
// $ANTLR end T__134

//   Comes from: 20:8: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__135
 *
 * Looks to match the characters the constitute the token T__135
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__135(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__135;
       
    
    // IQL.g:20:8: ( '|' )
    // IQL.g:20:10: '|'
    {
        MATCHC('|'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__135Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__135Ex; /* Prevent compiler warnings */
    ruleT__135Ex: ;

}
// $ANTLR end T__135

//   Comes from: 21:8: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__136
 *
 * Looks to match the characters the constitute the token T__136
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__136(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__136;
       
    
    // IQL.g:21:8: ( '&' )
    // IQL.g:21:10: '&'
    {
        MATCHC('&'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__136Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__136Ex; /* Prevent compiler warnings */
    ruleT__136Ex: ;

}
// $ANTLR end T__136

//   Comes from: 22:8: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__137
 *
 * Looks to match the characters the constitute the token T__137
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__137(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__137;
       
    
    // IQL.g:22:8: ( '>' )
    // IQL.g:22:10: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__137Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__137Ex; /* Prevent compiler warnings */
    ruleT__137Ex: ;

}
// $ANTLR end T__137

//   Comes from: 23:8: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__138
 *
 * Looks to match the characters the constitute the token T__138
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__138(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__138;
       
    
    // IQL.g:23:8: ( '<' )
    // IQL.g:23:10: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__138Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__138Ex; /* Prevent compiler warnings */
    ruleT__138Ex: ;

}
// $ANTLR end T__138

//   Comes from: 24:8: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__139
 *
 * Looks to match the characters the constitute the token T__139
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__139(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__139;
       
    
    // IQL.g:24:8: ( '>=' )
    // IQL.g:24:10: '>='
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleT__139Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__139Ex; /* Prevent compiler warnings */
    ruleT__139Ex: ;

}
// $ANTLR end T__139

//   Comes from: 25:8: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__140
 *
 * Looks to match the characters the constitute the token T__140
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__140(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__140;
       
    
    // IQL.g:25:8: ( '<=' )
    // IQL.g:25:10: '<='
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleT__140Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__140Ex; /* Prevent compiler warnings */
    ruleT__140Ex: ;

}
// $ANTLR end T__140

//   Comes from: 26:8: ( '<>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__141
 *
 * Looks to match the characters the constitute the token T__141
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__141(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__141;
       
    
    // IQL.g:26:8: ( '<>' )
    // IQL.g:26:10: '<>'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleT__141Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__141Ex; /* Prevent compiler warnings */
    ruleT__141Ex: ;

}
// $ANTLR end T__141

//   Comes from: 27:8: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__142
 *
 * Looks to match the characters the constitute the token T__142
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__142(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__142;
       
    
    // IQL.g:27:8: ( '!=' )
    // IQL.g:27:10: '!='
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleT__142Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__142Ex; /* Prevent compiler warnings */
    ruleT__142Ex: ;

}
// $ANTLR end T__142

//   Comes from: 28:8: ( '>>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__143
 *
 * Looks to match the characters the constitute the token T__143
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__143(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__143;
       
    
    // IQL.g:28:8: ( '>>' )
    // IQL.g:28:10: '>>'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleT__143Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__143Ex; /* Prevent compiler warnings */
    ruleT__143Ex: ;

}
// $ANTLR end T__143

//   Comes from: 29:8: ( '>>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__144
 *
 * Looks to match the characters the constitute the token T__144
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__144(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__144;
       
    
    // IQL.g:29:8: ( '>>=' )
    // IQL.g:29:10: '>>='
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleT__144Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__144Ex; /* Prevent compiler warnings */
    ruleT__144Ex: ;

}
// $ANTLR end T__144

//   Comes from: 30:8: ( '<<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__145
 *
 * Looks to match the characters the constitute the token T__145
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__145(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__145;
       
    
    // IQL.g:30:8: ( '<<' )
    // IQL.g:30:10: '<<'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleT__145Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__145Ex; /* Prevent compiler warnings */
    ruleT__145Ex: ;

}
// $ANTLR end T__145

//   Comes from: 31:8: ( '<<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__146
 *
 * Looks to match the characters the constitute the token T__146
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__146(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__146;
       
    
    // IQL.g:31:8: ( '<<=' )
    // IQL.g:31:10: '<<='
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleT__146Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__146Ex; /* Prevent compiler warnings */
    ruleT__146Ex: ;

}
// $ANTLR end T__146

//   Comes from: 32:8: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__147
 *
 * Looks to match the characters the constitute the token T__147
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__147(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__147;
       
    
    // IQL.g:32:8: ( '&&' )
    // IQL.g:32:10: '&&'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleT__147Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__147Ex; /* Prevent compiler warnings */
    ruleT__147Ex: ;

}
// $ANTLR end T__147

//   Comes from: 33:8: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__148
 *
 * Looks to match the characters the constitute the token T__148
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__148(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__148;
       
    
    // IQL.g:33:8: ( '+' )
    // IQL.g:33:10: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__148Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__148Ex; /* Prevent compiler warnings */
    ruleT__148Ex: ;

}
// $ANTLR end T__148

//   Comes from: 34:8: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__149
 *
 * Looks to match the characters the constitute the token T__149
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__149(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__149;
       
    
    // IQL.g:34:8: ( '-' )
    // IQL.g:34:10: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__149Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__149Ex; /* Prevent compiler warnings */
    ruleT__149Ex: ;

}
// $ANTLR end T__149

//   Comes from: 35:8: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__150
 *
 * Looks to match the characters the constitute the token T__150
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__150(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__150;
       
    
    // IQL.g:35:8: ( '||' )
    // IQL.g:35:10: '||'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleT__150Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__150Ex; /* Prevent compiler warnings */
    ruleT__150Ex: ;

}
// $ANTLR end T__150

//   Comes from: 36:8: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__151
 *
 * Looks to match the characters the constitute the token T__151
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__151(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__151;
       
    
    // IQL.g:36:8: ( '/' )
    // IQL.g:36:10: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__151Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__151Ex; /* Prevent compiler warnings */
    ruleT__151Ex: ;

}
// $ANTLR end T__151

//   Comes from: 37:8: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__152
 *
 * Looks to match the characters the constitute the token T__152
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__152(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__152;
       
    
    // IQL.g:37:8: ( '%' )
    // IQL.g:37:10: '%'
    {
        MATCHC('%'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__152Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__152Ex; /* Prevent compiler warnings */
    ruleT__152Ex: ;

}
// $ANTLR end T__152

//   Comes from: 38:8: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__153
 *
 * Looks to match the characters the constitute the token T__153
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__153(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__153;
       
    
    // IQL.g:38:8: ( '~' )
    // IQL.g:38:10: '~'
    {
        MATCHC('~'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__153Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__153Ex; /* Prevent compiler warnings */
    ruleT__153Ex: ;

}
// $ANTLR end T__153

//   Comes from: 39:8: ( '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__154
 *
 * Looks to match the characters the constitute the token T__154
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__154(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__154;
       
    
    // IQL.g:39:8: ( '#' )
    // IQL.g:39:10: '#'
    {
        MATCHC('#'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__154Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__154Ex; /* Prevent compiler warnings */
    ruleT__154Ex: ;

}
// $ANTLR end T__154

//   Comes from: 40:8: ( '$' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__155
 *
 * Looks to match the characters the constitute the token T__155
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__155(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__155;
       
    
    // IQL.g:40:8: ( '$' )
    // IQL.g:40:10: '$'
    {
        MATCHC('$'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__155Ex;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__155Ex; /* Prevent compiler warnings */
    ruleT__155Ex: ;

}
// $ANTLR end T__155

//   Comes from: 543:8: ( 'ADD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ADD
 *
 * Looks to match the characters the constitute the token TK_ADD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ADD(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ADD;
       
    
    // IQL.g:543:8: ( 'ADD' )
    // IQL.g:543:10: 'ADD'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ADDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ADDEx; /* Prevent compiler warnings */
    ruleTK_ADDEx: ;

}
// $ANTLR end TK_ADD

//   Comes from: 544:8: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALL
 *
 * Looks to match the characters the constitute the token TK_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALL;
       
    
    // IQL.g:544:8: ( 'ALL' )
    // IQL.g:544:10: 'ALL'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALLEx; /* Prevent compiler warnings */
    ruleTK_ALLEx: ;

}
// $ANTLR end TK_ALL

//   Comes from: 545:10: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALTER
 *
 * Looks to match the characters the constitute the token TK_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALTER;
       
    
    // IQL.g:545:10: ( 'ALTER' )
    // IQL.g:545:12: 'ALTER'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALTEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALTEREx; /* Prevent compiler warnings */
    ruleTK_ALTEREx: ;

}
// $ANTLR end TK_ALTER

//   Comes from: 546:8: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AND
 *
 * Looks to match the characters the constitute the token TK_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AND(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AND;
       
    
    // IQL.g:546:8: ( 'AND' )
    // IQL.g:546:10: 'AND'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANDEx; /* Prevent compiler warnings */
    ruleTK_ANDEx: ;

}
// $ANTLR end TK_AND

//   Comes from: 547:8: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ANY
 *
 * Looks to match the characters the constitute the token TK_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ANY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ANY;
       
    
    // IQL.g:547:8: ( 'ANY' )
    // IQL.g:547:10: 'ANY'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANYEx; /* Prevent compiler warnings */
    ruleTK_ANYEx: ;

}
// $ANTLR end TK_ANY

//   Comes from: 548:10: ( 'ARRAY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ARRAY
 *
 * Looks to match the characters the constitute the token TK_ARRAY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ARRAY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ARRAY;
       
    
    // IQL.g:548:10: ( 'ARRAY' )
    // IQL.g:548:12: 'ARRAY'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ARRAYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ARRAYEx; /* Prevent compiler warnings */
    ruleTK_ARRAYEx: ;

}
// $ANTLR end TK_ARRAY

//   Comes from: 549:17: ( 'ARRAY_CONCAT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ARRAY_CONCAT
 *
 * Looks to match the characters the constitute the token TK_ARRAY_CONCAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ARRAY_CONCAT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ARRAY_CONCAT;
       
    
    // IQL.g:549:17: ( 'ARRAY_CONCAT' )
    // IQL.g:549:19: 'ARRAY_CONCAT'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ARRAY_CONCATEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ARRAY_CONCATEx; /* Prevent compiler warnings */
    ruleTK_ARRAY_CONCATEx: ;

}
// $ANTLR end TK_ARRAY_CONCAT

//   Comes from: 550:7: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AS
 *
 * Looks to match the characters the constitute the token TK_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AS;
       
    
    // IQL.g:550:7: ( 'AS' )
    // IQL.g:550:9: 'AS'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASEx; /* Prevent compiler warnings */
    ruleTK_ASEx: ;

}
// $ANTLR end TK_AS

//   Comes from: 551:8: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ASC
 *
 * Looks to match the characters the constitute the token TK_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ASC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ASC;
       
    
    // IQL.g:551:8: ( 'ASC' )
    // IQL.g:551:10: 'ASC'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASCEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASCEx; /* Prevent compiler warnings */
    ruleTK_ASCEx: ;

}
// $ANTLR end TK_ASC

//   Comes from: 552:8: ( 'AVG' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AVG
 *
 * Looks to match the characters the constitute the token TK_AVG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AVG(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AVG;
       
    
    // IQL.g:552:8: ( 'AVG' )
    // IQL.g:552:10: 'AVG'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_AVGEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_AVGEx; /* Prevent compiler warnings */
    ruleTK_AVGEx: ;

}
// $ANTLR end TK_AVG

//   Comes from: 553:10: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BEGIN
 *
 * Looks to match the characters the constitute the token TK_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BEGIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BEGIN;
       
    
    // IQL.g:553:10: ( 'BEGIN' )
    // IQL.g:553:12: 'BEGIN'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BEGINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BEGINEx; /* Prevent compiler warnings */
    ruleTK_BEGINEx: ;

}
// $ANTLR end TK_BEGIN

//   Comes from: 554:12: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BETWEEN
 *
 * Looks to match the characters the constitute the token TK_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BETWEEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BETWEEN;
       
    
    // IQL.g:554:12: ( 'BETWEEN' )
    // IQL.g:554:14: 'BETWEEN'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BETWEENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BETWEENEx; /* Prevent compiler warnings */
    ruleTK_BETWEENEx: ;

}
// $ANTLR end TK_BETWEEN

//   Comes from: 555:11: ( 'BIGINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BIGINT
 *
 * Looks to match the characters the constitute the token TK_BIGINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BIGINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BIGINT;
       
    
    // IQL.g:555:11: ( 'BIGINT' )
    // IQL.g:555:13: 'BIGINT'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BIGINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BIGINTEx; /* Prevent compiler warnings */
    ruleTK_BIGINTEx: ;

}
// $ANTLR end TK_BIGINT

//   Comes from: 556:12: ( 'BOOLEAN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BOOLEAN
 *
 * Looks to match the characters the constitute the token TK_BOOLEAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BOOLEAN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BOOLEAN;
       
    
    // IQL.g:556:12: ( 'BOOLEAN' )
    // IQL.g:556:14: 'BOOLEAN'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BOOLEANEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BOOLEANEx; /* Prevent compiler warnings */
    ruleTK_BOOLEANEx: ;

}
// $ANTLR end TK_BOOLEAN

//   Comes from: 557:10: ( 'BREAK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BREAK
 *
 * Looks to match the characters the constitute the token TK_BREAK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BREAK(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BREAK;
       
    
    // IQL.g:557:10: ( 'BREAK' )
    // IQL.g:557:12: 'BREAK'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BREAKEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BREAKEx; /* Prevent compiler warnings */
    ruleTK_BREAKEx: ;

}
// $ANTLR end TK_BREAK

//   Comes from: 558:7: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BY
 *
 * Looks to match the characters the constitute the token TK_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BY;
       
    
    // IQL.g:558:7: ( 'BY' )
    // IQL.g:558:9: 'BY'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BYEx; /* Prevent compiler warnings */
    ruleTK_BYEx: ;

}
// $ANTLR end TK_BY

//   Comes from: 559:9: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CASE
 *
 * Looks to match the characters the constitute the token TK_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CASE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CASE;
       
    
    // IQL.g:559:9: ( 'CASE' )
    // IQL.g:559:11: 'CASE'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASEEx; /* Prevent compiler warnings */
    ruleTK_CASEEx: ;

}
// $ANTLR end TK_CASE

//   Comes from: 560:9: ( 'CAST' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CAST
 *
 * Looks to match the characters the constitute the token TK_CAST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CAST(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CAST;
       
    
    // IQL.g:560:9: ( 'CAST' )
    // IQL.g:560:11: 'CAST'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASTEx; /* Prevent compiler warnings */
    ruleTK_CASTEx: ;

}
// $ANTLR end TK_CAST

//   Comes from: 561:9: ( 'CHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CHAR
 *
 * Looks to match the characters the constitute the token TK_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CHAR;
       
    
    // IQL.g:561:9: ( 'CHAR' )
    // IQL.g:561:11: 'CHAR'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CHAREx; /* Prevent compiler warnings */
    ruleTK_CHAREx: ;

}
// $ANTLR end TK_CHAR

//   Comes from: 562:11: ( 'CIDRV4' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CIDRV4
 *
 * Looks to match the characters the constitute the token TK_CIDRV4
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CIDRV4(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CIDRV4;
       
    
    // IQL.g:562:11: ( 'CIDRV4' )
    // IQL.g:562:13: 'CIDRV4'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CIDRV4Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CIDRV4Ex; /* Prevent compiler warnings */
    ruleTK_CIDRV4Ex: ;

}
// $ANTLR end TK_CIDRV4

//   Comes from: 563:11: ( 'CIDRV6' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CIDRV6
 *
 * Looks to match the characters the constitute the token TK_CIDRV6
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CIDRV6(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CIDRV6;
       
    
    // IQL.g:563:11: ( 'CIDRV6' )
    // IQL.g:563:13: 'CIDRV6'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CIDRV6Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CIDRV6Ex; /* Prevent compiler warnings */
    ruleTK_CIDRV6Ex: ;

}
// $ANTLR end TK_CIDRV6

//   Comes from: 564:13: ( 'COALESCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COALESCE
 *
 * Looks to match the characters the constitute the token TK_COALESCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COALESCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COALESCE;
       
    
    // IQL.g:564:13: ( 'COALESCE' )
    // IQL.g:564:15: 'COALESCE'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COALESCEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COALESCEEx; /* Prevent compiler warnings */
    ruleTK_COALESCEEx: ;

}
// $ANTLR end TK_COALESCE

//   Comes from: 565:13: ( 'CONTINUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CONTINUE
 *
 * Looks to match the characters the constitute the token TK_CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CONTINUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CONTINUE;
       
    
    // IQL.g:565:13: ( 'CONTINUE' )
    // IQL.g:565:15: 'CONTINUE'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CONTINUEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CONTINUEEx; /* Prevent compiler warnings */
    ruleTK_CONTINUEEx: ;

}
// $ANTLR end TK_CONTINUE

//   Comes from: 566:10: ( 'COUNT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COUNT
 *
 * Looks to match the characters the constitute the token TK_COUNT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COUNT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COUNT;
       
    
    // IQL.g:566:10: ( 'COUNT' )
    // IQL.g:566:12: 'COUNT'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COUNTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COUNTEx; /* Prevent compiler warnings */
    ruleTK_COUNTEx: ;

}
// $ANTLR end TK_COUNT

//   Comes from: 567:11: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CREATE
 *
 * Looks to match the characters the constitute the token TK_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CREATE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CREATE;
       
    
    // IQL.g:567:11: ( 'CREATE' )
    // IQL.g:567:13: 'CREATE'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CREATEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CREATEEx; /* Prevent compiler warnings */
    ruleTK_CREATEEx: ;

}
// $ANTLR end TK_CREATE

//   Comes from: 568:10: ( 'CROSS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CROSS
 *
 * Looks to match the characters the constitute the token TK_CROSS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CROSS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CROSS;
       
    
    // IQL.g:568:10: ( 'CROSS' )
    // IQL.g:568:12: 'CROSS'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CROSSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CROSSEx; /* Prevent compiler warnings */
    ruleTK_CROSSEx: ;

}
// $ANTLR end TK_CROSS

//   Comes from: 569:13: ( 'DATETIME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DATETIME
 *
 * Looks to match the characters the constitute the token TK_DATETIME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DATETIME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DATETIME;
       
    
    // IQL.g:569:13: ( 'DATETIME' )
    // IQL.g:569:15: 'DATETIME'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DATETIMEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DATETIMEEx; /* Prevent compiler warnings */
    ruleTK_DATETIMEEx: ;

}
// $ANTLR end TK_DATETIME

//   Comes from: 570:12: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECLARE
 *
 * Looks to match the characters the constitute the token TK_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECLARE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECLARE;
       
    
    // IQL.g:570:12: ( 'DECLARE' )
    // IQL.g:570:14: 'DECLARE'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECLAREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECLAREEx; /* Prevent compiler warnings */
    ruleTK_DECLAREEx: ;

}
// $ANTLR end TK_DECLARE

//   Comes from: 571:13: ( 'DECLTYPE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECLTYPE
 *
 * Looks to match the characters the constitute the token TK_DECLTYPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECLTYPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECLTYPE;
       
    
    // IQL.g:571:13: ( 'DECLTYPE' )
    // IQL.g:571:15: 'DECLTYPE'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECLTYPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECLTYPEEx; /* Prevent compiler warnings */
    ruleTK_DECLTYPEEx: ;

}
// $ANTLR end TK_DECLTYPE

//   Comes from: 572:12: ( 'DECIMAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECIMAL
 *
 * Looks to match the characters the constitute the token TK_DECIMAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECIMAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECIMAL;
       
    
    // IQL.g:572:12: ( 'DECIMAL' )
    // IQL.g:572:14: 'DECIMAL'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECIMALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECIMALEx; /* Prevent compiler warnings */
    ruleTK_DECIMALEx: ;

}
// $ANTLR end TK_DECIMAL

//   Comes from: 573:9: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DESC
 *
 * Looks to match the characters the constitute the token TK_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DESC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DESC;
       
    
    // IQL.g:573:9: ( 'DESC' )
    // IQL.g:573:11: 'DESC'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DESCEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DESCEx; /* Prevent compiler warnings */
    ruleTK_DESCEx: ;

}
// $ANTLR end TK_DESC

//   Comes from: 574:13: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DISTINCT
 *
 * Looks to match the characters the constitute the token TK_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DISTINCT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DISTINCT;
       
    
    // IQL.g:574:13: ( 'DISTINCT' )
    // IQL.g:574:15: 'DISTINCT'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DISTINCTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DISTINCTEx; /* Prevent compiler warnings */
    ruleTK_DISTINCTEx: ;

}
// $ANTLR end TK_DISTINCT

//   Comes from: 575:11: ( 'DOUBLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DOUBLE
 *
 * Looks to match the characters the constitute the token TK_DOUBLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DOUBLE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DOUBLE;
       
    
    // IQL.g:575:11: ( 'DOUBLE' )
    // IQL.g:575:13: 'DOUBLE'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DOUBLEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DOUBLEEx; /* Prevent compiler warnings */
    ruleTK_DOUBLEEx: ;

}
// $ANTLR end TK_DOUBLE

//   Comes from: 576:9: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ELSE
 *
 * Looks to match the characters the constitute the token TK_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ELSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ELSE;
       
    
    // IQL.g:576:9: ( 'ELSE' )
    // IQL.g:576:11: 'ELSE'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ELSEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ELSEEx; /* Prevent compiler warnings */
    ruleTK_ELSEEx: ;

}
// $ANTLR end TK_ELSE

//   Comes from: 577:8: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_END
 *
 * Looks to match the characters the constitute the token TK_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_END(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_END;
       
    
    // IQL.g:577:8: ( 'END' )
    // IQL.g:577:10: 'END'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ENDEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ENDEx; /* Prevent compiler warnings */
    ruleTK_ENDEx: ;

}
// $ANTLR end TK_END

//   Comes from: 578:11: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_EXISTS
 *
 * Looks to match the characters the constitute the token TK_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_EXISTS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_EXISTS;
       
    
    // IQL.g:578:11: ( 'EXISTS' )
    // IQL.g:578:13: 'EXISTS'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_EXISTSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_EXISTSEx; /* Prevent compiler warnings */
    ruleTK_EXISTSEx: ;

}
// $ANTLR end TK_EXISTS

//   Comes from: 579:10: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FALSE
 *
 * Looks to match the characters the constitute the token TK_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FALSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FALSE;
       
    
    // IQL.g:579:10: ( 'FALSE' )
    // IQL.g:579:12: 'FALSE'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FALSEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FALSEEx; /* Prevent compiler warnings */
    ruleTK_FALSEEx: ;

}
// $ANTLR end TK_FALSE

//   Comes from: 580:9: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FROM
 *
 * Looks to match the characters the constitute the token TK_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FROM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FROM;
       
    
    // IQL.g:580:9: ( 'FROM' )
    // IQL.g:580:11: 'FROM'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FROMEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FROMEx; /* Prevent compiler warnings */
    ruleTK_FROMEx: ;

}
// $ANTLR end TK_FROM

//   Comes from: 581:9: ( 'FULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FULL
 *
 * Looks to match the characters the constitute the token TK_FULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FULL;
       
    
    // IQL.g:581:9: ( 'FULL' )
    // IQL.g:581:11: 'FULL'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FULLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FULLEx; /* Prevent compiler warnings */
    ruleTK_FULLEx: ;

}
// $ANTLR end TK_FULL

//   Comes from: 582:13: ( 'FUNCTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FUNCTION
 *
 * Looks to match the characters the constitute the token TK_FUNCTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FUNCTION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FUNCTION;
       
    
    // IQL.g:582:13: ( 'FUNCTION' )
    // IQL.g:582:15: 'FUNCTION'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FUNCTIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FUNCTIONEx; /* Prevent compiler warnings */
    ruleTK_FUNCTIONEx: ;

}
// $ANTLR end TK_FUNCTION

//   Comes from: 583:10: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_GROUP
 *
 * Looks to match the characters the constitute the token TK_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_GROUP(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_GROUP;
       
    
    // IQL.g:583:10: ( 'GROUP' )
    // IQL.g:583:12: 'GROUP'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_GROUPEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_GROUPEx; /* Prevent compiler warnings */
    ruleTK_GROUPEx: ;

}
// $ANTLR end TK_GROUP

//   Comes from: 584:11: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_HAVING
 *
 * Looks to match the characters the constitute the token TK_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_HAVING(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_HAVING;
       
    
    // IQL.g:584:11: ( 'HAVING' )
    // IQL.g:584:13: 'HAVING'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_HAVINGEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_HAVINGEx; /* Prevent compiler warnings */
    ruleTK_HAVINGEx: ;

}
// $ANTLR end TK_HAVING

//   Comes from: 585:7: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IF
 *
 * Looks to match the characters the constitute the token TK_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IF(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IF;
       
    
    // IQL.g:585:7: ( 'IF' )
    // IQL.g:585:9: 'IF'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IFEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IFEx; /* Prevent compiler warnings */
    ruleTK_IFEx: ;

}
// $ANTLR end TK_IF

//   Comes from: 586:7: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IN
 *
 * Looks to match the characters the constitute the token TK_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IN;
       
    
    // IQL.g:586:7: ( 'IN' )
    // IQL.g:586:9: 'IN'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INEx; /* Prevent compiler warnings */
    ruleTK_INEx: ;

}
// $ANTLR end TK_IN

//   Comes from: 587:10: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INDEX
 *
 * Looks to match the characters the constitute the token TK_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INDEX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INDEX;
       
    
    // IQL.g:587:10: ( 'INDEX' )
    // IQL.g:587:12: 'INDEX'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INDEXEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INDEXEx; /* Prevent compiler warnings */
    ruleTK_INDEXEx: ;

}
// $ANTLR end TK_INDEX

//   Comes from: 588:10: ( 'INNER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INNER
 *
 * Looks to match the characters the constitute the token TK_INNER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INNER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INNER;
       
    
    // IQL.g:588:10: ( 'INNER' )
    // IQL.g:588:12: 'INNER'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INNEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INNEREx; /* Prevent compiler warnings */
    ruleTK_INNEREx: ;

}
// $ANTLR end TK_INNER

//   Comes from: 589:9: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTO
 *
 * Looks to match the characters the constitute the token TK_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTO(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTO;
       
    
    // IQL.g:589:9: ( 'INTO' )
    // IQL.g:589:11: 'INTO'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTOEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTOEx; /* Prevent compiler warnings */
    ruleTK_INTOEx: ;

}
// $ANTLR end TK_INTO

//   Comes from: 590:12: ( 'INTEGER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTEGER
 *
 * Looks to match the characters the constitute the token TK_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTEGER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTEGER;
       
    
    // IQL.g:590:12: ( 'INTEGER' )
    // IQL.g:590:14: 'INTEGER'
    {
        MATCHS(lit_59); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTEGEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTEGEREx; /* Prevent compiler warnings */
    ruleTK_INTEGEREx: ;

}
// $ANTLR end TK_INTEGER

//   Comes from: 591:13: ( 'INTERVAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTERVAL
 *
 * Looks to match the characters the constitute the token TK_INTERVAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTERVAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTERVAL;
       
    
    // IQL.g:591:13: ( 'INTERVAL' )
    // IQL.g:591:15: 'INTERVAL'
    {
        MATCHS(lit_60); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTERVALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTERVALEx; /* Prevent compiler warnings */
    ruleTK_INTERVALEx: ;

}
// $ANTLR end TK_INTERVAL

//   Comes from: 592:9: ( 'IPV4' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IPV4
 *
 * Looks to match the characters the constitute the token TK_IPV4
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IPV4(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IPV4;
       
    
    // IQL.g:592:9: ( 'IPV4' )
    // IQL.g:592:11: 'IPV4'
    {
        MATCHS(lit_61); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IPV4Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IPV4Ex; /* Prevent compiler warnings */
    ruleTK_IPV4Ex: ;

}
// $ANTLR end TK_IPV4

//   Comes from: 593:9: ( 'IPV6' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IPV6
 *
 * Looks to match the characters the constitute the token TK_IPV6
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IPV6(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IPV6;
       
    
    // IQL.g:593:9: ( 'IPV6' )
    // IQL.g:593:11: 'IPV6'
    {
        MATCHS(lit_62); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IPV6Ex;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IPV6Ex; /* Prevent compiler warnings */
    ruleTK_IPV6Ex: ;

}
// $ANTLR end TK_IPV6

//   Comes from: 594:7: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IS
 *
 * Looks to match the characters the constitute the token TK_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IS;
       
    
    // IQL.g:594:7: ( 'IS' )
    // IQL.g:594:9: 'IS'
    {
        MATCHS(lit_63); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ISEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ISEx; /* Prevent compiler warnings */
    ruleTK_ISEx: ;

}
// $ANTLR end TK_IS

//   Comes from: 595:9: ( 'JOIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_JOIN
 *
 * Looks to match the characters the constitute the token TK_JOIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_JOIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_JOIN;
       
    
    // IQL.g:595:9: ( 'JOIN' )
    // IQL.g:595:11: 'JOIN'
    {
        MATCHS(lit_64); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_JOINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_JOINEx; /* Prevent compiler warnings */
    ruleTK_JOINEx: ;

}
// $ANTLR end TK_JOIN

//   Comes from: 596:8: ( 'KEY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_KEY
 *
 * Looks to match the characters the constitute the token TK_KEY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_KEY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_KEY;
       
    
    // IQL.g:596:8: ( 'KEY' )
    // IQL.g:596:10: 'KEY'
    {
        MATCHS(lit_65); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_KEYEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_KEYEx; /* Prevent compiler warnings */
    ruleTK_KEYEx: ;

}
// $ANTLR end TK_KEY

//   Comes from: 597:9: ( 'LEFT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LEFT
 *
 * Looks to match the characters the constitute the token TK_LEFT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LEFT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LEFT;
       
    
    // IQL.g:597:9: ( 'LEFT' )
    // IQL.g:597:11: 'LEFT'
    {
        MATCHS(lit_66); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LEFTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LEFTEx; /* Prevent compiler warnings */
    ruleTK_LEFTEx: ;

}
// $ANTLR end TK_LEFT

//   Comes from: 598:9: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LIKE
 *
 * Looks to match the characters the constitute the token TK_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LIKE;
       
    
    // IQL.g:598:9: ( 'LIKE' )
    // IQL.g:598:11: 'LIKE'
    {
        MATCHS(lit_67); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LIKEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LIKEEx; /* Prevent compiler warnings */
    ruleTK_LIKEEx: ;

}
// $ANTLR end TK_LIKE

//   Comes from: 599:8: ( 'MAX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MAX
 *
 * Looks to match the characters the constitute the token TK_MAX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MAX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MAX;
       
    
    // IQL.g:599:8: ( 'MAX' )
    // IQL.g:599:10: 'MAX'
    {
        MATCHS(lit_68); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MAXEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MAXEx; /* Prevent compiler warnings */
    ruleTK_MAXEx: ;

}
// $ANTLR end TK_MAX

//   Comes from: 600:8: ( 'MIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MIN
 *
 * Looks to match the characters the constitute the token TK_MIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MIN;
       
    
    // IQL.g:600:8: ( 'MIN' )
    // IQL.g:600:10: 'MIN'
    {
        MATCHS(lit_69); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MINEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MINEx; /* Prevent compiler warnings */
    ruleTK_MINEx: ;

}
// $ANTLR end TK_MIN

//   Comes from: 601:8: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NOT
 *
 * Looks to match the characters the constitute the token TK_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NOT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NOT;
       
    
    // IQL.g:601:8: ( 'NOT' )
    // IQL.g:601:10: 'NOT'
    {
        MATCHS(lit_70); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NOTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NOTEx; /* Prevent compiler warnings */
    ruleTK_NOTEx: ;

}
// $ANTLR end TK_NOT

//   Comes from: 602:9: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NULL
 *
 * Looks to match the characters the constitute the token TK_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NULL;
       
    
    // IQL.g:602:9: ( 'NULL' )
    // IQL.g:602:11: 'NULL'
    {
        MATCHS(lit_71); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NULLEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NULLEx; /* Prevent compiler warnings */
    ruleTK_NULLEx: ;

}
// $ANTLR end TK_NULL

//   Comes from: 603:13: ( 'NVARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NVARCHAR
 *
 * Looks to match the characters the constitute the token TK_NVARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NVARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NVARCHAR;
       
    
    // IQL.g:603:13: ( 'NVARCHAR' )
    // IQL.g:603:15: 'NVARCHAR'
    {
        MATCHS(lit_72); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NVARCHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NVARCHAREx; /* Prevent compiler warnings */
    ruleTK_NVARCHAREx: ;

}
// $ANTLR end TK_NVARCHAR

//   Comes from: 604:7: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ON
 *
 * Looks to match the characters the constitute the token TK_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ON(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ON;
       
    
    // IQL.g:604:7: ( 'ON' )
    // IQL.g:604:9: 'ON'
    {
        MATCHS(lit_73); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ONEx; /* Prevent compiler warnings */
    ruleTK_ONEx: ;

}
// $ANTLR end TK_ON

//   Comes from: 605:7: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OR
 *
 * Looks to match the characters the constitute the token TK_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OR;
       
    
    // IQL.g:605:7: ( 'OR' )
    // IQL.g:605:9: 'OR'
    {
        MATCHS(lit_74); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OREx; /* Prevent compiler warnings */
    ruleTK_OREx: ;

}
// $ANTLR end TK_OR

//   Comes from: 606:10: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ORDER
 *
 * Looks to match the characters the constitute the token TK_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ORDER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ORDER;
       
    
    // IQL.g:606:10: ( 'ORDER' )
    // IQL.g:606:12: 'ORDER'
    {
        MATCHS(lit_75); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ORDEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ORDEREx; /* Prevent compiler warnings */
    ruleTK_ORDEREx: ;

}
// $ANTLR end TK_ORDER

//   Comes from: 607:10: ( 'OUTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTER
 *
 * Looks to match the characters the constitute the token TK_OUTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTER;
       
    
    // IQL.g:607:10: ( 'OUTER' )
    // IQL.g:607:12: 'OUTER'
    {
        MATCHS(lit_76); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTEREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTEREx; /* Prevent compiler warnings */
    ruleTK_OUTEREx: ;

}
// $ANTLR end TK_OUTER

//   Comes from: 608:11: ( 'OUTPUT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTPUT
 *
 * Looks to match the characters the constitute the token TK_OUTPUT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTPUT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTPUT;
       
    
    // IQL.g:608:11: ( 'OUTPUT' )
    // IQL.g:608:13: 'OUTPUT'
    {
        MATCHS(lit_77); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTPUTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTPUTEx; /* Prevent compiler warnings */
    ruleTK_OUTPUTEx: ;

}
// $ANTLR end TK_OUTPUT

//   Comes from: 609:14: ( 'PRECISION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRECISION
 *
 * Looks to match the characters the constitute the token TK_PRECISION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRECISION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRECISION;
       
    
    // IQL.g:609:14: ( 'PRECISION' )
    // IQL.g:609:16: 'PRECISION'
    {
        MATCHS(lit_78); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRECISIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRECISIONEx; /* Prevent compiler warnings */
    ruleTK_PRECISIONEx: ;

}
// $ANTLR end TK_PRECISION

//   Comes from: 610:10: ( 'PRINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRINT
 *
 * Looks to match the characters the constitute the token TK_PRINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRINT;
       
    
    // IQL.g:610:10: ( 'PRINT' )
    // IQL.g:610:12: 'PRINT'
    {
        MATCHS(lit_79); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRINTEx; /* Prevent compiler warnings */
    ruleTK_PRINTEx: ;

}
// $ANTLR end TK_PRINT

//   Comes from: 611:14: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PROCEDURE
 *
 * Looks to match the characters the constitute the token TK_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PROCEDURE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PROCEDURE;
       
    
    // IQL.g:611:14: ( 'PROCEDURE' )
    // IQL.g:611:16: 'PROCEDURE'
    {
        MATCHS(lit_80); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PROCEDUREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PROCEDUREEx; /* Prevent compiler warnings */
    ruleTK_PROCEDUREEx: ;

}
// $ANTLR end TK_PROCEDURE

//   Comes from: 612:14: ( 'RAISERROR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RAISERROR
 *
 * Looks to match the characters the constitute the token TK_RAISERROR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RAISERROR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RAISERROR;
       
    
    // IQL.g:612:14: ( 'RAISERROR' )
    // IQL.g:612:16: 'RAISERROR'
    {
        MATCHS(lit_81); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RAISERROREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RAISERROREx; /* Prevent compiler warnings */
    ruleTK_RAISERROREx: ;

}
// $ANTLR end TK_RAISERROR

//   Comes from: 613:9: ( 'REAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_REAL
 *
 * Looks to match the characters the constitute the token TK_REAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_REAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_REAL;
       
    
    // IQL.g:613:9: ( 'REAL' )
    // IQL.g:613:11: 'REAL'
    {
        MATCHS(lit_82); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_REALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_REALEx; /* Prevent compiler warnings */
    ruleTK_REALEx: ;

}
// $ANTLR end TK_REAL

//   Comes from: 614:11: ( 'RETURN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURN
 *
 * Looks to match the characters the constitute the token TK_RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURN;
       
    
    // IQL.g:614:11: ( 'RETURN' )
    // IQL.g:614:13: 'RETURN'
    {
        MATCHS(lit_83); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNEx; /* Prevent compiler warnings */
    ruleTK_RETURNEx: ;

}
// $ANTLR end TK_RETURN

//   Comes from: 615:12: ( 'RETURNS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURNS
 *
 * Looks to match the characters the constitute the token TK_RETURNS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURNS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURNS;
       
    
    // IQL.g:615:12: ( 'RETURNS' )
    // IQL.g:615:14: 'RETURNS'
    {
        MATCHS(lit_84); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNSEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNSEx; /* Prevent compiler warnings */
    ruleTK_RETURNSEx: ;

}
// $ANTLR end TK_RETURNS

//   Comes from: 616:10: ( 'RIGHT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RIGHT
 *
 * Looks to match the characters the constitute the token TK_RIGHT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RIGHT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RIGHT;
       
    
    // IQL.g:616:10: ( 'RIGHT' )
    // IQL.g:616:12: 'RIGHT'
    {
        MATCHS(lit_85); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RIGHTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RIGHTEx; /* Prevent compiler warnings */
    ruleTK_RIGHTEx: ;

}
// $ANTLR end TK_RIGHT

//   Comes from: 617:10: ( 'RLIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RLIKE
 *
 * Looks to match the characters the constitute the token TK_RLIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RLIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RLIKE;
       
    
    // IQL.g:617:10: ( 'RLIKE' )
    // IQL.g:617:12: 'RLIKE'
    {
        MATCHS(lit_86); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RLIKEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RLIKEEx; /* Prevent compiler warnings */
    ruleTK_RLIKEEx: ;

}
// $ANTLR end TK_RLIKE

//   Comes from: 618:8: ( 'ROW' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ROW
 *
 * Looks to match the characters the constitute the token TK_ROW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ROW(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ROW;
       
    
    // IQL.g:618:8: ( 'ROW' )
    // IQL.g:618:10: 'ROW'
    {
        MATCHS(lit_87); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ROWEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ROWEx; /* Prevent compiler warnings */
    ruleTK_ROWEx: ;

}
// $ANTLR end TK_ROW

//   Comes from: 619:11: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SELECT
 *
 * Looks to match the characters the constitute the token TK_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SELECT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SELECT;
       
    
    // IQL.g:619:11: ( 'SELECT' )
    // IQL.g:619:13: 'SELECT'
    {
        MATCHS(lit_88); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SELECTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SELECTEx; /* Prevent compiler warnings */
    ruleTK_SELECTEx: ;

}
// $ANTLR end TK_SELECT

//   Comes from: 620:8: ( 'SET' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SET
 *
 * Looks to match the characters the constitute the token TK_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SET(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SET;
       
    
    // IQL.g:620:8: ( 'SET' )
    // IQL.g:620:10: 'SET'
    {
        MATCHS(lit_89); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SETEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SETEx; /* Prevent compiler warnings */
    ruleTK_SETEx: ;

}
// $ANTLR end TK_SET

//   Comes from: 621:13: ( 'SMALLINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SMALLINT
 *
 * Looks to match the characters the constitute the token TK_SMALLINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SMALLINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SMALLINT;
       
    
    // IQL.g:621:13: ( 'SMALLINT' )
    // IQL.g:621:15: 'SMALLINT'
    {
        MATCHS(lit_90); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SMALLINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SMALLINTEx; /* Prevent compiler warnings */
    ruleTK_SMALLINTEx: ;

}
// $ANTLR end TK_SMALLINT

//   Comes from: 622:9: ( 'SOME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SOME
 *
 * Looks to match the characters the constitute the token TK_SOME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SOME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SOME;
       
    
    // IQL.g:622:9: ( 'SOME' )
    // IQL.g:622:11: 'SOME'
    {
        MATCHS(lit_91); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SOMEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SOMEEx; /* Prevent compiler warnings */
    ruleTK_SOMEEx: ;

}
// $ANTLR end TK_SOME

//   Comes from: 623:8: ( 'SUM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SUM
 *
 * Looks to match the characters the constitute the token TK_SUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SUM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SUM;
       
    
    // IQL.g:623:8: ( 'SUM' )
    // IQL.g:623:10: 'SUM'
    {
        MATCHS(lit_92); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SUMEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SUMEx; /* Prevent compiler warnings */
    ruleTK_SUMEx: ;

}
// $ANTLR end TK_SUM

//   Comes from: 624:11: ( 'SWITCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SWITCH
 *
 * Looks to match the characters the constitute the token TK_SWITCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SWITCH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SWITCH;
       
    
    // IQL.g:624:11: ( 'SWITCH' )
    // IQL.g:624:13: 'SWITCH'
    {
        MATCHS(lit_93); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SWITCHEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SWITCHEx; /* Prevent compiler warnings */
    ruleTK_SWITCHEx: ;

}
// $ANTLR end TK_SWITCH

//   Comes from: 625:9: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_THEN
 *
 * Looks to match the characters the constitute the token TK_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_THEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_THEN;
       
    
    // IQL.g:625:9: ( 'THEN' )
    // IQL.g:625:11: 'THEN'
    {
        MATCHS(lit_94); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_THENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_THENEx; /* Prevent compiler warnings */
    ruleTK_THENEx: ;

}
// $ANTLR end TK_THEN

//   Comes from: 626:12: ( 'TINYINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_TINYINT
 *
 * Looks to match the characters the constitute the token TK_TINYINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_TINYINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_TINYINT;
       
    
    // IQL.g:626:12: ( 'TINYINT' )
    // IQL.g:626:14: 'TINYINT'
    {
        MATCHS(lit_95); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_TINYINTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_TINYINTEx; /* Prevent compiler warnings */
    ruleTK_TINYINTEx: ;

}
// $ANTLR end TK_TINYINT

//   Comes from: 627:9: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_TRUE
 *
 * Looks to match the characters the constitute the token TK_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_TRUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_TRUE;
       
    
    // IQL.g:627:9: ( 'TRUE' )
    // IQL.g:627:11: 'TRUE'
    {
        MATCHS(lit_96); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_TRUEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_TRUEEx; /* Prevent compiler warnings */
    ruleTK_TRUEEx: ;

}
// $ANTLR end TK_TRUE

//   Comes from: 628:10: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_UNION
 *
 * Looks to match the characters the constitute the token TK_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_UNION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_UNION;
       
    
    // IQL.g:628:10: ( 'UNION' )
    // IQL.g:628:12: 'UNION'
    {
        MATCHS(lit_97); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_UNIONEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_UNIONEx; /* Prevent compiler warnings */
    ruleTK_UNIONEx: ;

}
// $ANTLR end TK_UNION

//   Comes from: 629:12: ( 'VARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_VARCHAR
 *
 * Looks to match the characters the constitute the token TK_VARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_VARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_VARCHAR;
       
    
    // IQL.g:629:12: ( 'VARCHAR' )
    // IQL.g:629:14: 'VARCHAR'
    {
        MATCHS(lit_98); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_VARCHAREx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_VARCHAREx; /* Prevent compiler warnings */
    ruleTK_VARCHAREx: ;

}
// $ANTLR end TK_VARCHAR

//   Comes from: 630:9: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHEN
 *
 * Looks to match the characters the constitute the token TK_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHEN;
       
    
    // IQL.g:630:9: ( 'WHEN' )
    // IQL.g:630:11: 'WHEN'
    {
        MATCHS(lit_99); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHENEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHENEx; /* Prevent compiler warnings */
    ruleTK_WHENEx: ;

}
// $ANTLR end TK_WHEN

//   Comes from: 631:10: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHERE
 *
 * Looks to match the characters the constitute the token TK_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHERE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHERE;
       
    
    // IQL.g:631:10: ( 'WHERE' )
    // IQL.g:631:12: 'WHERE'
    {
        MATCHS(lit_100); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHEREEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHEREEx; /* Prevent compiler warnings */
    ruleTK_WHEREEx: ;

}
// $ANTLR end TK_WHERE

//   Comes from: 632:10: ( 'WHILE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHILE
 *
 * Looks to match the characters the constitute the token TK_WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHILE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHILE;
       
    
    // IQL.g:632:10: ( 'WHILE' )
    // IQL.g:632:12: 'WHILE'
    {
        MATCHS(lit_101); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHILEEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHILEEx; /* Prevent compiler warnings */
    ruleTK_WHILEEx: ;

}
// $ANTLR end TK_WHILE

//   Comes from: 633:9: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WITH
 *
 * Looks to match the characters the constitute the token TK_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WITH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WITH;
       
    
    // IQL.g:633:9: ( 'WITH' )
    // IQL.g:633:11: 'WITH'
    {
        MATCHS(lit_102); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WITHEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WITHEx; /* Prevent compiler warnings */
    ruleTK_WITHEx: ;

}
// $ANTLR end TK_WITH

//   Comes from: 636:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL;
       
    
    // IQL.g:636:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:636:8: '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:636:13: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt1=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (LA1_0 == '\\') ) 
                {
                    alt1=1;
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= '[')) || ((LA1_0 >= ']') && (LA1_0 <= 0xFFFF))) ) 
                {
                    alt1=2;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // IQL.g:636:15: ESCAPE_SEQUENCE
        	    {
        	        /* 636:15: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:636:33: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 640:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WSTRING_LITERAL
 *
 * Looks to match the characters the constitute the token WSTRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WSTRING_LITERAL;
       
    
    // IQL.g:640:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:640:8: 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHS(lit_103); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:640:14: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt2=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                if ( (LA2_0 == '\\') ) 
                {
                    alt2=1;
                }
                else if ( (((LA2_0 >= 0x0000) && (LA2_0 <= '&')) || ((LA2_0 >= '(') && (LA2_0 <= '[')) || ((LA2_0 >= ']') && (LA2_0 <= 0xFFFF))) ) 
                {
                    alt2=2;
                }

            }
            switch (alt2) 
            {
        	case 1:
        	    // IQL.g:640:16: ESCAPE_SEQUENCE
        	    {
        	        /* 640:16: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleWSTRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:640:34: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleWSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleWSTRING_LITERALEx: ;

}
// $ANTLR end WSTRING_LITERAL

//   Comes from: 644:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTED_STRING_LITERAL
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTED_STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTED_STRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_QUOTED_STRING_LITERAL;
       
    
    // IQL.g:644:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
    // IQL.g:644:8: '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:644:12: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt3=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (LA3_0 == '\\') ) 
                {
                    alt3=1;
                }
                else if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= '[')) || ((LA3_0 >= ']') && (LA3_0 <= 0xFFFF))) ) 
                {
                    alt3=2;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // IQL.g:644:14: ESCAPE_SEQUENCE
        	    {
        	        /* 644:14: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:644:32: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTED_STRING_LITERALEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTED_STRING_LITERALEx: ;

}
// $ANTLR end DOUBLE_QUOTED_STRING_LITERAL

//   Comes from: 649:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESCAPE_SEQUENCE
 *
 * Looks to match the characters the constitute the token ESCAPE_SEQUENCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESCAPE_SEQUENCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:649:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
        
        ANTLR3_UINT32 alt4;

        alt4=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '"':
        		case '\'':
        		case 'B':
        		case 'F':
        		case 'N':
        		case 'R':
        		case 'T':
        		case '\\':
        		case 'b':
        		case 'f':
        		case 'n':
        		case 'r':
        		case 't':
        			{
        				alt4=1;
        			}
        		    break;
        		case 'u':
        			{
        				alt4=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				alt4=3;
        			}
        		    break;

        		default:
        		    if (BACKTRACKING>0)
        		    {
        		        FAILEDFLAG = ANTLR3_TRUE;
        		        return ;
        		    }
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 4;
        		    EXCEPTION->state        = 1;


        		    goto ruleESCAPE_SEQUENCEEx;
        		}

        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleESCAPE_SEQUENCEEx;
        }

        switch (alt4) 
        {
    	case 1:
    	    // IQL.g:649:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | 'B' | 'T' | 'N' | 'F' | 'R' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == 'B' || LA(1) == 'F' || LA(1) == 'N' || LA(1) == 'R' || LA(1) == 'T' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();
    	        FAILEDFLAG=ANTLR3_FALSE;

    	        }
    	        else 
    	        {
    	            if (BACKTRACKING>0)
    	            {
    	                FAILEDFLAG = ANTLR3_TRUE;
    	                return ;
    	            }
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleESCAPE_SEQUENCEEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:650:9: UNICODE_ESCAPE
    	    {
    	        /* 650:9: UNICODE_ESCAPE */
    	        mUNICODE_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:651:9: OCTAL_ESCAPE
    	    {
    	        /* 651:9: OCTAL_ESCAPE */
    	        mOCTAL_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESCAPE_SEQUENCEEx; /* Prevent compiler warnings */
    ruleESCAPE_SEQUENCEEx: ;

}
// $ANTLR end ESCAPE_SEQUENCE

//   Comes from: 656:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESCAPE
 *
 * Looks to match the characters the constitute the token OCTAL_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:656:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt5;

        alt5=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						switch ( LA(4) ) 
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        							{
        								alt5=1;
        							}
        						    break;

        						default:
        						    alt5=2;}

        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						alt5=2;
        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;

        		default:
        		    if (BACKTRACKING>0)
        		    {
        		        FAILEDFLAG = ANTLR3_TRUE;
        		        return ;
        		    }
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 1;


        		    goto ruleOCTAL_ESCAPEEx;
        		}

        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCAPEEx;
        }

        switch (alt5) 
        {
    	case 1:
    	    // IQL.g:656:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:656:14: ( '0' .. '3' )
    	        // IQL.g:656:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:656:25: ( '0' .. '7' )
    	        // IQL.g:656:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:656:36: ( '0' .. '7' )
    	        // IQL.g:656:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:657:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:657:14: ( '0' .. '7' )
    	        // IQL.g:657:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }

    	        // IQL.g:657:25: ( '0' .. '7' )
    	        // IQL.g:657:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;
    	case 3:
    	    // IQL.g:658:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:658:14: ( '0' .. '7' )
    	        // IQL.g:658:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }
    	            if (HASFAILED())
    	            {
    	                return ;
    	            }

    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCAPEEx; /* Prevent compiler warnings */
    ruleOCTAL_ESCAPEEx: ;

}
// $ANTLR end OCTAL_ESCAPE

//   Comes from: 663:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:663:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
    // IQL.g:663:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
    ruleHEX_DIGITEx: ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 667:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESCAPE
 *
 * Looks to match the characters the constitute the token UNICODE_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:667:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // IQL.g:667:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('u'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 667:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 667:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 667:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 667:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCAPEEx; /* Prevent compiler warnings */
    ruleUNICODE_ESCAPEEx: ;

}
// $ANTLR end UNICODE_ESCAPE

//   Comes from: 670:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;
       
    
    // IQL.g:670:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
    // IQL.g:670:8: ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSEx;
        }

        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 674:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ML_COMMENT
 *
 * Looks to match the characters the constitute the token ML_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mML_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ML_COMMENT;
       
    
    // IQL.g:674:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // IQL.g:674:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_104); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:674:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt6=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA6_0 = LA(1);
                if ( (LA6_0 == '*') ) 
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == '/') ) 
                        {
                            alt6=2;
                        }
                        else if ( (((LA6_1 >= 0x0000) && (LA6_1 <= '.')) || ((LA6_1 >= '0') && (LA6_1 <= 0xFFFF))) ) 
                        {
                            alt6=1;
                        }

                    }
                }
                else if ( (((LA6_0 >= 0x0000) && (LA6_0 <= ')')) || ((LA6_0 >= '+') && (LA6_0 <= 0xFFFF))) ) 
                {
                    alt6=1;
                }

            }
            switch (alt6) 
            {
        	case 1:
        	    // IQL.g:674:42: .
        	    {
        	        MATCHANY(); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleML_COMMENTEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

        	default:
        	    goto loop6;	/* break out of the loop */
        	    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */

        MATCHS(lit_105); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleML_COMMENTEx; /* Prevent compiler warnings */
    ruleML_COMMENTEx: ;

}
// $ANTLR end ML_COMMENT

//   Comes from: 678:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SL_COMMENT
 *
 * Looks to match the characters the constitute the token SL_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSL_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SL_COMMENT;
       
    
    // IQL.g:678:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // IQL.g:678:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_106); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }


        // IQL.g:678:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt7=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA7_0 = LA(1);
                if ( (((LA7_0 >= 0x0000) && (LA7_0 <= '\t')) || ((LA7_0 >= 0x000B) && (LA7_0 <= '\f')) || ((LA7_0 >= 0x000E) && (LA7_0 <= 0xFFFF))) ) 
                {
                    alt7=1;
                }

            }
            switch (alt7) 
            {
        	case 1:
        	    // IQL.g:678:12: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSL_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop7;	/* break out of the loop */
        	    break;
            }
        }
        loop7: ; /* Jump out to here if this rule does not match */


        // IQL.g:678:26: ( '\\r' )?
        {
            int alt8=2;
            switch ( LA(1) ) 
            {
                case '\r':
                	{
                		alt8=1;
                	}
                    break;
            }

            switch (alt8) 
            {
        	case 1:
        	    // IQL.g:678:26: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSL_COMMENTEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        if ( BACKTRACKING==0 ) 
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSL_COMMENTEx; /* Prevent compiler warnings */
    ruleSL_COMMENTEx: ;

}
// $ANTLR end SL_COMMENT

//   Comes from: 682:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ID;
       
    
    // IQL.g:682:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
    // IQL.g:682:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDEx;
        }


        // IQL.g:682:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*

        for (;;)
        {
            int alt9=2;
            switch ( LA(1) ) 
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt9=1;
            	}
                break;

            }

            switch (alt9) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop9;	/* break out of the loop */
        	    break;
            }
        }
        loop9: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 686:2: ( '`' (~ ( '`' ) )* '`' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTED_ID
 *
 * Looks to match the characters the constitute the token QUOTED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUOTED_ID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUOTED_ID;
       
    
    // IQL.g:686:2: ( '`' (~ ( '`' ) )* '`' )
    // IQL.g:686:4: '`' (~ ( '`' ) )* '`'
    {
        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:686:8: (~ ( '`' ) )*

        for (;;)
        {
            int alt10=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA10_0 = LA(1);
                if ( (((LA10_0 >= 0x0000) && (LA10_0 <= '_')) || ((LA10_0 >= 'a') && (LA10_0 <= 0xFFFF))) ) 
                {
                    alt10=1;
                }

            }
            switch (alt10) 
            {
        	case 1:
        	    // IQL.g:686:8: ~ ( '`' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '_')) || ((LA(1) >= 'a') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleQUOTED_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop10;	/* break out of the loop */
        	    break;
            }
        }
        loop10: ; /* Jump out to here if this rule does not match */

        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUOTED_IDEx; /* Prevent compiler warnings */
    ruleQUOTED_IDEx: ;

}
// $ANTLR end QUOTED_ID

//   Comes from: 692:2: ( 'L' 'L' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIGINT_SUFFIX
 *
 * Looks to match the characters the constitute the token BIGINT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIGINT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:692:2: ( 'L' 'L' )
    // IQL.g:692:4: 'L' 'L'
    {
        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleBIGINT_SUFFIXEx; /* Prevent compiler warnings */
    ruleBIGINT_SUFFIXEx: ;

}
// $ANTLR end BIGINT_SUFFIX

//   Comes from: 697:5: ( '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THREE_DIGIT_NUMBER
 *
 * Looks to match the characters the constitute the token THREE_DIGIT_NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHREE_DIGIT_NUMBER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:697:5: ( '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )? )
    // IQL.g:698:5: '0' .. '9' ( '0' .. '9' ( '0' .. '9' )? )?
    {
        MATCHRANGE('0', '9'); 
        if  (HASEXCEPTION())
        {
            goto ruleTHREE_DIGIT_NUMBEREx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:698:14: ( '0' .. '9' ( '0' .. '9' )? )?
        {
            int alt12=2;
            switch ( LA(1) ) 
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                	{
                		alt12=1;
                	}
                    break;
            }

            switch (alt12) 
            {
        	case 1:
        	    // IQL.g:698:15: '0' .. '9' ( '0' .. '9' )?
        	    {
        	        MATCHRANGE('0', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleTHREE_DIGIT_NUMBEREx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:698:24: ( '0' .. '9' )?
        	        {
        	            int alt11=2;
        	            switch ( LA(1) ) 
        	            {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11) 
        	            {
        	        	case 1:
        	        	    // IQL.g:698:25: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleTHREE_DIGIT_NUMBEREx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleTHREE_DIGIT_NUMBEREx; /* Prevent compiler warnings */
    ruleTHREE_DIGIT_NUMBEREx: ;

}
// $ANTLR end THREE_DIGIT_NUMBER

//   Comes from: 703:5: ( HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOUR_DIGIT_HEX
 *
 * Looks to match the characters the constitute the token FOUR_DIGIT_HEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOUR_DIGIT_HEX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:703:5: ( HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? )
    // IQL.g:703:7: HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )?
    {
        /* 703:7: HEX_DIGIT ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )? */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleFOUR_DIGIT_HEXEx;
        }
        if (HASFAILED())
        {
            return ;
        }

        // IQL.g:703:17: ( ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )? )?
        {
            int alt15=2;
            switch ( LA(1) ) 
            {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                	{
                		alt15=1;
                	}
                    break;
            }

            switch (alt15) 
            {
        	case 1:
        	    // IQL.g:703:18: ( HEX_DIGIT ) ( ( HEX_DIGIT ) ( HEX_DIGIT )? )?
        	    {
        	        // IQL.g:703:18: ( HEX_DIGIT )
        	        // IQL.g:703:19: HEX_DIGIT
        	        {
        	            /* 703:19: HEX_DIGIT */
        	            mHEX_DIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleFOUR_DIGIT_HEXEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }


        	        // IQL.g:703:30: ( ( HEX_DIGIT ) ( HEX_DIGIT )? )?
        	        {
        	            int alt14=2;
        	            switch ( LA(1) ) 
        	            {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                case 'A':
        	                case 'B':
        	                case 'C':
        	                case 'D':
        	                case 'E':
        	                case 'F':
        	                case 'a':
        	                case 'b':
        	                case 'c':
        	                case 'd':
        	                case 'e':
        	                case 'f':
        	                	{
        	                		alt14=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt14) 
        	            {
        	        	case 1:
        	        	    // IQL.g:703:31: ( HEX_DIGIT ) ( HEX_DIGIT )?
        	        	    {
        	        	        // IQL.g:703:31: ( HEX_DIGIT )
        	        	        // IQL.g:703:32: HEX_DIGIT
        	        	        {
        	        	            /* 703:32: HEX_DIGIT */
        	        	            mHEX_DIGIT(ctx ); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleFOUR_DIGIT_HEXEx;
        	        	            }
        	        	            if (HASFAILED())
        	        	            {
        	        	                return ;
        	        	            }

        	        	        }


        	        	        // IQL.g:703:43: ( HEX_DIGIT )?
        	        	        {
        	        	            int alt13=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	                case '0':
        	        	                case '1':
        	        	                case '2':
        	        	                case '3':
        	        	                case '4':
        	        	                case '5':
        	        	                case '6':
        	        	                case '7':
        	        	                case '8':
        	        	                case '9':
        	        	                case 'A':
        	        	                case 'B':
        	        	                case 'C':
        	        	                case 'D':
        	        	                case 'E':
        	        	                case 'F':
        	        	                case 'a':
        	        	                case 'b':
        	        	                case 'c':
        	        	                case 'd':
        	        	                case 'e':
        	        	                case 'f':
        	        	                	{
        	        	                		alt13=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt13) 
        	        	            {
        	        	        	case 1:
        	        	        	    // IQL.g:703:44: HEX_DIGIT
        	        	        	    {
        	        	        	        /* 703:44: HEX_DIGIT */
        	        	        	        mHEX_DIGIT(ctx ); 
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleFOUR_DIGIT_HEXEx;
        	        	        	        }
        	        	        	        if (HASFAILED())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleFOUR_DIGIT_HEXEx; /* Prevent compiler warnings */
    ruleFOUR_DIGIT_HEXEx: ;

}
// $ANTLR end FOUR_DIGIT_HEX

//   Comes from: 707:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token HEX_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HEX_INTEGER_LITERAL;
       
    
    // IQL.g:707:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
    // IQL.g:708:5: '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )?
    {
        MATCHC('0'); 
        if  (HASEXCEPTION())
        {
            goto ruleHEX_INTEGER_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_INTEGER_LITERALEx;
        }

        // IQL.g:708:19: ( HEX_DIGIT )+
        {
            int cnt16=0;

            for (;;)
            {
                int alt16=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        		{
        			alt16=1;
        		}
        	    break;

        	}

        	switch (alt16) 
        	{
        	    case 1:
        	        // IQL.g:708:19: HEX_DIGIT
        	        {
        	            /* 708:19: HEX_DIGIT */
        	            mHEX_DIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleHEX_INTEGER_LITERALEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt16 >= 1 )
        		{
        		    goto loop16;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_INTEGER_LITERALEx;
        	}
        	cnt16++;
            }
            loop16: ;	/* Jump to here if this rule does not match */
        }

        // IQL.g:708:30: ( BIGINT_SUFFIX )?
        {
            int alt17=2;
            switch ( LA(1) ) 
            {
                case 'L':
                	{
                		alt17=1;
                	}
                    break;
            }

            switch (alt17) 
            {
        	case 1:
        	    // IQL.g:708:30: BIGINT_SUFFIX
        	    {
        	        /* 708:30: BIGINT_SUFFIX */
        	        mBIGINT_SUFFIX(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEX_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEX_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleHEX_INTEGER_LITERALEx: ;

}
// $ANTLR end HEX_INTEGER_LITERAL

//   Comes from: 712:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_INTEGER_LITERAL;
       
    
    // IQL.g:712:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
    // IQL.g:713:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
    {

        // IQL.g:713:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt19=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt19=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt19=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_INTEGER_LITERALEx;
            }

            switch (alt19) 
            {
        	case 1:
        	    // IQL.g:713:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:713:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:713:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt18=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt18=1;
        	            	}
        	                break;

        	            }

        	            switch (alt18) 
        	            {
        	        	case 1:
        	        	    // IQL.g:713:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop18;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop18: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_INTEGER_LITERALEx: ;

}
// $ANTLR end DECIMAL_INTEGER_LITERAL

//   Comes from: 717:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_BIGINT_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_BIGINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_BIGINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_BIGINT_LITERAL;
       
    
    // IQL.g:717:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
    // IQL.g:718:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX
    {

        // IQL.g:718:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt21=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt21=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt21=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return ;
                }
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_BIGINT_LITERALEx;
            }

            switch (alt21) 
            {
        	case 1:
        	    // IQL.g:718:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	    }
        	    break;
        	case 2:
        	    // IQL.g:718:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return ;
        	        }

        	        // IQL.g:718:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt20=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt20=1;
        	            	}
        	                break;

        	            }

        	            switch (alt20) 
        	            {
        	        	case 1:
        	        	    // IQL.g:718:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return ;
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop20;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop20: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
        /* 718:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX */
        mBIGINT_SUFFIX(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_BIGINT_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_BIGINT_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_BIGINT_LITERALEx: ;

}
// $ANTLR end DECIMAL_BIGINT_LITERAL

//   Comes from: 722:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOATING_POINT_LITERAL
 *
 * Looks to match the characters the constitute the token FLOATING_POINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOATING_POINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOATING_POINT_LITERAL;
       
    
    {
        //  IQL.g:722:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
        
        ANTLR3_UINT32 alt30;

        alt30=3;

        alt30 = cdfa30.predict(ctx, RECOGNIZER, ISTREAM, &cdfa30);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATING_POINT_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt30) 
        {
    	case 1:
    	    // IQL.g:722:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        // IQL.g:722:9: ( '0' .. '9' )+
    	        {
    	            int cnt22=0;

    	            for (;;)
    	            {
    	                int alt22=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt22=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt22) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:722:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt22 >= 1 )
    	        		{
    	        		    goto loop22;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt22++;
    	            }
    	            loop22: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:722:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt23=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt23=1;
    	            	}
    	                break;

    	            }

    	            switch (alt23) 
    	            {
    	        	case 1:
    	        	    // IQL.g:722:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop23;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop23: ; /* Jump out to here if this rule does not match */

    	        /* 722:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:722:46: ( FLOAT_SUFFIX )?
    	        {
    	            int alt24=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt24=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt24) 
    	            {
    	        	case 1:
    	        	    // IQL.g:722:46: FLOAT_SUFFIX
    	        	    {
    	        	        /* 722:46: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:723:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:723:13: ( '0' .. '9' )+
    	        {
    	            int cnt25=0;

    	            for (;;)
    	            {
    	                int alt25=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt25=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt25) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:723:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt25 >= 1 )
    	        		{
    	        		    goto loop25;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt25++;
    	            }
    	            loop25: ;	/* Jump to here if this rule does not match */
    	        }
    	        /* 723:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:723:34: ( FLOAT_SUFFIX )?
    	        {
    	            int alt26=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt26=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt26) 
    	            {
    	        	case 1:
    	        	    // IQL.g:723:34: FLOAT_SUFFIX
    	        	    {
    	        	        /* 723:34: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:724:9: ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	    {
    	        // IQL.g:724:9: ( '0' .. '9' )+
    	        {
    	            int cnt27=0;

    	            for (;;)
    	            {
    	                int alt27=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt27=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt27) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:724:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt27 >= 1 )
    	        		{
    	        		    goto loop27;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt27++;
    	            }
    	            loop27: ;	/* Jump to here if this rule does not match */
    	        }

    	        // IQL.g:724:21: ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	        {
    	            int alt29=2;
    	            switch ( LA(1) ) 
    	            {
    	            case 'E':
    	            case 'e':
    	            	{
    	            		alt29=1;
    	            	}
    	                break;
    	            case 'D':
    	            case 'F':
    	            case 'd':
    	            case 'f':
    	            	{
    	            		alt29=2;
    	            	}
    	                break;

    	            default:
    	                if (BACKTRACKING>0)
    	                {
    	                    FAILEDFLAG = ANTLR3_TRUE;
    	                    return ;
    	                }
    	                CONSTRUCTEX();
    	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    	                EXCEPTION->message      = (void *)"";
    	                EXCEPTION->decisionNum  = 29;
    	                EXCEPTION->state        = 0;


    	                goto ruleFLOATING_POINT_LITERALEx;
    	            }

    	            switch (alt29) 
    	            {
    	        	case 1:
    	        	    // IQL.g:724:25: EXPONENT ( FLOAT_SUFFIX )?
    	        	    {
    	        	        /* 724:25: EXPONENT ( FLOAT_SUFFIX )? */
    	        	        mEXPONENT(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:724:34: ( FLOAT_SUFFIX )?
    	        	        {
    	        	            int alt28=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	                case 'D':
    	        	                case 'F':
    	        	                case 'd':
    	        	                case 'f':
    	        	                	{
    	        	                		alt28=1;
    	        	                	}
    	        	                    break;
    	        	            }

    	        	            switch (alt28) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:724:34: FLOAT_SUFFIX
    	        	        	    {
    	        	        	        /* 724:34: FLOAT_SUFFIX */
    	        	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	            }
    	        	        }

    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // IQL.g:725:9: FLOAT_SUFFIX
    	        	    {
    	        	        /* 725:9: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATING_POINT_LITERALEx; /* Prevent compiler warnings */
    ruleFLOATING_POINT_LITERALEx: ;

}
// $ANTLR end FLOATING_POINT_LITERAL

//   Comes from: 730:5: ( THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IPV4_LITERAL
 *
 * Looks to match the characters the constitute the token IPV4_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIPV4_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IPV4_LITERAL;
       
    
    // IQL.g:730:5: ( THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER )
    // IQL.g:731:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER
    {
        /* 731:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 731:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 731:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        /* 731:5: THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER '.' THREE_DIGIT_NUMBER */
        mTHREE_DIGIT_NUMBER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleIPV4_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIPV4_LITERALEx; /* Prevent compiler warnings */
    ruleIPV4_LITERALEx: ;

}
// $ANTLR end IPV4_LITERAL

//   Comes from: 735:5: ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IPV6_LITERAL
 *
 * Looks to match the characters the constitute the token IPV6_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIPV6_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IPV6_LITERAL;
       
    
    {
        //  IQL.g:735:5: ( ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? | FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ | ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )? )
        
        ANTLR3_UINT32 alt37;

        alt37=3;

        alt37 = cdfa37.predict(ctx, RECOGNIZER, ISTREAM, &cdfa37);
        if  (HASEXCEPTION())
        {
            goto ruleIPV6_LITERALEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt37) 
        {
    	case 1:
    	    // IQL.g:736:5: ':' ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	    {
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:736:13: ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	        {
    	            int alt32=2;
    	            switch ( LA(1) ) 
    	            {
    	                case '0':
    	                case '1':
    	                case '2':
    	                case '3':
    	                case '4':
    	                case '5':
    	                case '6':
    	                case '7':
    	                case '8':
    	                case '9':
    	                case 'A':
    	                case 'B':
    	                case 'C':
    	                case 'D':
    	                case 'E':
    	                case 'F':
    	                case 'a':
    	                case 'b':
    	                case 'c':
    	                case 'd':
    	                case 'e':
    	                case 'f':
    	                	{
    	                		alt32=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt32) 
    	            {
    	        	case 1:
    	        	    // IQL.g:736:14: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )*
    	        	    {
    	        	        /* 736:14: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* */
    	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleIPV6_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:736:29: ( ':' FOUR_DIGIT_HEX )*

    	        	        for (;;)
    	        	        {
    	        	            int alt31=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	            case ':':
    	        	            	{
    	        	            		alt31=1;
    	        	            	}
    	        	                break;

    	        	            }

    	        	            switch (alt31) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:736:30: ':' FOUR_DIGIT_HEX
    	        	        	    {
    	        	        	        MATCHC(':'); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }
    	        	        	        /* 736:30: ':' FOUR_DIGIT_HEX */
    	        	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	        	default:
    	        	        	    goto loop31;	/* break out of the loop */
    	        	        	    break;
    	        	            }
    	        	        }
    	        	        loop31: ; /* Jump out to here if this rule does not match */


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:738:5: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+
    	    {
    	        /* 738:5: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )+ */
    	        mFOUR_DIGIT_HEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:738:20: ( ':' FOUR_DIGIT_HEX )+
    	        {
    	            int cnt33=0;

    	            for (;;)
    	            {
    	                int alt33=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case ':':
    	        		{
    	        			alt33=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt33) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:738:21: ':' FOUR_DIGIT_HEX
    	        	        {
    	        	            MATCHC(':'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }
    	        	            /* 738:21: ':' FOUR_DIGIT_HEX */
    	        	            mFOUR_DIGIT_HEX(ctx ); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt33 >= 1 )
    	        		{
    	        		    goto loop33;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleIPV6_LITERALEx;
    	        	}
    	        	cnt33++;
    	            }
    	            loop33: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:740:5: ( ( FOUR_DIGIT_HEX ':' )+ ':' )=> ( FOUR_DIGIT_HEX ':' )+ ':' ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	    {
    	        // IQL.g:741:5: ( FOUR_DIGIT_HEX ':' )+
    	        {
    	            int cnt34=0;

    	            for (;;)
    	            {
    	                int alt34=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        	case 'A':
    	        	case 'B':
    	        	case 'C':
    	        	case 'D':
    	        	case 'E':
    	        	case 'F':
    	        	case 'a':
    	        	case 'b':
    	        	case 'c':
    	        	case 'd':
    	        	case 'e':
    	        	case 'f':
    	        		{
    	        			alt34=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt34) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:741:6: FOUR_DIGIT_HEX ':'
    	        	        {
    	        	            /* 741:6: FOUR_DIGIT_HEX ':' */
    	        	            mFOUR_DIGIT_HEX(ctx ); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }
    	        	            MATCHC(':'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleIPV6_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt34 >= 1 )
    	        		{
    	        		    goto loop34;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleIPV6_LITERALEx;
    	        	}
    	        	cnt34++;
    	            }
    	            loop34: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC(':'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleIPV6_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:742:5: ( FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* )?
    	        {
    	            int alt36=2;
    	            switch ( LA(1) ) 
    	            {
    	                case '0':
    	                case '1':
    	                case '2':
    	                case '3':
    	                case '4':
    	                case '5':
    	                case '6':
    	                case '7':
    	                case '8':
    	                case '9':
    	                case 'A':
    	                case 'B':
    	                case 'C':
    	                case 'D':
    	                case 'E':
    	                case 'F':
    	                case 'a':
    	                case 'b':
    	                case 'c':
    	                case 'd':
    	                case 'e':
    	                case 'f':
    	                	{
    	                		alt36=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt36) 
    	            {
    	        	case 1:
    	        	    // IQL.g:742:6: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )*
    	        	    {
    	        	        /* 742:6: FOUR_DIGIT_HEX ( ':' FOUR_DIGIT_HEX )* */
    	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleIPV6_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	        // IQL.g:742:21: ( ':' FOUR_DIGIT_HEX )*

    	        	        for (;;)
    	        	        {
    	        	            int alt35=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	            case ':':
    	        	            	{
    	        	            		alt35=1;
    	        	            	}
    	        	                break;

    	        	            }

    	        	            switch (alt35) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:742:22: ':' FOUR_DIGIT_HEX
    	        	        	    {
    	        	        	        MATCHC(':'); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }
    	        	        	        /* 742:22: ':' FOUR_DIGIT_HEX */
    	        	        	        mFOUR_DIGIT_HEX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleIPV6_LITERALEx;
    	        	        	        }
    	        	        	        if (HASFAILED())
    	        	        	        {
    	        	        	            return ;
    	        	        	        }

    	        	        	    }
    	        	        	    break;

    	        	        	default:
    	        	        	    goto loop35;	/* break out of the loop */
    	        	        	    break;
    	        	            }
    	        	        }
    	        	        loop35: ; /* Jump out to here if this rule does not match */


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIPV6_LITERALEx; /* Prevent compiler warnings */
    ruleIPV6_LITERALEx: ;

}
// $ANTLR end IPV6_LITERAL

//   Comes from: 748:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:748:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // IQL.g:748:4: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleEXPONENTEx;
        }


        // IQL.g:748:14: ( '+' | '-' )?
        {
            int alt38=2;
            switch ( LA(1) ) 
            {
                case '+':
                case '-':
                	{
                		alt38=1;
                	}
                    break;
            }

            switch (alt38) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();
        	        FAILEDFLAG=ANTLR3_FALSE;

        	        }
        	        else 
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return ;
        	            }
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }
        // IQL.g:748:25: ( '0' .. '9' )+
        {
            int cnt39=0;

            for (;;)
            {
                int alt39=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt39=1;
        		}
        	    break;

        	}

        	switch (alt39) 
        	{
        	    case 1:
        	        // IQL.g:748:26: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleEXPONENTEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt39 >= 1 )
        		{
        		    goto loop39;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt39++;
            }
            loop39: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 754:2: ( 'f' | 'F' | 'd' | 'D' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT_SUFFIX
 *
 * Looks to match the characters the constitute the token FLOAT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:754:2: ( 'f' | 'F' | 'd' | 'D' )
    // IQL.g:
    {
        if ( LA(1) == 'D' || LA(1) == 'F' || LA(1) == 'd' || LA(1) == 'f' )
        {
            CONSUME();
        FAILEDFLAG=ANTLR3_FALSE;

        }
        else 
        {
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFLOAT_SUFFIXEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFLOAT_SUFFIXEx; /* Prevent compiler warnings */
    ruleFLOAT_SUFFIXEx: ;

}
// $ANTLR end FLOAT_SUFFIX

//   Comes from: 758:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_LITERAL;
       
    
    {
        //  IQL.g:758:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
        
        ANTLR3_UINT32 alt43;

        alt43=2;

        switch ( LA(1) ) 
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
        		alt43=1;
        	}
            break;
        case '.':
        	{
        		alt43=2;
        	}
            break;

        default:
            if (BACKTRACKING>0)
            {
                FAILEDFLAG = ANTLR3_TRUE;
                return ;
            }
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 43;
            EXCEPTION->state        = 0;


            goto ruleDECIMAL_LITERALEx;
        }

        switch (alt43) 
        {
    	case 1:
    	    // IQL.g:758:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )*
    	    {
    	        // IQL.g:758:9: ( '0' .. '9' )+
    	        {
    	            int cnt40=0;

    	            for (;;)
    	            {
    	                int alt40=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt40=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt40) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:758:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt40 >= 1 )
    	        		{
    	        		    goto loop40;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt40++;
    	            }
    	            loop40: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	        // IQL.g:758:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt41=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt41=1;
    	            	}
    	                break;

    	            }

    	            switch (alt41) 
    	            {
    	        	case 1:
    	        	    // IQL.g:758:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleDECIMAL_LITERALEx;
    	        	        }
    	        	        if (HASFAILED())
    	        	        {
    	        	            return ;
    	        	        }

    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop41;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop41: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // IQL.g:759:9: '.' ( '0' .. '9' )+
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }
    	        // IQL.g:759:13: ( '0' .. '9' )+
    	        {
    	            int cnt42=0;

    	            for (;;)
    	            {
    	                int alt42=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt42=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt42) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:759:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }
    	        	            if (HASFAILED())
    	        	            {
    	        	                return ;
    	        	            }

    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt42 >= 1 )
    	        		{
    	        		    goto loop42;
    	        		}
    	        		if (BACKTRACKING>0)
    	        		{
    	        		    FAILEDFLAG = ANTLR3_TRUE;
    	        		    return ;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt42++;
    	            }
    	            loop42: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_LITERALEx: ;

}
// $ANTLR end DECIMAL_LITERAL

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pIQLLexer ctx)
{
    {
        //  IQL.g:1:8: ( T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | T__134 | T__135 | T__136 | T__137 | T__138 | T__139 | T__140 | T__141 | T__142 | T__143 | T__144 | T__145 | T__146 | T__147 | T__148 | T__149 | T__150 | T__151 | T__152 | T__153 | T__154 | T__155 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_ARRAY | TK_ARRAY_CONCAT | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_CIDRV4 | TK_CIDRV6 | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECLTYPE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IPV4 | TK_IPV6 | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_REAL | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_ROW | TK_SELECT | TK_SET | TK_SMALLINT | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TINYINT | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | IPV4_LITERAL | IPV6_LITERAL | DECIMAL_LITERAL )
        
        ANTLR3_UINT32 alt44;

        alt44=140;

        alt44 = cdfa44.predict(ctx, RECOGNIZER, ISTREAM, &cdfa44);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }
        if (HASFAILED())
        {
            return ;
        }
        switch (alt44) 
        {
    	case 1:
    	    // IQL.g:1:10: T__122
    	    {
    	        /* 1:10: T__122 */
    	        mT__122(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:1:17: T__123
    	    {
    	        /* 1:17: T__123 */
    	        mT__123(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:1:24: T__124
    	    {
    	        /* 1:24: T__124 */
    	        mT__124(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 4:
    	    // IQL.g:1:31: T__125
    	    {
    	        /* 1:31: T__125 */
    	        mT__125(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 5:
    	    // IQL.g:1:38: T__126
    	    {
    	        /* 1:38: T__126 */
    	        mT__126(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 6:
    	    // IQL.g:1:45: T__127
    	    {
    	        /* 1:45: T__127 */
    	        mT__127(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 7:
    	    // IQL.g:1:52: T__128
    	    {
    	        /* 1:52: T__128 */
    	        mT__128(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 8:
    	    // IQL.g:1:59: T__129
    	    {
    	        /* 1:59: T__129 */
    	        mT__129(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 9:
    	    // IQL.g:1:66: T__130
    	    {
    	        /* 1:66: T__130 */
    	        mT__130(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 10:
    	    // IQL.g:1:73: T__131
    	    {
    	        /* 1:73: T__131 */
    	        mT__131(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 11:
    	    // IQL.g:1:80: T__132
    	    {
    	        /* 1:80: T__132 */
    	        mT__132(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 12:
    	    // IQL.g:1:87: T__133
    	    {
    	        /* 1:87: T__133 */
    	        mT__133(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 13:
    	    // IQL.g:1:94: T__134
    	    {
    	        /* 1:94: T__134 */
    	        mT__134(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 14:
    	    // IQL.g:1:101: T__135
    	    {
    	        /* 1:101: T__135 */
    	        mT__135(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 15:
    	    // IQL.g:1:108: T__136
    	    {
    	        /* 1:108: T__136 */
    	        mT__136(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 16:
    	    // IQL.g:1:115: T__137
    	    {
    	        /* 1:115: T__137 */
    	        mT__137(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 17:
    	    // IQL.g:1:122: T__138
    	    {
    	        /* 1:122: T__138 */
    	        mT__138(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 18:
    	    // IQL.g:1:129: T__139
    	    {
    	        /* 1:129: T__139 */
    	        mT__139(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 19:
    	    // IQL.g:1:136: T__140
    	    {
    	        /* 1:136: T__140 */
    	        mT__140(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 20:
    	    // IQL.g:1:143: T__141
    	    {
    	        /* 1:143: T__141 */
    	        mT__141(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 21:
    	    // IQL.g:1:150: T__142
    	    {
    	        /* 1:150: T__142 */
    	        mT__142(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 22:
    	    // IQL.g:1:157: T__143
    	    {
    	        /* 1:157: T__143 */
    	        mT__143(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 23:
    	    // IQL.g:1:164: T__144
    	    {
    	        /* 1:164: T__144 */
    	        mT__144(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 24:
    	    // IQL.g:1:171: T__145
    	    {
    	        /* 1:171: T__145 */
    	        mT__145(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 25:
    	    // IQL.g:1:178: T__146
    	    {
    	        /* 1:178: T__146 */
    	        mT__146(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 26:
    	    // IQL.g:1:185: T__147
    	    {
    	        /* 1:185: T__147 */
    	        mT__147(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 27:
    	    // IQL.g:1:192: T__148
    	    {
    	        /* 1:192: T__148 */
    	        mT__148(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 28:
    	    // IQL.g:1:199: T__149
    	    {
    	        /* 1:199: T__149 */
    	        mT__149(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 29:
    	    // IQL.g:1:206: T__150
    	    {
    	        /* 1:206: T__150 */
    	        mT__150(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 30:
    	    // IQL.g:1:213: T__151
    	    {
    	        /* 1:213: T__151 */
    	        mT__151(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 31:
    	    // IQL.g:1:220: T__152
    	    {
    	        /* 1:220: T__152 */
    	        mT__152(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 32:
    	    // IQL.g:1:227: T__153
    	    {
    	        /* 1:227: T__153 */
    	        mT__153(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 33:
    	    // IQL.g:1:234: T__154
    	    {
    	        /* 1:234: T__154 */
    	        mT__154(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 34:
    	    // IQL.g:1:241: T__155
    	    {
    	        /* 1:241: T__155 */
    	        mT__155(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 35:
    	    // IQL.g:1:248: TK_ADD
    	    {
    	        /* 1:248: TK_ADD */
    	        mTK_ADD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 36:
    	    // IQL.g:1:255: TK_ALL
    	    {
    	        /* 1:255: TK_ALL */
    	        mTK_ALL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 37:
    	    // IQL.g:1:262: TK_ALTER
    	    {
    	        /* 1:262: TK_ALTER */
    	        mTK_ALTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 38:
    	    // IQL.g:1:271: TK_AND
    	    {
    	        /* 1:271: TK_AND */
    	        mTK_AND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 39:
    	    // IQL.g:1:278: TK_ANY
    	    {
    	        /* 1:278: TK_ANY */
    	        mTK_ANY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 40:
    	    // IQL.g:1:285: TK_ARRAY
    	    {
    	        /* 1:285: TK_ARRAY */
    	        mTK_ARRAY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 41:
    	    // IQL.g:1:294: TK_ARRAY_CONCAT
    	    {
    	        /* 1:294: TK_ARRAY_CONCAT */
    	        mTK_ARRAY_CONCAT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 42:
    	    // IQL.g:1:310: TK_AS
    	    {
    	        /* 1:310: TK_AS */
    	        mTK_AS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 43:
    	    // IQL.g:1:316: TK_ASC
    	    {
    	        /* 1:316: TK_ASC */
    	        mTK_ASC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 44:
    	    // IQL.g:1:323: TK_AVG
    	    {
    	        /* 1:323: TK_AVG */
    	        mTK_AVG(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 45:
    	    // IQL.g:1:330: TK_BEGIN
    	    {
    	        /* 1:330: TK_BEGIN */
    	        mTK_BEGIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 46:
    	    // IQL.g:1:339: TK_BETWEEN
    	    {
    	        /* 1:339: TK_BETWEEN */
    	        mTK_BETWEEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 47:
    	    // IQL.g:1:350: TK_BIGINT
    	    {
    	        /* 1:350: TK_BIGINT */
    	        mTK_BIGINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 48:
    	    // IQL.g:1:360: TK_BOOLEAN
    	    {
    	        /* 1:360: TK_BOOLEAN */
    	        mTK_BOOLEAN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 49:
    	    // IQL.g:1:371: TK_BREAK
    	    {
    	        /* 1:371: TK_BREAK */
    	        mTK_BREAK(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 50:
    	    // IQL.g:1:380: TK_BY
    	    {
    	        /* 1:380: TK_BY */
    	        mTK_BY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 51:
    	    // IQL.g:1:386: TK_CASE
    	    {
    	        /* 1:386: TK_CASE */
    	        mTK_CASE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 52:
    	    // IQL.g:1:394: TK_CAST
    	    {
    	        /* 1:394: TK_CAST */
    	        mTK_CAST(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 53:
    	    // IQL.g:1:402: TK_CHAR
    	    {
    	        /* 1:402: TK_CHAR */
    	        mTK_CHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 54:
    	    // IQL.g:1:410: TK_CIDRV4
    	    {
    	        /* 1:410: TK_CIDRV4 */
    	        mTK_CIDRV4(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 55:
    	    // IQL.g:1:420: TK_CIDRV6
    	    {
    	        /* 1:420: TK_CIDRV6 */
    	        mTK_CIDRV6(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 56:
    	    // IQL.g:1:430: TK_COALESCE
    	    {
    	        /* 1:430: TK_COALESCE */
    	        mTK_COALESCE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 57:
    	    // IQL.g:1:442: TK_CONTINUE
    	    {
    	        /* 1:442: TK_CONTINUE */
    	        mTK_CONTINUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 58:
    	    // IQL.g:1:454: TK_COUNT
    	    {
    	        /* 1:454: TK_COUNT */
    	        mTK_COUNT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 59:
    	    // IQL.g:1:463: TK_CREATE
    	    {
    	        /* 1:463: TK_CREATE */
    	        mTK_CREATE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 60:
    	    // IQL.g:1:473: TK_CROSS
    	    {
    	        /* 1:473: TK_CROSS */
    	        mTK_CROSS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 61:
    	    // IQL.g:1:482: TK_DATETIME
    	    {
    	        /* 1:482: TK_DATETIME */
    	        mTK_DATETIME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 62:
    	    // IQL.g:1:494: TK_DECLARE
    	    {
    	        /* 1:494: TK_DECLARE */
    	        mTK_DECLARE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 63:
    	    // IQL.g:1:505: TK_DECLTYPE
    	    {
    	        /* 1:505: TK_DECLTYPE */
    	        mTK_DECLTYPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 64:
    	    // IQL.g:1:517: TK_DECIMAL
    	    {
    	        /* 1:517: TK_DECIMAL */
    	        mTK_DECIMAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 65:
    	    // IQL.g:1:528: TK_DESC
    	    {
    	        /* 1:528: TK_DESC */
    	        mTK_DESC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 66:
    	    // IQL.g:1:536: TK_DISTINCT
    	    {
    	        /* 1:536: TK_DISTINCT */
    	        mTK_DISTINCT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 67:
    	    // IQL.g:1:548: TK_DOUBLE
    	    {
    	        /* 1:548: TK_DOUBLE */
    	        mTK_DOUBLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 68:
    	    // IQL.g:1:558: TK_ELSE
    	    {
    	        /* 1:558: TK_ELSE */
    	        mTK_ELSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 69:
    	    // IQL.g:1:566: TK_END
    	    {
    	        /* 1:566: TK_END */
    	        mTK_END(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 70:
    	    // IQL.g:1:573: TK_EXISTS
    	    {
    	        /* 1:573: TK_EXISTS */
    	        mTK_EXISTS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 71:
    	    // IQL.g:1:583: TK_FALSE
    	    {
    	        /* 1:583: TK_FALSE */
    	        mTK_FALSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 72:
    	    // IQL.g:1:592: TK_FROM
    	    {
    	        /* 1:592: TK_FROM */
    	        mTK_FROM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 73:
    	    // IQL.g:1:600: TK_FULL
    	    {
    	        /* 1:600: TK_FULL */
    	        mTK_FULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 74:
    	    // IQL.g:1:608: TK_FUNCTION
    	    {
    	        /* 1:608: TK_FUNCTION */
    	        mTK_FUNCTION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 75:
    	    // IQL.g:1:620: TK_GROUP
    	    {
    	        /* 1:620: TK_GROUP */
    	        mTK_GROUP(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 76:
    	    // IQL.g:1:629: TK_HAVING
    	    {
    	        /* 1:629: TK_HAVING */
    	        mTK_HAVING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 77:
    	    // IQL.g:1:639: TK_IF
    	    {
    	        /* 1:639: TK_IF */
    	        mTK_IF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 78:
    	    // IQL.g:1:645: TK_IN
    	    {
    	        /* 1:645: TK_IN */
    	        mTK_IN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 79:
    	    // IQL.g:1:651: TK_INDEX
    	    {
    	        /* 1:651: TK_INDEX */
    	        mTK_INDEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 80:
    	    // IQL.g:1:660: TK_INNER
    	    {
    	        /* 1:660: TK_INNER */
    	        mTK_INNER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 81:
    	    // IQL.g:1:669: TK_INTO
    	    {
    	        /* 1:669: TK_INTO */
    	        mTK_INTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 82:
    	    // IQL.g:1:677: TK_INTEGER
    	    {
    	        /* 1:677: TK_INTEGER */
    	        mTK_INTEGER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 83:
    	    // IQL.g:1:688: TK_INTERVAL
    	    {
    	        /* 1:688: TK_INTERVAL */
    	        mTK_INTERVAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 84:
    	    // IQL.g:1:700: TK_IPV4
    	    {
    	        /* 1:700: TK_IPV4 */
    	        mTK_IPV4(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 85:
    	    // IQL.g:1:708: TK_IPV6
    	    {
    	        /* 1:708: TK_IPV6 */
    	        mTK_IPV6(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 86:
    	    // IQL.g:1:716: TK_IS
    	    {
    	        /* 1:716: TK_IS */
    	        mTK_IS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 87:
    	    // IQL.g:1:722: TK_JOIN
    	    {
    	        /* 1:722: TK_JOIN */
    	        mTK_JOIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 88:
    	    // IQL.g:1:730: TK_KEY
    	    {
    	        /* 1:730: TK_KEY */
    	        mTK_KEY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 89:
    	    // IQL.g:1:737: TK_LEFT
    	    {
    	        /* 1:737: TK_LEFT */
    	        mTK_LEFT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 90:
    	    // IQL.g:1:745: TK_LIKE
    	    {
    	        /* 1:745: TK_LIKE */
    	        mTK_LIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 91:
    	    // IQL.g:1:753: TK_MAX
    	    {
    	        /* 1:753: TK_MAX */
    	        mTK_MAX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 92:
    	    // IQL.g:1:760: TK_MIN
    	    {
    	        /* 1:760: TK_MIN */
    	        mTK_MIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 93:
    	    // IQL.g:1:767: TK_NOT
    	    {
    	        /* 1:767: TK_NOT */
    	        mTK_NOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 94:
    	    // IQL.g:1:774: TK_NULL
    	    {
    	        /* 1:774: TK_NULL */
    	        mTK_NULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 95:
    	    // IQL.g:1:782: TK_NVARCHAR
    	    {
    	        /* 1:782: TK_NVARCHAR */
    	        mTK_NVARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 96:
    	    // IQL.g:1:794: TK_ON
    	    {
    	        /* 1:794: TK_ON */
    	        mTK_ON(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 97:
    	    // IQL.g:1:800: TK_OR
    	    {
    	        /* 1:800: TK_OR */
    	        mTK_OR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 98:
    	    // IQL.g:1:806: TK_ORDER
    	    {
    	        /* 1:806: TK_ORDER */
    	        mTK_ORDER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 99:
    	    // IQL.g:1:815: TK_OUTER
    	    {
    	        /* 1:815: TK_OUTER */
    	        mTK_OUTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 100:
    	    // IQL.g:1:824: TK_OUTPUT
    	    {
    	        /* 1:824: TK_OUTPUT */
    	        mTK_OUTPUT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 101:
    	    // IQL.g:1:834: TK_PRECISION
    	    {
    	        /* 1:834: TK_PRECISION */
    	        mTK_PRECISION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 102:
    	    // IQL.g:1:847: TK_PRINT
    	    {
    	        /* 1:847: TK_PRINT */
    	        mTK_PRINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 103:
    	    // IQL.g:1:856: TK_PROCEDURE
    	    {
    	        /* 1:856: TK_PROCEDURE */
    	        mTK_PROCEDURE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 104:
    	    // IQL.g:1:869: TK_RAISERROR
    	    {
    	        /* 1:869: TK_RAISERROR */
    	        mTK_RAISERROR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 105:
    	    // IQL.g:1:882: TK_REAL
    	    {
    	        /* 1:882: TK_REAL */
    	        mTK_REAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 106:
    	    // IQL.g:1:890: TK_RETURN
    	    {
    	        /* 1:890: TK_RETURN */
    	        mTK_RETURN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 107:
    	    // IQL.g:1:900: TK_RETURNS
    	    {
    	        /* 1:900: TK_RETURNS */
    	        mTK_RETURNS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 108:
    	    // IQL.g:1:911: TK_RIGHT
    	    {
    	        /* 1:911: TK_RIGHT */
    	        mTK_RIGHT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 109:
    	    // IQL.g:1:920: TK_RLIKE
    	    {
    	        /* 1:920: TK_RLIKE */
    	        mTK_RLIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 110:
    	    // IQL.g:1:929: TK_ROW
    	    {
    	        /* 1:929: TK_ROW */
    	        mTK_ROW(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 111:
    	    // IQL.g:1:936: TK_SELECT
    	    {
    	        /* 1:936: TK_SELECT */
    	        mTK_SELECT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 112:
    	    // IQL.g:1:946: TK_SET
    	    {
    	        /* 1:946: TK_SET */
    	        mTK_SET(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 113:
    	    // IQL.g:1:953: TK_SMALLINT
    	    {
    	        /* 1:953: TK_SMALLINT */
    	        mTK_SMALLINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 114:
    	    // IQL.g:1:965: TK_SOME
    	    {
    	        /* 1:965: TK_SOME */
    	        mTK_SOME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 115:
    	    // IQL.g:1:973: TK_SUM
    	    {
    	        /* 1:973: TK_SUM */
    	        mTK_SUM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 116:
    	    // IQL.g:1:980: TK_SWITCH
    	    {
    	        /* 1:980: TK_SWITCH */
    	        mTK_SWITCH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 117:
    	    // IQL.g:1:990: TK_THEN
    	    {
    	        /* 1:990: TK_THEN */
    	        mTK_THEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 118:
    	    // IQL.g:1:998: TK_TINYINT
    	    {
    	        /* 1:998: TK_TINYINT */
    	        mTK_TINYINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 119:
    	    // IQL.g:1:1009: TK_TRUE
    	    {
    	        /* 1:1009: TK_TRUE */
    	        mTK_TRUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 120:
    	    // IQL.g:1:1017: TK_UNION
    	    {
    	        /* 1:1017: TK_UNION */
    	        mTK_UNION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 121:
    	    // IQL.g:1:1026: TK_VARCHAR
    	    {
    	        /* 1:1026: TK_VARCHAR */
    	        mTK_VARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 122:
    	    // IQL.g:1:1037: TK_WHEN
    	    {
    	        /* 1:1037: TK_WHEN */
    	        mTK_WHEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 123:
    	    // IQL.g:1:1045: TK_WHERE
    	    {
    	        /* 1:1045: TK_WHERE */
    	        mTK_WHERE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 124:
    	    // IQL.g:1:1054: TK_WHILE
    	    {
    	        /* 1:1054: TK_WHILE */
    	        mTK_WHILE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 125:
    	    // IQL.g:1:1063: TK_WITH
    	    {
    	        /* 1:1063: TK_WITH */
    	        mTK_WITH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 126:
    	    // IQL.g:1:1071: STRING_LITERAL
    	    {
    	        /* 1:1071: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 127:
    	    // IQL.g:1:1086: WSTRING_LITERAL
    	    {
    	        /* 1:1086: WSTRING_LITERAL */
    	        mWSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 128:
    	    // IQL.g:1:1102: DOUBLE_QUOTED_STRING_LITERAL
    	    {
    	        /* 1:1102: DOUBLE_QUOTED_STRING_LITERAL */
    	        mDOUBLE_QUOTED_STRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 129:
    	    // IQL.g:1:1131: WS
    	    {
    	        /* 1:1131: WS */
    	        mWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 130:
    	    // IQL.g:1:1134: ML_COMMENT
    	    {
    	        /* 1:1134: ML_COMMENT */
    	        mML_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 131:
    	    // IQL.g:1:1145: SL_COMMENT
    	    {
    	        /* 1:1145: SL_COMMENT */
    	        mSL_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 132:
    	    // IQL.g:1:1156: ID
    	    {
    	        /* 1:1156: ID */
    	        mID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 133:
    	    // IQL.g:1:1159: QUOTED_ID
    	    {
    	        /* 1:1159: QUOTED_ID */
    	        mQUOTED_ID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 134:
    	    // IQL.g:1:1169: HEX_INTEGER_LITERAL
    	    {
    	        /* 1:1169: HEX_INTEGER_LITERAL */
    	        mHEX_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 135:
    	    // IQL.g:1:1189: DECIMAL_INTEGER_LITERAL
    	    {
    	        /* 1:1189: DECIMAL_INTEGER_LITERAL */
    	        mDECIMAL_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 136:
    	    // IQL.g:1:1213: DECIMAL_BIGINT_LITERAL
    	    {
    	        /* 1:1213: DECIMAL_BIGINT_LITERAL */
    	        mDECIMAL_BIGINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 137:
    	    // IQL.g:1:1236: FLOATING_POINT_LITERAL
    	    {
    	        /* 1:1236: FLOATING_POINT_LITERAL */
    	        mFLOATING_POINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 138:
    	    // IQL.g:1:1259: IPV4_LITERAL
    	    {
    	        /* 1:1259: IPV4_LITERAL */
    	        mIPV4_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 139:
    	    // IQL.g:1:1272: IPV6_LITERAL
    	    {
    	        /* 1:1272: IPV6_LITERAL */
    	        mIPV6_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;
    	case 140:
    	    // IQL.g:1:1285: DECIMAL_LITERAL
    	    {
    	        /* 1:1285: DECIMAL_LITERAL */
    	        mDECIMAL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }
    	        if (HASFAILED())
    	        {
    	            return ;
    	        }

    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

// $ANTLR start synpred1_IQL
static void synpred1_IQL_fragment(pIQLLexer ctx ) 
{
    // IQL.g:740:5: ( ( FOUR_DIGIT_HEX ':' )+ ':' )
    // IQL.g:740:6: ( FOUR_DIGIT_HEX ':' )+ ':'
    {
        // IQL.g:740:6: ( FOUR_DIGIT_HEX ':' )+
        {
            int cnt45=0;

            for (;;)
            {
                int alt45=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        		{
        			alt45=1;
        		}
        	    break;

        	}

        	switch (alt45) 
        	{
        	    case 1:
        	        // IQL.g:740:7: FOUR_DIGIT_HEX ':'
        	        {
        	            /* 740:7: FOUR_DIGIT_HEX ':' */
        	            mFOUR_DIGIT_HEX(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_IQLEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }
        	            MATCHC(':'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred1_IQLEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }

        	        }
        	        break;

        	    default:
        	    
        		if ( cnt45 >= 1 )
        		{
        		    goto loop45;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred1_IQLEx;
        	}
        	cnt45++;
            }
            loop45: ;	/* Jump to here if this rule does not match */
        }
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_IQLEx;
        }
        if (HASFAILED())
        {
            return ;
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred1_IQLEx; /* Prevent compiler warnings */
rulesynpred1_IQLEx: ;

}
// $ANTLR end synpred1_IQL

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */

/* =========================================================================
 * Lexer syntactic predicates
 */
static ANTLR3_BOOLEAN synpred1_IQL(pIQLLexer ctx) 
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_IQL_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
